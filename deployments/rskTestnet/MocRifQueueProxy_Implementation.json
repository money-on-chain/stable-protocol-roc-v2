{
  "address": "0x242feAAa38fDFe00B091Aea13C8772f8c45f7d07",
  "abi": [
    {
      "inputs": [],
      "name": "BucketAlreadyRegistered",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ExecutionFeePaymentFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAllowOnNoneEmptyQueue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAuthorizedChanger",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotWhenPaused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyPauser",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyWhilePaused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Unstoppable",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "expectedValue",
          "type": "uint256"
        }
      ],
      "name": "WrongExecutionFee",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previousAdmin",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "AdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "beacon",
          "type": "address"
        }
      ],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes4",
          "name": "errorCode_",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "msg_",
          "type": "string"
        }
      ],
      "name": "OperationError",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "executor",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "OperationExecuted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "bucket_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "enum MocQueue.OperType",
          "name": "operType_",
          "type": "uint8"
        }
      ],
      "name": "OperationQueued",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qAC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TCMinted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qAC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TCRedeemed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tp_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTP_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TCSwappedForTP",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tp_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTP_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qAC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TCandTPMinted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tp_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTP_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qAC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TCandTPRedeemed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tp",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTP_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qAC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TPMinted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tp_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTP_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qAC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TPRedeemed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tp_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTP_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTC_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TPSwappedForTC",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "tpFrom_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "tpTo_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender_",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTPfrom_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qTPto_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACfee_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeToken_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qACVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "qFeeTokenVendorMarkup_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "vendor_",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        }
      ],
      "name": "TPSwappedForTP",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "operId_",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "reason_",
          "type": "bytes"
        }
      ],
      "name": "UnhandledError",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DEFAULT_ADMIN_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IGovernor",
          "name": "newGovernor_",
          "type": "address"
        }
      ],
      "name": "changeGovernor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "executionFeeRecipient",
          "type": "address"
        }
      ],
      "name": "execute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "firstOperId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        }
      ],
      "name": "getRoleAdmin",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governor",
      "outputs": [
        {
          "internalType": "contract IGovernor",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "governor_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "pauser_",
          "type": "address"
        },
        {
          "internalType": "uint128",
          "name": "minOperWaitingBlk_",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "maxOperPerBatch_",
          "type": "uint128"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tcMintExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tcRedeemExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tpMintExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tpRedeemExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "swapTPforTPExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "swapTPforTCExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "swapTCforTPExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "redeemTCandTPExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "mintTCandTPExecFee",
              "type": "uint256"
            }
          ],
          "internalType": "struct MocQueueExecFees.InitializeMocQueueExecFeesParams",
          "name": "mocQueueExecFeesParams_",
          "type": "tuple"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isEmpty",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "makeStoppable",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "makeUnstoppable",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxOperPerBatch",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minOperWaitingBlk",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mintTCandTPExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "mocCore",
      "outputs": [
        {
          "internalType": "contract MocCARC20Deferred",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "operIdCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsMintTC",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "qTC",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmax",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsMintTCandTP",
      "outputs": [
        {
          "internalType": "address",
          "name": "tp",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "qTP",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmax",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsMintTP",
      "outputs": [
        {
          "internalType": "address",
          "name": "tp",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "qTP",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmax",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsRedeemTC",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "qTC",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmin",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsRedeemTCandTP",
      "outputs": [
        {
          "internalType": "address",
          "name": "tp",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "qTC",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qTP",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmin",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsRedeemTP",
      "outputs": [
        {
          "internalType": "address",
          "name": "tp",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "qTP",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmin",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsSwapTCforTP",
      "outputs": [
        {
          "internalType": "address",
          "name": "tp",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "qTC",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qTPmin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmax",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsSwapTPforTC",
      "outputs": [
        {
          "internalType": "address",
          "name": "tp",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "qTP",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qTCmin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmax",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "operationsSwapTPforTP",
      "outputs": [
        {
          "internalType": "address",
          "name": "tpFrom",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tpTo",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "qTP",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qTPmin",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "qACmax",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vendor",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "opersInfo",
      "outputs": [
        {
          "internalType": "enum MocQueue.OperType",
          "name": "operType",
          "type": "uint8"
        },
        {
          "internalType": "uint248",
          "name": "queuedBlk",
          "type": "uint248"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pauser",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "qTC",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmax",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCore.MintTCParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueMintTC",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tp",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "qTP",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmax",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCommons.MintTCandTPParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueMintTCandTP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tp",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "qTP",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmax",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCore.MintTPParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueMintTP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "qTC",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmin",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCore.RedeemTCParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueRedeemTC",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tp",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "qTC",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qTP",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmin",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCommons.RedeemTCandTPParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueRedeemTCandTP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tp",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "qTP",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmin",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCommons.RedeemTPParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueRedeemTP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tp",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "qTC",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qTPmin",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmax",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCommons.SwapTCforTPParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueSwapTCforTP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tp",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "qTP",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qTCmin",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmax",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCommons.SwapTPforTCParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueSwapTPforTC",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tpFrom",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tpTo",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "qTP",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qTPmin",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "qACmax",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vendor",
              "type": "address"
            }
          ],
          "internalType": "struct MocCommons.SwapTPforTPParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "queueSwapTPforTP",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "operId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "readyToExecute",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "redeemTCandTPExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract MocCARC20Deferred",
          "name": "bucket_",
          "type": "address"
        }
      ],
      "name": "registerBucket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "renounceRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "maxOperPerBatch_",
          "type": "uint128"
        }
      ],
      "name": "setMaxOperPerBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "minOperWaitingBlk_",
          "type": "uint128"
        }
      ],
      "name": "setMinOperWaitingBlk",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newPauser_",
          "type": "address"
        }
      ],
      "name": "setPauser",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "stoppable",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "swapTCforTPExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "swapTPforTCExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "swapTPforTPExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tcMintExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tcRedeemExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tpMintExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tpRedeemExecFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tcMintExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tcRedeemExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tpMintExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tpRedeemExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "swapTPforTPExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "swapTPforTCExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "swapTCforTPExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "redeemTCandTPExecFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "mintTCandTPExecFee",
              "type": "uint256"
            }
          ],
          "internalType": "struct MocQueueExecFees.InitializeMocQueueExecFeesParams",
          "name": "mocQueueExecFeesParams_",
          "type": "tuple"
        }
      ],
      "name": "updateExecutionFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4f764d59955e8a2e9656f13351407756586e4957f4820a6cd278f12998f9b6af",
  "receipt": {
    "to": null,
    "from": "0xB4776c2bd17DF529b98Ea31661D9d852EaBDd217",
    "contractAddress": "0x242feAAa38fDFe00B091Aea13C8772f8c45f7d07",
    "transactionIndex": 3,
    "gasUsed": "5191619",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5b2ada31d23b8cc6b44213b03f8fbf483b0af946843a83db9b24d11c79aacd72",
    "transactionHash": "0x4f764d59955e8a2e9656f13351407756586e4957f4820a6cd278f12998f9b6af",
    "logs": [],
    "blockNumber": 4564118,
    "cumulativeGasUsed": "5413784",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "e8a4ab8ee3ae12243351eea9f9fc8121",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BucketAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecutionFeePaymentFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAllowOnNoneEmptyQueue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorizedChanger\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWhenPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPauser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyWhilePaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unstoppable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedValue\",\"type\":\"uint256\"}],\"name\":\"WrongExecutionFee\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"errorCode_\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"msg_\",\"type\":\"string\"}],\"name\":\"OperationError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"OperationExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bucket_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum MocQueue.OperType\",\"name\":\"operType_\",\"type\":\"uint8\"}],\"name\":\"OperationQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qAC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TCMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qAC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TCRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tp_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTP_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TCSwappedForTP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tp_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTP_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qAC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TCandTPMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tp_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTP_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qAC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TCandTPRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTP_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qAC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TPMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tp_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTP_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qAC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TPRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tp_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTP_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTC_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TPSwappedForTC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tpFrom_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tpTo_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTPfrom_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qTPto_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACfee_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeToken_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qACVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qFeeTokenVendorMarkup_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vendor_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"}],\"name\":\"TPSwappedForTP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operId_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason_\",\"type\":\"bytes\"}],\"name\":\"UnhandledError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGovernor\",\"name\":\"newGovernor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionFeeRecipient\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstOperId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"contract IGovernor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauser_\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"minOperWaitingBlk_\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"maxOperPerBatch_\",\"type\":\"uint128\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tcMintExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tcRedeemExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tpMintExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tpRedeemExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapTPforTPExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapTPforTCExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapTCforTPExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemTCandTPExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTCandTPExecFee\",\"type\":\"uint256\"}],\"internalType\":\"struct MocQueueExecFees.InitializeMocQueueExecFeesParams\",\"name\":\"mocQueueExecFeesParams_\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEmpty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeStoppable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeUnstoppable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxOperPerBatch\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOperWaitingBlk\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintTCandTPExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mocCore\",\"outputs\":[{\"internalType\":\"contract MocCARC20Deferred\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operIdCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsMintTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsMintTCandTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsMintTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsRedeemTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsRedeemTCandTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsRedeemTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsSwapTCforTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTPmin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsSwapTPforTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTCmin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operationsSwapTPforTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tpFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tpTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTPmin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"opersInfo\",\"outputs\":[{\"internalType\":\"enum MocQueue.OperType\",\"name\":\"operType\",\"type\":\"uint8\"},{\"internalType\":\"uint248\",\"name\":\"queuedBlk\",\"type\":\"uint248\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCore.MintTCParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueMintTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCommons.MintTCandTPParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueMintTCandTP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCore.MintTPParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueMintTP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCore.RedeemTCParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueRedeemTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCommons.RedeemTCandTPParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueRedeemTCandTP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCommons.RedeemTPParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueRedeemTP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTPmin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCommons.SwapTCforTPParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueSwapTCforTP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTCmin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCommons.SwapTPforTCParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueSwapTPforTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tpFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tpTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qTP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qTPmin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qACmax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vendor\",\"type\":\"address\"}],\"internalType\":\"struct MocCommons.SwapTPforTPParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"queueSwapTPforTP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"operId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readyToExecute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemTCandTPExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MocCARC20Deferred\",\"name\":\"bucket_\",\"type\":\"address\"}],\"name\":\"registerBucket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"maxOperPerBatch_\",\"type\":\"uint128\"}],\"name\":\"setMaxOperPerBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"minOperWaitingBlk_\",\"type\":\"uint128\"}],\"name\":\"setMinOperWaitingBlk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser_\",\"type\":\"address\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stoppable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTCforTPExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTPforTCExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTPforTPExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tcMintExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tcRedeemExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tpMintExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tpRedeemExecFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tcMintExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tcRedeemExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tpMintExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tpRedeemExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapTPforTPExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapTPforTCExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapTCforTPExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemTCandTPExecFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTCandTPExecFee\",\"type\":\"uint256\"}],\"internalType\":\"struct MocQueueExecFees.InitializeMocQueueExecFeesParams\",\"name\":\"mocQueueExecFeesParams_\",\"type\":\"tuple\"}],\"name\":\"updateExecutionFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"AdminChanged(address,address)\":{\"details\":\"Emitted when the admin account has changed.\"},\"BeaconUpgraded(address)\":{\"details\":\"Emitted when the beacon is changed.\"},\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"},\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"},\"Upgraded(address)\":{\"details\":\"Emitted when the implementation is upgraded.\"}},\"kind\":\"dev\",\"methods\":{\"changeGovernor(address)\":{\"params\":{\"newGovernor_\":\"New governor address\"}},\"execute(address)\":{\"details\":\"does not revert on Operation failure, throws Process and Error events according to the Oper type and result\"},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"makeStoppable()\":{\"details\":\"Should be called through governance\"},\"makeUnstoppable()\":{\"details\":\"Should be called through governance\"},\"pause()\":{\"details\":\"Should only be called by the pauser and when it is stoppable\"},\"proxiableUUID()\":{\"details\":\"Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\"},\"queueMintTC((uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueMintTCandTP((address,uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueMintTP((address,uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueRedeemTC((uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueRedeemTP((address,uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueSwapTCforTP((address,uint256,uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueSwapTPforTC((address,uint256,uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"queueSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))\":{\"returns\":{\"operId\":\"Identifier to track the Operation lifecycle\"}},\"registerBucket(address)\":{\"details\":\"in order to operate, the queue needs to be whitelisted as EXECUTOR on the bucket as well\",\"params\":{\"bucket_\":\"address of the mocCore implementation to interact with May emit a {RoleGranted} event for ENQUEUER role\"}},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event.\"},\"setMaxOperPerBatch(uint128)\":{\"params\":{\"maxOperPerBatch_\":\"maximum amount of operations allowed on a batch to avoid going over the block gas limit\"}},\"setMinOperWaitingBlk(uint128)\":{\"params\":{\"minOperWaitingBlk_\":\"minimum amount of blocks an operation needs to remain in the queue before it can be executed\"}},\"setPauser(address)\":{\"details\":\"Should be called through governance\",\"params\":{\"newPauser_\":\"Address of the new pauser\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"upgradeTo(address)\":{\"custom:oz-upgrades-unsafe-allow-reachable\":\"delegatecall\",\"details\":\"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"},\"upgradeToAndCall(address,bytes)\":{\"custom:oz-upgrades-unsafe-allow-reachable\":\"delegatecall\",\"details\":\"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.\"}},\"stateVariables\":{\"__gap\":{\"details\":\"This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain. See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\"}},\"title\":\"MocQueue: Allows queue Operation deferral execution processing\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"changeGovernor(address)\":{\"notice\":\"Change the contract's governor. Should be called through the old governance system\"},\"execute(address)\":{\"notice\":\"registered executors can process Operations in the queue\"},\"governor()\":{\"notice\":\"The address of the contract which governs this one\"},\"isEmpty()\":{\"notice\":\"true if the queue is empty\"},\"makeStoppable()\":{\"notice\":\"Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function\"},\"makeUnstoppable()\":{\"notice\":\"Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so\"},\"pause()\":{\"notice\":\"Called by the owner to pause, triggers stopped state\"},\"paused()\":{\"notice\":\"Returns true if paused\"},\"queueMintTC((uint256,uint256,address,address,address))\":{\"notice\":\"registered enqueuer can queue an Operations\"},\"queueMintTCandTP((address,uint256,uint256,address,address,address))\":{\"notice\":\"Registered enqueuer can queue an Operations\"},\"queueMintTP((address,uint256,uint256,address,address,address))\":{\"notice\":\"registered enqueuer can queue an Operations\"},\"queueRedeemTC((uint256,uint256,address,address,address))\":{\"notice\":\"registered enqueuer can queue an Operations\"},\"queueRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))\":{\"notice\":\"Registered enqueuer can queue an Operations\"},\"queueRedeemTP((address,uint256,uint256,address,address,address))\":{\"notice\":\"Registered enqueuer can queue an Operations\"},\"queueSwapTCforTP((address,uint256,uint256,uint256,address,address,address))\":{\"notice\":\"Registered enqueuer can queue an Operations\"},\"queueSwapTPforTC((address,uint256,uint256,uint256,address,address,address))\":{\"notice\":\"Registered enqueuer can queue an Operations\"},\"queueSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))\":{\"notice\":\"Registered enqueuer can queue an Operations\"},\"readyToExecute()\":{\"notice\":\"true if the queue has at least one Operation ready to be executed\"},\"registerBucket(address)\":{\"notice\":\"registers the mocCore bucket that would operate over this queue\"},\"setMaxOperPerBatch(uint128)\":{\"notice\":\"sets Moc Queue maximum amount of operations per execution batch\"},\"setMinOperWaitingBlk(uint128)\":{\"notice\":\"sets Moc Queue minimum operation waiting blocks\"},\"setPauser(address)\":{\"notice\":\"Changes the address which is enable to pause this contract\"},\"unpause()\":{\"notice\":\"Called by the owner to unpause, returns to normal state\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"moc-main/contracts/queue/MocQueue.sol\":\"MocQueue\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul[j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTOtfDnca[r]Iulc]jmul[jul]VcTOculjmul:fDnTOc\",\"stackAllocation\":true}},\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"./AccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\\n    function __AccessControlEnumerable_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        super._grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        super._revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xc2dfd6ba9449f61b6b03b262182faf302f093a8c05dd10792aeecb4ed1663c0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xfeefb24d068524440e1ba885efdf105d91f83504af3c2d745ffacc4595396831\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x7acbc538aad6eb4614e26612a8c5c0149bb8808db95e2638d245a8365f63e572\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0xb8f5302f12138c5561362e88a78d061573e6298b7a1a5afe84a1e2c8d4d5aeaa\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0x47d6e06872b12e72c79d1b5eb55842f860b5fb1207b2317c2358d2766b950a7b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x77c89f893e403efc6929ba842b7ccf6534d4ffe03afe31670b4a528c0ad78c0f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x584ebdf9c1118a7c773f98788e3f3ede01982bdf8932aa06f5acc7d54876e161\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x24b86ac8c005b8c654fbf6ac34a5a4f61580d7273541e83e013e89d66fbf0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb607cb94c27e89750f5ae2ccebcb94e654e926f6125f4fd4c6262c89875118ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x40c636b4572ff5f1dc50cf22097e93c0723ee14eff87e99ac2b02636eeca1250\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xb82ef33f43b6b96109687d91b39c94573fdccaaa423fe28e8ba0977b31c023e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xd14a627157b9a411d2410713e5dd3a377e9064bd5c194a90748bbf27ea625784\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../security/PausableUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n *\\n * IMPORTANT: This contract does not include public pause and unpause functions. In\\n * addition to inheriting this contract, you must define both functions, invoking the\\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\\n * make the contract unpausable.\\n */\\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\\n    function __ERC20Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xf0bd7f71ffae5f0addd375e8511fbf2ad8ca0c9b2606c32d92bdda7d76a7a81c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xd60f939a3ca0199014d079b4dd66aa757954334947d81eb5c1d35d7a83061ab3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x4dae161227d332808312ee2caf6384929321b83c16cc89b5642985fbec6b814c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x07ac95acad040f1fb1f6120dd0aa5f702db69446e95f82613721879d30de0908\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\nimport \\\"./math/SignedMathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMathUpgradeable.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0xb96dc79b65b7c37937919dcdb356a969ce0aa2e8338322bf4dc027a3c9c9a7eb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2bc0007987c229ae7624eb29be6a9b84f6a6a5872f76248b15208b131ea41c4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMathUpgradeable {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x88f6b7bba3ee33eeb741f9a0f5bc98b6e6e352d0fe4905377bb328590f84095a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x1c65595a26548a1b2263315b08a56334a2d7087319814437559c3c96025e939f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0x3cbef5ebc24b415252e2f8c0c9254555d30d9f085603b4b80d9b5ed20ab87e90\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3b21ae06bf5957f73fa16754b0669c77b7abd8ba6c072d35c3281d446fdb86c2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf09e68aa0dc6722a25bc46490e8d48ed864466d17313b8a0b254c36b54e49899\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"moc-main/contracts/collateral/rc20/MocCARC20Deferred.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocCore } from \\\"../../core/MocCore.sol\\\";\\nimport { MocQueue, ENQUEUER_ROLE } from \\\"../../queue/MocQueue.sol\\\";\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @title MocCARC20Deferred: Moc Collateral Asset RC20 with deferred operations\\n * @notice Moc protocol implementation using a RC20 as Collateral Asset.\\n */\\ncontract MocCARC20Deferred is MocCore {\\n    // ------- Structs -------\\n    struct InitializeParams {\\n        InitializeCoreParams initializeCoreParams;\\n        // Collateral Asset Token contract address\\n        address acTokenAddress;\\n        address mocQueue;\\n    }\\n\\n    // ------- Storage -------\\n\\n    // Collateral Asset token\\n    IERC20 public acToken;\\n\\n    // amount of AC locked on pending operations\\n    uint256 public qACLockedInPending;\\n\\n    // Queue\\n    MocQueue public mocQueue;\\n\\n    modifier onlyMocQueue() {\\n        //TODO\\n        require(msg.sender == address(mocQueue), \\\"NOT queue\\\");\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    // ------- Initializer -------\\n    /**\\n     * @notice contract initializer\\n     * @param initializeParams_ contract initializer params\\n     * @dev governorAddress The address that will define when a change contract is authorized\\n     *      pauserAddress The address that is authorized to pause this contract\\n     *      acTokenAddress Collateral Asset Token contract address\\n     *      tcTokenAddress Collateral Token contract address\\n     *      mocFeeFlowAddress Moc Fee Flow contract address\\n     *      mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address\\n     *      protThrld protected state threshold [PREC]\\n     *      liqThrld liquidation coverage threshold [PREC]\\n     *      feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]\\n     *      tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]\\n     *      tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]\\n     *      successFee pct of the gain because Pegged Tokens devaluation that is transferred\\n     *        in Collateral Asset to Moc Fee Flow during the settlement [PREC]\\n     *      appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned\\n     *        in Pegged Tokens to appreciation beneficiary during the settlement [PREC]\\n     *      bes number of blocks between settlements\\n     *      tcInterestCollectorAddress TC interest collector address\\n     *      tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]\\n     *      tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment\\n     *      maxAbsoluteOpProviderAddress max absolute operation provider address\\n     *      maxOpDiffProviderAddress max operation difference provider address\\n     *      decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0\\n     *      emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation\\n     *      mocVendors address for MocVendors contract\\n     */\\n    function initialize(InitializeParams calldata initializeParams_) external initializer {\\n        acToken = IERC20(initializeParams_.acTokenAddress);\\n        __MocCore_init(initializeParams_.initializeCoreParams);\\n        mocQueue = MocQueue(initializeParams_.mocQueue);\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * @inheritdoc MocCore\\n     * @dev this function could revert during safeTransfer call.\\n     *  safeTransfer will revert if token transfer reverts or returns 0\\n     * IMPORTANT: if an ERC777 is used as Collateral, this transfer gasLimit should be capped\\n     */\\n    function acTransfer(address to_, uint256 amount_) internal override {\\n        if (amount_ > 0) {\\n            SafeERC20.safeTransfer(acToken, to_, amount_);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc MocCore\\n     */\\n    function acBalanceOf(address account) internal view override returns (uint256 balance) {\\n        return acToken.balanceOf(account);\\n    }\\n\\n    /**\\n     * @notice hook before any AC reception involving operation, as dealing with a deferred RC20 Token\\n     * funds have already been transferred to the contract, so we need to return the unused\\n     * @param qACMax_ max amount of AC available\\n     * @param qACNeeded_ amount of AC needed\\n     * @return change amount needed to be return to the sender after the operation is complete\\n     */\\n    function _onACNeededOperation(uint256 qACMax_, uint256 qACNeeded_) internal override returns (uint256 change) {\\n        // As we locked qACMax, we need to return the extra amount\\n        // TODO: review this\\n        change = qACMax_ - qACNeeded_;\\n        // All locked AC is either unlock or returned, no longer on pending Operation\\n        qACLockedInPending -= qACMax_;\\n    }\\n\\n    /**\\n     * @notice Refreshes the AC holdings for the Bucket\\n     * @dev Intended to be use as notification after an RC20 AC transfer to this contract\\n     */\\n    function refreshACBalance() external {\\n        uint256 unaccountedAcBalance = acBalanceOf(address(this)) - nACcb - qACLockedInPending;\\n        // On this implementation, AC token balance is nACcb plus AC locked on pending operations\\n        if (unaccountedAcBalance > 0) _depositAC(unaccountedAcBalance);\\n    }\\n\\n    // Do nothing on Operation hooks, as event is later on emitted with OperId in context\\n\\n    /* solhint-disable no-empty-blocks */\\n    function onTCMinted(MintTCParams memory p_, uint256 qAC_, FeeCalcs memory fc_) internal override {}\\n\\n    function onTCRedeemed(RedeemTCParams memory p_, uint256 qAC_, FeeCalcs memory fc_) internal override {}\\n\\n    function onTPMinted(MintTPParams memory p_, uint256 qAC_, FeeCalcs memory fc_) internal override {}\\n\\n    function onTPRedeemed(RedeemTPParams memory p_, uint256 qAC_, FeeCalcs memory fc_) internal override {}\\n\\n    function onTCandTPMinted(\\n        MintTCandTPParams memory p_,\\n        uint256 qTC_,\\n        uint256 qAC_,\\n        FeeCalcs memory fc_\\n    ) internal override {}\\n\\n    function onTCandTPRedeemed(\\n        RedeemTCandTPParams memory p_,\\n        uint256 qTP_,\\n        uint256 qAC_,\\n        FeeCalcs memory fc_\\n    ) internal override {}\\n\\n    function onTCSwappedForTP(SwapTCforTPParams memory p_, uint256 qTP_, FeeCalcs memory fc_) internal override {}\\n\\n    function onTPSwappedForTC(SwapTPforTCParams memory p_, uint256 qTC_, FeeCalcs memory fc_) internal override {}\\n\\n    function onTPSwappedForTP(SwapTPforTPParams memory p_, uint256 qTP_, FeeCalcs memory fc_) internal override {}\\n\\n    /* solhint-enable no-empty-blocks */\\n\\n    /**\\n     * @notice while registering a pending Operation, we need to lock user's funds until it's executed\\n     * @param qACToLock_ AC amount to be locked\\n     */\\n    function _lockACInPending(uint256 qACToLock_) internal {\\n        qACLockedInPending += qACToLock_;\\n        SafeERC20.safeTransferFrom(acToken, msg.sender, address(this), qACToLock_);\\n    }\\n\\n    /**\\n     * @notice while registering a pending Operation, we need to lock user's tokens until it's executed\\n     * @param qTCToLock_ TC amount to be locked\\n     */\\n    function _lockTCInPending(uint256 qTCToLock_) internal {\\n        SafeERC20Upgradeable.safeTransferFrom(tcToken, msg.sender, address(this), qTCToLock_);\\n    }\\n\\n    /**\\n     * @notice while registering a pending Operation, we need to lock user's tokens until it's executed\\n     * @param qTPToLock_ TP amount to be locked\\n     */\\n    function _lockTPInPending(IERC20Upgradeable tpToken, uint256 qTPToLock_) internal {\\n        SafeERC20Upgradeable.safeTransferFrom(tpToken, msg.sender, address(this), qTPToLock_);\\n    }\\n\\n    // ------- External Functions -------\\n\\n    /**\\n     * @notice caller sends Collateral Asset and receives Collateral Token\\n        Requires prior sender approval of Collateral Asset to this contract \\n     * @param qTC_ amount of Collateral Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTC(uint256 qTC_, uint256 qACmax_) external payable returns (uint256 operId) {\\n        return mintTCtoViaVendor(qTC_, qACmax_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and receives Collateral Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     *  Requires prior sender approval of Collateral Asset to this contract\\n     * @param qTC_ amount of Collateral Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTCViaVendor(uint256 qTC_, uint256 qACmax_, address vendor_) external payable returns (uint256 operId) {\\n        return mintTCtoViaVendor(qTC_, qACmax_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and recipient receives Collateral Token\\n     *  Requires prior sender approval of Collateral Asset to this contract\\n     * @param qTC_ amount of Collateral Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param recipient_ address who receives the Collateral Token\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTCto(uint256 qTC_, uint256 qACmax_, address recipient_) external payable returns (uint256 operId) {\\n        return mintTCtoViaVendor(qTC_, qACmax_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and recipient receives Collateral Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     *   Requires prior sender approval of Collateral Asset to this contract\\n     * @param qTC_ amount of Collateral Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param recipient_ address who receives the Collateral Token\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTCtoViaVendor(\\n        uint256 qTC_,\\n        uint256 qACmax_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        MintTCParams memory params = MintTCParams({\\n            qTC: qTC_,\\n            qACmax: qACmax_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueMintTC{ value: msg.value }(params);\\n        _lockACInPending(qACmax_);\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Token and receives Collateral Asset\\n     * @param qTC_ amount of Collateral Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that sender expects to receive\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTC(uint256 qTC_, uint256 qACmin_) external payable returns (uint256 operId) {\\n        return redeemTCtoViaVendor(qTC_, qACmin_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Token and receives Collateral Asset\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param qTC_ amount of Collateral Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that sender expects to receive\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTCViaVendor(\\n        uint256 qTC_,\\n        uint256 qACmin_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return redeemTCtoViaVendor(qTC_, qACmin_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Token and recipient receives Collateral Asset\\n     * @param qTC_ amount of Collateral Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     * @param recipient_ address who receives the Collateral Asset\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTCto(uint256 qTC_, uint256 qACmin_, address recipient_) external payable returns (uint256 operId) {\\n        return redeemTCtoViaVendor(qTC_, qACmin_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Token and recipient receives Collateral Asset\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param qTC_ amount of Collateral Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     * @param recipient_ address who receives the Collateral Asset\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTCtoViaVendor(\\n        uint256 qTC_,\\n        uint256 qACmin_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        RedeemTCParams memory params = RedeemTCParams({\\n            qTC: qTC_,\\n            qACmin: qACmin_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueRedeemTC{ value: msg.value }(params);\\n        _lockTCInPending(qTC_);\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and receives Pegged Token\\n        Requires prior sender approval of Collateral Asset to this contract\\n     * @param tp_ Pegged Token address to mint\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTP(address tp_, uint256 qTP_, uint256 qACmax_) external payable returns (uint256 operId) {\\n        return mintTPtoViaVendor(tp_, qTP_, qACmax_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and receives Pegged Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     *   Requires prior sender approval of Collateral Asset to this contract\\n     * @param tp_ Pegged Token address to mint\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTPViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmax_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return mintTPtoViaVendor(tp_, qTP_, qACmax_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and recipient receives Pegged Token\\n        Requires prior sender approval of Collateral Asset to this contract\\n     * @param tp_ Pegged Token address to mint\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param recipient_ address who receives the Pegged Token\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTPto(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmax_,\\n        address recipient_\\n    ) external payable returns (uint256 operId) {\\n        return mintTPtoViaVendor(tp_, qTP_, qACmax_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and recipient receives Pegged Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     *   Requires prior sender approval of Collateral Asset to this contract\\n     * @param tp_ Pegged Token address to mint\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param recipient_ address who receives the Pegged Token\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTPtoViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmax_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        MintTPParams memory params = MintTPParams({\\n            tp: tp_,\\n            qTP: qTP_,\\n            qACmax: qACmax_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueMintTP{ value: msg.value }(params);\\n        _lockACInPending(qACmax_);\\n    }\\n\\n    /**\\n     * @notice caller sends Pegged Token and receives Collateral Asset\\n     * @param tp_ Pegged Token address to redeem\\n     * @param qTP_ amount of Pegged Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that sender expects to receive\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTP(address tp_, uint256 qTP_, uint256 qACmin_) external payable returns (uint256 operId) {\\n        return redeemTPtoViaVendor(tp_, qTP_, qACmin_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Pegged Token and receives Collateral Asset\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param tp_ Pegged Token address to redeem\\n     * @param qTP_ amount of Pegged Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that sender expects to receive\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTPViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmin_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return redeemTPtoViaVendor(tp_, qTP_, qACmin_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice caller sends Pegged Token and recipient receives Collateral Asset\\n     * @param tp_ Pegged Token address to redeem\\n     * @param qTP_ amount of Pegged Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     * @param recipient_ address who receives the Collateral Asset\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTPto(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmin_,\\n        address recipient_\\n    ) external payable returns (uint256 operId) {\\n        return redeemTPtoViaVendor(tp_, qTP_, qACmin_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Pegged Token and recipient receives Collateral Asset\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param tp_ Pegged Token address to redeem\\n     * @param qTP_ amount of Pegged Token to redeem\\n     * @param qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     * @param recipient_ address who receives the Collateral Asset\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTPtoViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmin_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        RedeemTPParams memory params = RedeemTPParams({\\n            tp: tp_,\\n            qTP: qTP_,\\n            qACmin: qACmin_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueRedeemTP{ value: msg.value }(params);\\n        _lockTPInPending(IERC20Upgradeable(tp_), qTP_);\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and receives Collateral Token and Pegged Token\\n     *  Requires prior sender approval of Collateral Asset to this contract\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are minted in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qAC sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTCandTP(address tp_, uint256 qTP_, uint256 qACmax_) external payable returns (uint256 operId) {\\n        return mintTCandTPtoViaVendor(tp_, qTP_, qACmax_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and receives Collateral Token and Pegged Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     *  Requires prior sender approval of Collateral Asset to this contract\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are minted in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qAC sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTCandTPViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmax_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return mintTCandTPtoViaVendor(tp_, qTP_, qACmax_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token\\n     *  Requires prior sender approval of Collateral Asset to this contract\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are minted in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qAC sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param recipient_ address who receives the Collateral Token and Pegged Token\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTCandTPto(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmax_,\\n        address recipient_\\n    ) external payable returns (uint256 operId) {\\n        return mintTCandTPtoViaVendor(tp_, qTP_, qACmax_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends Collateral Asset and recipient receives Collateral Token and Pegged Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     *  Requires prior sender approval of Collateral Asset to this contract\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are minted in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qAC sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent\\n     * @param recipient_ address who receives the Collateral Token and Pegged Token\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function mintTCandTPtoViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qACmax_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        MintTCandTPParams memory params = MintTCandTPParams({\\n            tp: tp_,\\n            qTP: qTP_,\\n            qACmax: qACmax_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueMintTCandTP{ value: msg.value }(params);\\n        _lockACInPending(qACmax_);\\n    }\\n\\n    /**\\n     * @notice Caller sends Collateral Token and Pegged Token and receives Collateral Asset.\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price\\n     *  and global coverage are not modified.\\n     *  Reverts if qTP sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Maximum amount of Collateral Token to redeem\\n     * @param qTP_ Maximum amount of Pegged Token to redeem\\n     * @param qACmin_ Minimum amount of Collateral Asset that the sender expects to receive\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTCandTP(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 qACmin_\\n    ) external payable returns (uint256 operId) {\\n        return redeemTCandTPtoViaVendor(tp_, qTC_, qTP_, qACmin_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice Caller sends Collateral Token and Pegged Token and receives Collateral Asset.\\n     *  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price\\n     *  and global coverage are not modified.\\n     *  Reverts if qTP sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Maximum amount of Collateral Token to redeem\\n     * @param qTP_ Maximum amount of Pegged Token to redeem\\n     * @param qACmin_ Minimum amount of Collateral Asset that the sender expects to receive\\n     * @param vendor_ Address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTCandTPViaVendor(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 qACmin_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return redeemTCandTPtoViaVendor(tp_, qTC_, qTP_, qACmin_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price\\n     *  and global coverage are not modified.\\n     *  Reverts if qTP sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Maximum amount of Collateral Token to redeem\\n     * @param qTP_ Maximum amount of Pegged Token to redeem\\n     * @param qACmin_ Minimum amount of Collateral Asset that `recipient_` expects to receive\\n     * @param recipient_ Address who receives the Collateral Asset\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTCandTPto(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 qACmin_,\\n        address recipient_\\n    ) external payable returns (uint256 operId) {\\n        return redeemTCandTPtoViaVendor(tp_, qTC_, qTP_, qACmin_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice Caller sends Collateral Token and Pegged Token and recipient receives Collateral Asset.\\n     *  `vendor_` receives a markup in Fee Token if possible or in Collateral Asset if not\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are redeemed in equivalent proportions so that their price\\n     *  and global coverage are not modified.\\n     *  Reverts if qTP sent are insufficient.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Maximum amount of Collateral Token to redeem\\n     * @param qTP_ Maximum amount of Pegged Token to redeem\\n     * @param qACmin_ Minimum amount of Collateral Asset that `recipient_` expects to receive\\n     * @param recipient_ Address who receives the Collateral Asset\\n     * @param vendor_ Address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function redeemTCandTPtoViaVendor(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 qACmin_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        RedeemTCandTPParams memory params = RedeemTCandTPParams({\\n            tp: tp_,\\n            qTC: qTC_,\\n            qTP: qTP_,\\n            qACmin: qACmin_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueRedeemTCandTP{ value: msg.value }(params);\\n        _lockTCInPending(qTC_);\\n        _lockTPInPending(IERC20Upgradeable(tp_), qTP_);\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and receives another one\\n     * @param tpFrom_ owned Pegged Token address\\n     * @param tpTo_ target Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTPmin_ minimum amount of target Pegged Token that the sender expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTP(\\n        address tpFrom_,\\n        address tpTo_,\\n        uint256 qTP_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_\\n    ) external payable returns (uint256 operId) {\\n        return swapTPforTPtoViaVendor(tpFrom_, tpTo_, qTP_, qTPmin_, qACmax_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and receives another one\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param tpFrom_ owned Pegged Token address\\n     * @param tpTo_ target Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTPmin_ minimum amount of target Pegged Token that the sender expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTPViaVendor(\\n        address tpFrom_,\\n        address tpTo_,\\n        uint256 qTP_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return swapTPforTPtoViaVendor(tpFrom_, tpTo_, qTP_, qTPmin_, qACmax_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and recipient receives another one\\n     * @param tpFrom_ owned Pegged Token address\\n     * @param tpTo_ target Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTPmin_ minimum amount of target Pegged Token that `recipient_` expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @param recipient_ address who receives the target Pegged Token\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTPto(\\n        address tpFrom_,\\n        address tpTo_,\\n        uint256 qTP_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_,\\n        address recipient_\\n    ) external payable returns (uint256 operId) {\\n        return swapTPforTPtoViaVendor(tpFrom_, tpTo_, qTP_, qTPmin_, qACmax_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and recipient receives another one\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param tpFrom_ owned Pegged Token address\\n     * @param tpTo_ target Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTPmin_ minimum amount of target Pegged Token that `recipient_` expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @param recipient_ address who receives the target Pegged Token\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTPtoViaVendor(\\n        address tpFrom_,\\n        address tpTo_,\\n        uint256 qTP_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        SwapTPforTPParams memory params = SwapTPforTPParams({\\n            tpFrom: tpFrom_,\\n            tpTo: tpTo_,\\n            qTP: qTP_,\\n            qTPmin: qTPmin_,\\n            qACmax: qACmax_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueSwapTPforTP{ value: msg.value }(params);\\n        _lockTPInPending(IERC20Upgradeable(tpFrom_), qTP_);\\n        _lockACInPending(qACmax_);\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and receives Collateral Token\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTCmin_ minimum amount of Collateral Token that the sender expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTC(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qTCmin_,\\n        uint256 qACmax_\\n    ) external payable returns (uint256 operId) {\\n        return swapTPforTCtoViaVendor(tp_, qTP_, qTCmin_, qACmax_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and receives Collateral Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTCmin_ minimum amount of Collateral Token that the sender expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTCViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qTCmin_,\\n        uint256 qACmax_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return swapTPforTCtoViaVendor(tp_, qTP_, qTCmin_, qACmax_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and recipient receives Collateral Token\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTCmin_ minimum amount of Collateral Token that `recipient_` expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @param recipient_ address who receives the Collateral Token\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTCto(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qTCmin_,\\n        uint256 qACmax_,\\n        address recipient_\\n    ) external payable returns (uint256 operId) {\\n        return swapTPforTCtoViaVendor(tp_, qTP_, qTCmin_, qACmax_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice caller sends a Pegged Token and recipient receives Collateral Token\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not\\n     * @param tp_ Pegged Token address\\n     * @param qTP_ amount of owned Pegged Token to swap\\n     * @param qTCmin_ minimum amount of Collateral Token that `recipient_` expects to receive\\n     * @param qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     * @param recipient_ address who receives the Collateral Token\\n     * @param vendor_ address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTPforTCtoViaVendor(\\n        address tp_,\\n        uint256 qTP_,\\n        uint256 qTCmin_,\\n        uint256 qACmax_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        SwapTPforTCParams memory params = SwapTPforTCParams({\\n            tp: tp_,\\n            qTP: qTP_,\\n            qTCmin: qTCmin_,\\n            qACmax: qACmax_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueSwapTPforTC{ value: msg.value }(params);\\n        _lockTPInPending(IERC20Upgradeable(tp_), qTP_);\\n        _lockACInPending(qACmax_);\\n    }\\n\\n    /**\\n     * @notice Caller sends a Collateral Token and receives Pegged Token.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Amount of owned Collateral Token to swap\\n     * @param qTPmin_ Minimum amount of Pegged Token that the sender expects to receive\\n     * @param qACmax_ Maximum amount of Collateral Asset that can be spent in fees\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTCforTP(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_\\n    ) external payable returns (uint256 operId) {\\n        return swapTCforTPtoViaVendor(tp_, qTC_, qTPmin_, qACmax_, msg.sender, address(0));\\n    }\\n\\n    /**\\n     * @notice Caller sends a Collateral Token and receives Pegged Token.\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Amount of owned Collateral Token to swap\\n     * @param qTPmin_ Minimum amount of Pegged Token that the sender expects to receive\\n     * @param qACmax_ Maximum amount of Collateral Asset that can be spent in fees\\n     * @param vendor_ Address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTCforTPViaVendor(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_,\\n        address vendor_\\n    ) external payable returns (uint256 operId) {\\n        return swapTCforTPtoViaVendor(tp_, qTC_, qTPmin_, qACmax_, msg.sender, vendor_);\\n    }\\n\\n    /**\\n     * @notice Caller sends a Collateral Token and recipient receives Pegged Token.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Amount of owned Collateral Token to swap\\n     * @param qTPmin_ Minimum amount of Pegged Token that `recipient_` expects to receive\\n     * @param qACmax_ Maximum amount of Collateral Asset that can be spent in fees\\n     * @param recipient_ Address who receives the Pegged Token\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTCforTPto(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_,\\n        address recipient_\\n    ) external payable returns (uint256 operId) {\\n        return swapTCforTPtoViaVendor(tp_, qTC_, qTPmin_, qACmax_, recipient_, address(0));\\n    }\\n\\n    /**\\n     * @notice Caller sends a Collateral Token and recipient receives Pegged Token.\\n     *  `vendor_` receives a markup in Fee Token if possible or in qAC if not.\\n     * @param tp_ Pegged Token address\\n     * @param qTC_ Amount of owned Collateral Token to swap\\n     * @param qTPmin_ Minimum amount of Pegged Token that `recipient_` expects to receive\\n     * @param qACmax_ Maximum amount of Collateral Asset that can be spent in fees\\n     * @param recipient_ Address who receives the Pegged Token\\n     * @param vendor_ Address who receives a markup\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function swapTCforTPtoViaVendor(\\n        address tp_,\\n        uint256 qTC_,\\n        uint256 qTPmin_,\\n        uint256 qACmax_,\\n        address recipient_,\\n        address vendor_\\n    ) public payable notLiquidated notPaused returns (uint256 operId) {\\n        SwapTCforTPParams memory params = SwapTCforTPParams({\\n            tp: tp_,\\n            qTC: qTC_,\\n            qTPmin: qTPmin_,\\n            qACmax: qACmax_,\\n            sender: msg.sender,\\n            recipient: recipient_,\\n            vendor: vendor_\\n        });\\n        operId = mocQueue.queueSwapTCforTP{ value: msg.value }(params);\\n        _lockTCInPending(qTC_);\\n        _lockACInPending(qACmax_);\\n    }\\n\\n    // ------- External Only Queue Functions -------\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _mintTCto for details\\n     */\\n    function execMintTC(\\n        MintTCParams calldata params_\\n    ) external onlyMocQueue returns (uint256 qACtotalNeeded, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs) {\\n        return _mintTCto(params_);\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _redeemTCto for details\\n     */\\n    function execRedeemTC(\\n        RedeemTCParams calldata params_\\n    ) external onlyMocQueue returns (uint256 qACtoRedeem, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs) {\\n        RedeemTCParams memory params = params_;\\n        // Override sender, as funds are now locked here\\n        return _redeemTCto(params, address(this));\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _mintTPto for details\\n     */\\n    function execMintTP(\\n        MintTPParams calldata params_\\n    ) external onlyMocQueue returns (uint256 qACtotalNeeded, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs) {\\n        return _mintTPto(params_);\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _redeemTPto for details\\n     */\\n    function execRedeemTP(\\n        RedeemTPParams calldata params_\\n    ) external onlyMocQueue returns (uint256 qACtoRedeem, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs) {\\n        return _redeemTPto(params_, address(this));\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _mintTCandTPto for details\\n     */\\n    function execMintTCandTP(\\n        MintTCandTPParams calldata params_\\n    )\\n        external\\n        onlyMocQueue\\n        returns (uint256 qACtotalNeeded, uint256 qTCMinted, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        return _mintTCandTPto(params_);\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _redeemTCandTPto for details\\n     */\\n    function execRedeemTCandTP(\\n        RedeemTCandTPParams calldata params_\\n    )\\n        external\\n        onlyMocQueue\\n        returns (uint256 qACtoRedeem, uint256 qTPRedeemed, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        (qACtoRedeem, qTPRedeemed, qFeeTokenTotalNeeded, feeCalcs) = _redeemTCandTPto(params_, address(this));\\n        // return the unused locked TPs\\n        unchecked {\\n            uint256 qTPDif = params_.qTP - qTPRedeemed;\\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(params_.tp), params_.sender, qTPDif);\\n        }\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _swapTCforTPto for details\\n     */\\n    function execSwapTCforTP(\\n        SwapTCforTPParams calldata params_\\n    )\\n        external\\n        onlyMocQueue\\n        returns (uint256 qACSurcharges, uint256 qTPMinted, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        return _swapTCforTPto(params_, address(this));\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _swapTPforTCto for details\\n     */\\n    function execSwapTPforTC(\\n        SwapTPforTCParams calldata params_\\n    )\\n        external\\n        onlyMocQueue\\n        returns (uint256 qACSurcharges, uint256 qTCMinted, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        return _swapTPforTCto(params_, address(this));\\n    }\\n\\n    /**\\n     * @notice executes Operation based on params, only mocQueue allowed\\n     * see MocCore _swapTPforTPto for details\\n     */\\n    function execSwapTPforTP(\\n        SwapTPforTPParams calldata params_\\n    )\\n        external\\n        onlyMocQueue\\n        returns (uint256 qACSurcharges, uint256 qTPMinted, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        return _swapTPforTPto(params_, address(this));\\n    }\\n\\n    /**\\n     * @notice while executing a pending Operation, if it fails we need to unlock user's funds\\n     * @param owner_ funds owner, address to be returned to\\n     * @param qACToUnlock_ AC amount to be unlocked\\n     */\\n    function unlockACInPending(address owner_, uint256 qACToUnlock_) external onlyMocQueue {\\n        unchecked {\\n            qACLockedInPending -= qACToUnlock_;\\n        }\\n        SafeERC20.safeTransfer(acToken, owner_, qACToUnlock_);\\n    }\\n\\n    /**\\n     * @notice while executing a pending Operation, if it fails we need to unlock user's tokens\\n     * @param owner_ funds owner, address to be returned to\\n     * @param qTCToUnlock_ TC amount to be unlocked\\n     */\\n    function unlockTCInPending(address owner_, uint256 qTCToUnlock_) external onlyMocQueue {\\n        SafeERC20Upgradeable.safeTransfer(tcToken, owner_, qTCToUnlock_);\\n    }\\n\\n    /**\\n     * @notice while executing a pending Operation, if it fails we need to unlock user's tokens\\n     * @param owner_ funds owner, address to be returned to\\n     * @param tpToken_ TP to be unlocked\\n     * @param qTPToUnlock_ TP amount to be unlocked\\n     */\\n    function unlockTPInPending(address owner_, IERC20Upgradeable tpToken_, uint256 qTPToUnlock_) external onlyMocQueue {\\n        SafeERC20Upgradeable.safeTransfer(tpToken_, owner_, qTPToUnlock_);\\n    }\\n\\n    // ------- Only Authorized Changer Functions -------\\n\\n    /**\\n     * @dev sets Moc Queue contract address\\n     * @param mocQueue_ moc queue new contract address\\n     */\\n    function setMocQueue(address mocQueue_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        mocQueue = MocQueue(mocQueue_);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xd58fc34789aab0391e6e2159af536889a6c1c53a068290f20d713480018bb41b\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/core/MocBaseBucket.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocTC, IMocRC20 } from \\\"../tokens/MocTC.sol\\\";\\nimport { IPriceProvider } from \\\"../interfaces/IPriceProvider.sol\\\";\\nimport { IDataProvider } from \\\"../interfaces/IDataProvider.sol\\\";\\nimport { MocUpgradable } from \\\"../governance/MocUpgradable.sol\\\";\\n/* solhint-disable-next-line max-line-length */\\nimport { ReentrancyGuardUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title MocBaseBucket: Moc Collateral Bag\\n * @notice MocBaseBucket holds Bucket Zero state, both for the Collateral Bag and PeggedTokens Items.\\n * @dev Abstracts all rw operations on the main bucket and expose all calculations relative to its state.\\n */\\nabstract contract MocBaseBucket is MocUpgradable, ReentrancyGuardUpgradeable {\\n    // ------- Events -------\\n\\n    event ContractLiquidated();\\n\\n    // ------- Custom Errors -------\\n    error MissingProviderPrice(address priceProviderAddress_);\\n    error Liquidated();\\n    error LowCoverage(uint256 cglb_, uint256 covThrld_);\\n\\n    // ------- Structs -------\\n    struct PegContainerItem {\\n        // total supply of Pegged Token\\n        uint256 nTP;\\n        // PegToken PriceFeed address\\n        IPriceProvider priceProvider;\\n    }\\n\\n    struct PeggedTokenIndex {\\n        // Pegged Token index\\n        uint256 index;\\n        // true if Pegged Token exists\\n        bool exists;\\n    }\\n\\n    struct InitializeBaseBucketParams {\\n        // Fee Token contract address\\n        address feeTokenAddress;\\n        // Fee Token price provider address\\n        address feeTokenPriceProviderAddress;\\n        // Collateral Token contract address\\n        address tcTokenAddress;\\n        // Moc Fee Flow contract address\\n        address mocFeeFlowAddress;\\n        // moc appreciation beneficiary Address\\n        address mocAppreciationBeneficiaryAddress;\\n        // protected state threshold [PREC]\\n        uint256 protThrld;\\n        // liquidation coverage threshold [PREC]\\n        uint256 liqThrld;\\n        // pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]\\n        uint256 feeRetainer;\\n        // additional fee pct applied on mint Collateral Tokens operations [PREC]\\n        uint256 tcMintFee;\\n        // additional fee pct applied on redeem Collateral Tokens operations [PREC]\\n        uint256 tcRedeemFee;\\n        // additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC]\\n        uint256 swapTPforTPFee;\\n        // additional fee pct applied on swap a Pegged Token for Collateral Token [PREC]\\n        uint256 swapTPforTCFee;\\n        // additional fee pct applied on swap Collateral Token for a Pegged Token [PREC]\\n        uint256 swapTCforTPFee;\\n        // additional fee pct applied on redeem Collateral Token and Pegged Token in one operations [PREC]\\n        uint256 redeemTCandTPFee;\\n        // additional fee pct applied on mint Collateral Token and Pegged Token in one operation [PREC]\\n        uint256 mintTCandTPFee;\\n        // pct applied on the top of the operation`s fee when using Fee Token as fee payment method [PREC]\\n        // e.g. if tcMintFee = 1%, feeTokenPct = 50% => qFeeToken = 0.5%\\n        uint256 feeTokenPct;\\n        // pct of the gain because Pegged Tokens devaluation that is transferred\\n        // in Collateral Asset to Moc Fee Flow during the settlement [PREC]\\n        uint256 successFee;\\n        // pct of the gain because Pegged Tokens devaluation that is returned\\n        // in Pegged Tokens to appreciation beneficiary during the settlement [PREC]\\n        uint256 appreciationFactor;\\n        // number of blocks between settlements\\n        uint256 bes;\\n        // TC interest collector address\\n        address tcInterestCollectorAddress;\\n        // pct interest charged to TC holders on the total collateral in the protocol [PREC]\\n        uint256 tcInterestRate;\\n        // amount of blocks to wait for next TC interest payment\\n        uint256 tcInterestPaymentBlockSpan;\\n        // max absolute operation provider address:\\n        //  absolute maximum transaction allowed for a certain number of blocks\\n        //  if absoluteAccumulator is above the value provided the operation will be rejected\\n        address maxAbsoluteOpProviderAddress;\\n        // max operation difference provider address:\\n        //  differential maximum transaction allowed for a certain number of blocks\\n        //  if operationalDifference is above the value provided the operation will be rejected\\n        address maxOpDiffProviderAddress;\\n        // number of blocks that have to elapse for the linear decay factor to be 0\\n        uint256 decayBlockSpan;\\n    }\\n\\n    // ------- Storage -------\\n\\n    // Fee Token\\n    IERC20 public feeToken;\\n    // Fee Token price provider\\n    IPriceProvider public feeTokenPriceProvider;\\n    // total amount of Collateral Asset held in the Collateral Bag\\n    // WARN: On RC20 implementation, this correlates with contract acBalance\\n    uint256 public nACcb;\\n    // amount of Collateral Asset that the Vaults owe to the Collateral Bag\\n    // this variable is not used and is reserved for a future upgrade of the protocol\\n    // slither-disable-next-line constable-states\\n    uint256 internal nACioucb;\\n\\n    // Collateral Token\\n    MocTC public tcToken;\\n    // Collateral Token in the Collateral Bag\\n    uint256 public nTCcb;\\n\\n    // Pegged Tokens MocRC20 addresses\\n    IMocRC20[] public tpTokens;\\n    // Pegged Token indexes\\n    mapping(address => PeggedTokenIndex) public peggedTokenIndex;\\n    // peg container\\n    PegContainerItem[] public pegContainer;\\n    // Pegged Token prices, at which they can be redeemed after liquidation event\\n    uint256[] public tpLiqPrices;\\n    // pct of the gain because Pegged Tokens devaluation that is transferred\\n    // in Collateral Asset to Moc Fee Flow during the settlement [PREC]\\n    uint256 public successFee;\\n    // pct of the gain because Pegged Tokens devaluation that is returned\\n    // in Pegged Tokens to appreciation beneficiary during the settlement [PREC]\\n    uint256 public appreciationFactor;\\n\\n    // ------- Storage Fees -------\\n\\n    // pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]\\n    uint256 public feeRetainer; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // additional fee pct applied on Collateral Tokens mint [PREC]\\n    uint256 public tcMintFee; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // additional fee pct applied on Collateral Tokens redeem [PREC]\\n    uint256 public tcRedeemFee; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC]\\n    uint256 public swapTPforTPFee; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // additional fee pct applied on swap a Pegged Token for Collateral Token [PREC]\\n    uint256 public swapTPforTCFee; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // additional fee pct applied on swap Collateral Token for a Pegged Token [PREC]\\n    uint256 public swapTCforTPFee; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // additional fee pct applied on redeem Collateral Token and Pegged Token in one operations [PREC]\\n    uint256 public redeemTCandTPFee; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // additional fee pct applied on mint Collateral Token and Pegged Token in one operation [PREC]\\n    uint256 public mintTCandTPFee; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // pct applied on the top of the operation`s fee when using Fee Token as fee payment method [PREC]\\n    // e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%\\n    uint256 public feeTokenPct; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n\\n    // Pegged Token => addition fee pct applied on TP mint [PREC]\\n    mapping(address => uint256) public tpMintFees; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n    // Pegged Token =>  addition fee pct applied on TP redeem [PREC]\\n    mapping(address => uint256) public tpRedeemFees; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n\\n    // Moc Fee Flow contract address\\n    address public mocFeeFlowAddress;\\n    // Moc appreciation beneficiary address\\n    address public mocAppreciationBeneficiaryAddress;\\n\\n    // ------- Storage Coverage Tracking -------\\n\\n    // Target coverage for each Pegged Token [PREC]\\n    uint256[] public tpCtarg;\\n    // Coverage protected state threshold [PREC]\\n    uint256 public protThrld;\\n    // Coverage liquidation threshold [PREC]\\n    uint256 public liqThrld;\\n    // Liquidation enabled\\n    bool public liqEnabled;\\n    // Irreversible state, peg lost, contract is terminated and all funds can be withdrawn\\n    bool public liquidated;\\n\\n    // ------- Storage Settlement -------\\n\\n    // number of blocks between settlements\\n    uint256 public bes;\\n    // next settlement block\\n    uint256 public bns;\\n\\n    // ------- Storage Success Fee Tracking -------\\n\\n    // profit and loss in collateral asset for each Pegged Token because its devaluation [N]\\n    // if it is positive it is a profit that will be distributed and reset during settlement\\n    int256[] internal tpiou;\\n    // Pegged Token price used at last operation(redeem or mint) [PREC]\\n    uint256[] internal pACtpLstop;\\n\\n    // ------- Storage Flux Capacitor -------\\n\\n    // max absolute operation provider:\\n    //  absolute maximum transaction allowed for a certain number of blocks\\n    //  if absoluteAccumulator is above the value provided the operation will be rejected\\n    IDataProvider public maxAbsoluteOpProvider;\\n    // max operation difference provider:\\n    //  differential maximum transaction allowed for a certain number of blocks\\n    //  if operationalDifference is above the value provided the operation will be rejected\\n    IDataProvider public maxOpDiffProvider;\\n    // number of blocks that have to elapse for the linear decay factor to be 0\\n    uint256 public decayBlockSpan;\\n    // accumulator increased by minting and redeeming TP operations\\n    uint256 public absoluteAccumulator;\\n    // accumulator increased by minting and decreased by redeeming TP operations\\n    int256 public differentialAccumulator;\\n    // last block number where an operation was submitted\\n    uint256 public lastOperationBlockNumber;\\n\\n    // ------- Storage TC Holders Interest Payment -------\\n\\n    // TC interest collector address\\n    address public tcInterestCollectorAddress;\\n    // pct interest charged to TC holders on the total collateral in the protocol [PREC]\\n    uint256 public tcInterestRate;\\n    // amount of blocks to wait for next TC interest payment\\n    uint256 public tcInterestPaymentBlockSpan;\\n    // next TC interest payment block number\\n    uint256 public nextTCInterestPayment;\\n\\n    // ------- Modifiers -------\\n    /// @notice functions with this modifier reverts being in liquidated state\\n    modifier notLiquidated() {\\n        _checkLiquidated();\\n        _;\\n    }\\n\\n    // ------- Initializer -------\\n    /**\\n     * @notice contract initializer\\n     * @param initializeBaseBucketParams_ contract initializer params\\n     * @dev   feeTokenAddress Fee Token contract address\\n     *        feeTokenPriceProviderAddress Fee Token price provider contract address\\n     *        tcTokenAddress Collateral Token contract address\\n     *        mocFeeFlowAddress Moc Fee Flow contract address\\n     *        mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address\\n     *        protThrld protected coverage threshold [PREC]\\n     *        liqThrld liquidation coverage threshold [PREC]\\n     *        feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]\\n     *        tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]\\n     *        tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]\\n     *        swapTPforTPFee additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC]\\n     *        swapTPforTCFee additional fee pct applied on swap a Pegged Token for Collateral Token [PREC]\\n     *        swapTCforTPFee additional fee pct applied on swap Collateral Token for a Pegged Token [PREC]\\n     *        redeemTCandTPFee additional fee pct applied on redeem Collateral Token and Pegged Token [PREC]\\n     *        mintTCandTPFee additional fee pct applied on mint Collateral Token and Pegged Token [PREC]\\n     *        feeTokenPct pct applied on the top of the operation`s fee when using\\n     *          Fee Token as fee payment method [PREC]\\n     *        successFee pct of the gain because Pegged Tokens devaluation that is transferred\\n     *          in Collateral Asset to Moc Fee Flow during the settlement [PREC]\\n     *        appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned\\n     *          in Pegged Tokens to appreciation beneficiary during the settlement [PREC]\\n     *        bes number of blocks between settlements\\n     *        tcInterestCollectorAddress TC interest collector address\\n     *        tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]\\n     *        tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment\\n     *        maxAbsoluteOpProviderAddress max absolute operation provider address\\n     *        maxOpDiffProviderAddress max operation difference provider address\\n     *        decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0\\n     */\\n    function __MocBaseBucket_init_unchained(\\n        InitializeBaseBucketParams calldata initializeBaseBucketParams_\\n    ) internal onlyInitializing {\\n        if (initializeBaseBucketParams_.protThrld < ONE) revert InvalidValue();\\n        _checkLessThanOne(initializeBaseBucketParams_.feeRetainer);\\n        _checkLessThanOne(initializeBaseBucketParams_.tcMintFee);\\n        _checkLessThanOne(initializeBaseBucketParams_.tcRedeemFee);\\n        _checkLessThanOne(initializeBaseBucketParams_.swapTPforTPFee);\\n        _checkLessThanOne(initializeBaseBucketParams_.swapTPforTCFee);\\n        _checkLessThanOne(initializeBaseBucketParams_.swapTCforTPFee);\\n        _checkLessThanOne(initializeBaseBucketParams_.redeemTCandTPFee);\\n        _checkLessThanOne(initializeBaseBucketParams_.mintTCandTPFee);\\n        _checkLessThanOne(initializeBaseBucketParams_.feeTokenPct);\\n        _checkLessThanOne(initializeBaseBucketParams_.successFee + initializeBaseBucketParams_.appreciationFactor);\\n        feeToken = IERC20(initializeBaseBucketParams_.feeTokenAddress);\\n        feeTokenPriceProvider = IPriceProvider(initializeBaseBucketParams_.feeTokenPriceProviderAddress);\\n        tcToken = MocTC(initializeBaseBucketParams_.tcTokenAddress);\\n        mocFeeFlowAddress = initializeBaseBucketParams_.mocFeeFlowAddress;\\n        mocAppreciationBeneficiaryAddress = initializeBaseBucketParams_.mocAppreciationBeneficiaryAddress;\\n        protThrld = initializeBaseBucketParams_.protThrld;\\n        liqThrld = initializeBaseBucketParams_.liqThrld;\\n        feeRetainer = initializeBaseBucketParams_.feeRetainer;\\n        tcMintFee = initializeBaseBucketParams_.tcMintFee;\\n        tcRedeemFee = initializeBaseBucketParams_.tcRedeemFee;\\n        swapTPforTPFee = initializeBaseBucketParams_.swapTPforTPFee;\\n        swapTPforTCFee = initializeBaseBucketParams_.swapTPforTCFee;\\n        swapTCforTPFee = initializeBaseBucketParams_.swapTCforTPFee;\\n        redeemTCandTPFee = initializeBaseBucketParams_.redeemTCandTPFee;\\n        mintTCandTPFee = initializeBaseBucketParams_.mintTCandTPFee;\\n        feeTokenPct = initializeBaseBucketParams_.feeTokenPct;\\n        successFee = initializeBaseBucketParams_.successFee;\\n        appreciationFactor = initializeBaseBucketParams_.appreciationFactor;\\n        bes = initializeBaseBucketParams_.bes;\\n        tcInterestCollectorAddress = initializeBaseBucketParams_.tcInterestCollectorAddress;\\n        tcInterestRate = initializeBaseBucketParams_.tcInterestRate;\\n        tcInterestPaymentBlockSpan = initializeBaseBucketParams_.tcInterestPaymentBlockSpan;\\n        maxAbsoluteOpProvider = IDataProvider(initializeBaseBucketParams_.maxAbsoluteOpProviderAddress);\\n        maxOpDiffProvider = IDataProvider(initializeBaseBucketParams_.maxOpDiffProviderAddress);\\n        decayBlockSpan = initializeBaseBucketParams_.decayBlockSpan;\\n        lastOperationBlockNumber = block.number;\\n        unchecked {\\n            bns = block.number + initializeBaseBucketParams_.bes;\\n            nextTCInterestPayment = block.number + initializeBaseBucketParams_.tcInterestPaymentBlockSpan;\\n        }\\n        liquidated = false;\\n        liqEnabled = false;\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * reverts if in liquidated state\\n     */\\n    function _checkLiquidated() internal view {\\n        if (liquidated) revert Liquidated();\\n    }\\n\\n    /**\\n     * @notice Adds Collateral Asset to the Bucket\\n     * @param qAC_ amount of Collateral Asset to add\\n     */\\n    function _depositAC(uint256 qAC_) internal {\\n        nACcb += qAC_;\\n    }\\n\\n    /**\\n     * @notice Adds Collateral Token and Collateral Asset to the Bucket\\n     * @param qTC_ amount of Collateral Token to add\\n     * @param qAC_ amount of Collateral Asset to add\\n     */\\n    function _depositTC(uint256 qTC_, uint256 qAC_) internal {\\n        nTCcb += qTC_;\\n        _depositAC(qAC_);\\n    }\\n\\n    /**\\n     * @notice Subtracts Collateral Token and Collateral Asset from the Bucket\\n     * @param qTC_ amount of Collateral Token to subtract\\n     * @param qAC_ amount of Collateral Asset to subtract\\n     */\\n    function _withdrawTC(uint256 qTC_, uint256 qAC_) internal {\\n        nTCcb -= qTC_;\\n        nACcb -= qAC_;\\n    }\\n\\n    /**\\n     * @notice Adds Pegged Token and Collateral Asset to the Bucket\\n     * @param i_ Pegged Token index\\n     * @param qTP_ amount of Pegged Token to add\\n     * @param qAC_ amount of Collateral Asset to add\\n     */\\n    function _depositTP(uint256 i_, uint256 qTP_, uint256 qAC_) internal {\\n        pegContainer[i_].nTP += qTP_;\\n        _depositAC(qAC_);\\n    }\\n\\n    /**\\n     * @notice Subtracts Pegged Token and Collateral Asset from the Bucket\\n     * @param i_ Pegged Token index\\n     * @param qTP_ amount of Pegged Token to subtract\\n     * @param qAC_ amount of Collateral Asset to subtract\\n     */\\n    function _withdrawTP(uint256 i_, uint256 qTP_, uint256 qAC_) internal {\\n        pegContainer[i_].nTP -= qTP_;\\n        nACcb -= qAC_;\\n    }\\n\\n    /**\\n     * @notice Adds Pegged Token and Collateral Asset to the Bucket and mints `qTP_` for Pegged Token `i_`\\n     * @param i_ Pegged Token index\\n     * @param qTP_ amount of Pegged Token to add\\n     * @param qAC_ amount of Collateral Asset to add\\n     * @param recipient_ the account to mint tokens to\\n     */\\n    function _depositAndMintTP(uint256 i_, uint256 qTP_, uint256 qAC_, address recipient_) internal {\\n        // add qTP and qAC to the Bucket\\n        _depositTP(i_, qTP_, qAC_);\\n        // mint qTP to the recipient\\n        // slither-disable-next-line unused-return\\n        tpTokens[i_].mint(recipient_, qTP_);\\n    }\\n\\n    /**\\n     * @notice subtracts Pegged Token and Collateral Asset from the Bucket and burns `qTP_` for Pegged Token `i_`\\n     * @param i_ Pegged Token index\\n     * @param qTP_ amount of Pegged Token to subtract\\n     * @param qAC_ amount of Collateral Asset to subtract\\n     * @param toBurnFrom_ the account to burn tokens from\\n     */\\n    function _withdrawAndBurnTP(uint256 i_, uint256 qTP_, uint256 qAC_, address toBurnFrom_) internal {\\n        // sub qTP and qAC from the Bucket\\n        _withdrawTP(i_, qTP_, qAC_);\\n        // burn qTP from this address\\n        // slither-disable-next-line unused-return\\n        tpTokens[i_].burn(toBurnFrom_, qTP_);\\n    }\\n\\n    /**\\n     * @notice Adds Collateral Token and Collateral Asset to the Bucket and mints qTCtoMint\\n     * @param qTC_ amount of Collateral Token to add\\n     * @param qAC_ amount of Collateral Asset to add\\n     * @param recipient_ the account to mint tokens to\\n     */\\n    function _depositAndMintTC(uint256 qTC_, uint256 qAC_, address recipient_) internal {\\n        // add qTC to the Bucket\\n        _depositTC(qTC_, qAC_);\\n        // mint qTC to the recipient\\n        // slither-disable-next-line unused-return\\n        tcToken.mint(recipient_, qTC_);\\n    }\\n\\n    /**\\n     * @notice Subtracts Collateral Token and Collateral Asset from the Bucket and burns `qTC_`\\n     * @param qTC_ amount of Collateral Token to subtract\\n     * @param qAC_ amount of Collateral Asset to subtract\\n     * @param toBurnFrom_ the account to burn tokens from\\n     */\\n    function _withdrawAndBurnTC(uint256 qTC_, uint256 qAC_, address toBurnFrom_) internal {\\n        // sub qTC and qAC from the Bucket\\n        _withdrawTC(qTC_, qAC_);\\n        // burn qTC from this address\\n        tcToken.burn(toBurnFrom_, qTC_);\\n    }\\n\\n    /**\\n     * @notice get amount of Collateral Asset available considering how many are locked by Pegged Token adjusted by EMA\\n     * @param ctargemaCA_ target coverage adjusted by the moving average of the value of the Collateral Asset [PREC]\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return lckACemaAdjusted [PREC]\\n     */\\n    function _getLckACemaAdjusted(\\n        uint256 ctargemaCA_,\\n        uint256 lckAC_,\\n        uint256 nACgain_\\n    ) internal view returns (int256 lckACemaAdjusted) {\\n        // [PREC] = [N] * [PREC] - [PREC] * [N]\\n        return int256(_getTotalACavailable(nACgain_) * PRECISION) - int256(ctargemaCA_ * lckAC_);\\n    }\\n\\n    /**\\n     * @notice get signed amount of Collateral Token available to redeem\\n     * @dev negative value is needed for multi collateral implementation\\n     * @param ctargemaCA_ target coverage adjusted by the moving average of the value of the Collateral Asset [PREC]\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return tcAvailableToRedeem [N]\\n     */\\n    function _getTCAvailableToRedeemSigned(\\n        uint256 ctargemaCA_,\\n        uint256 lckAC_,\\n        uint256 nACgain_\\n    ) internal view returns (int256 tcAvailableToRedeem) {\\n        // [PREC]\\n        int256 lckACemaAdjusted = _getLckACemaAdjusted(ctargemaCA_, lckAC_, nACgain_);\\n        // [N] = [PREC] / [PREC]\\n        return lckACemaAdjusted / int256(_getPTCac(lckAC_, nACgain_));\\n    }\\n\\n    /**\\n     * @notice get amount of Collateral Token available to redeem\\n     * @param ctargemaCA_ target coverage adjusted by the moving average of the value of the Collateral Asset [PREC]\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return tcAvailableToRedeem [N]\\n     */\\n    function _getTCAvailableToRedeem(\\n        uint256 ctargemaCA_,\\n        uint256 lckAC_,\\n        uint256 nACgain_\\n    ) internal view virtual returns (uint256 tcAvailableToRedeem) {\\n        int256 tcAvailableToRedeemSigned = _getTCAvailableToRedeemSigned(ctargemaCA_, lckAC_, nACgain_);\\n        // if coverage <= ctargemaCA, we force that there be 0 AC available due to possible rounding errors\\n        if (tcAvailableToRedeemSigned < 0 || _getCglb(lckAC_, nACgain_) <= ctargemaCA_) return 0;\\n        return uint256(tcAvailableToRedeemSigned);\\n    }\\n\\n    /**\\n     * @notice get signed amount of Pegged Token available to mint\\n     * @dev negative value is needed for multi collateral implementation\\n     * @param ctargemaCA_ target coverage adjusted by the moving average of the value of the Collateral Asset\\n     * @param ctargemaTP_ target coverage adjusted by the moving average of the value of a Pegged Token\\n     * @param pACtp_ Collateral Asset price in amount of Pegged Token [PREC]\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return tpAvailableToMint [N]\\n     */\\n    function _getTPAvailableToMintSigned(\\n        uint256 ctargemaCA_,\\n        uint256 ctargemaTP_,\\n        uint256 pACtp_,\\n        uint256 lckAC_,\\n        uint256 nACgain_\\n    ) internal view returns (int256 tpAvailableToMint) {\\n        int256 lckACemaAdjusted = _getLckACemaAdjusted(ctargemaCA_, lckAC_, nACgain_);\\n        // [N] = [PREC] * [PREC] / ([PREC]) * [PREC])\\n        return (lckACemaAdjusted * int256(pACtp_)) / int256((ctargemaTP_ - ONE) * PRECISION);\\n    }\\n\\n    /**\\n     * @notice get amount of Pegged Token available to mint\\n     * @param ctargemaCA_ target coverage adjusted by the moving average of the value of the Collateral Asset\\n     * @param ctargemaTP_ target coverage adjusted by the moving average of the value of a Pegged Token\\n     * @param pACtp_ Collateral Asset price in amount of Pegged Token [PREC]\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return tpAvailableToMint [N]\\n     */\\n    function _getTPAvailableToMint(\\n        uint256 ctargemaCA_,\\n        uint256 ctargemaTP_,\\n        uint256 pACtp_,\\n        uint256 lckAC_,\\n        uint256 nACgain_\\n    ) internal view virtual returns (uint256 tpAvailableToMint) {\\n        int256 tpAvailableToMintSigned = _getTPAvailableToMintSigned(\\n            ctargemaCA_,\\n            ctargemaTP_,\\n            pACtp_,\\n            lckAC_,\\n            nACgain_\\n        );\\n        // if coverage <= ctargemaCA, we force that there be 0 AC available due to possible rounding errors\\n        if (tpAvailableToMintSigned < 0 || _getCglb(lckAC_, nACgain_) <= ctargemaCA_) return 0;\\n        return uint256(tpAvailableToMintSigned);\\n    }\\n\\n    /**\\n     * @notice evaluates whether or not the coverage is over the cThrld_, reverts if below\\n     * @param cThrld_ coverage threshold to check for [PREC]\\n     * @param pACtps_ array of all AC prices for each TP, with [PREC]\\n     * @return lckAC amount of Collateral Asset locked by Pegged Tokens [PREC]\\n     * @return nACgain amount of collateral asset to be distributed during settlement [N]\\n     */\\n    function _evalCoverage(\\n        uint256 cThrld_,\\n        uint256[] memory pACtps_\\n    ) internal view returns (uint256 lckAC, uint256 nACgain) {\\n        (lckAC, nACgain) = _calcLckACandACgain(pACtps_);\\n        uint256 cglb = _getCglb(lckAC, nACgain);\\n        // check if coverage is above the given threshold\\n        if (cglb <= cThrld_) revert LowCoverage(cglb, cThrld_);\\n    }\\n\\n    /**\\n     * @dev Calculates price at liquidation event as a relation between Pegs total supply\\n     * and the amount of Asset Collateral available to distribute\\n     */\\n    function settleLiquidationPrices() internal {\\n        // Total amount of AC available to be redeemed\\n        uint256 totalACAvailable = nACcb;\\n        // slither-disable-next-line incorrect-equality\\n        if (totalACAvailable == 0) return;\\n        uint256 pegAmount = pegContainer.length;\\n        // this could be get by getLckAC(), but given the prices are needed after,\\n        // it's better to cache them here.\\n        uint256 lckAC;\\n        // Auxiliary cache of pegs pACtp\\n        uint256[] memory pACtps = new uint256[](pegAmount);\\n        // for each peg, calculates the proportion of AC reserves it's locked\\n\\n        for (uint256 i = 0; i < pegAmount; i = unchecked_inc(i)) {\\n            pACtps[i] = _getPACtp(i);\\n            // [N] = [N] * [PREC] / [PREC]\\n            lckAC += _divPrec(pegContainer[i].nTP, pACtps[i]);\\n        }\\n        for (uint256 i = 0; i < pegAmount; i = unchecked_inc(i)) {\\n            // [PREC] = [PREC] * [N] / [N];\\n            tpLiqPrices.push((pACtps[i] * lckAC) / totalACAvailable);\\n        }\\n    }\\n\\n    /**\\n     * @notice updates Pegged Token P&L and last operation price\\n     * @param i_ Pegged Token index\\n     * @param pACtp_ Pegged Token price [PREC]\\n     */\\n    function _updateTPtracking(uint256 i_, uint256 pACtp_) internal {\\n        tpiou[i_] += _calcOtfPnLTP(i_, pACtp_);\\n        pACtpLstop[i_] = pACtp_;\\n    }\\n\\n    /**\\n     * @notice calculates on the fly Pegged Token P&L\\n     * @param i_ Pegged Token index\\n     * @param pACtp_ Pegged Token price [PREC]\\n     * @return otfPnLtp [N]\\n     */\\n    function _calcOtfPnLTP(uint256 i_, uint256 pACtp_) internal view returns (int256 otfPnLtp) {\\n        // [PREC] = [N] * [PREC]\\n        uint256 nTP = pegContainer[i_].nTP * PRECISION;\\n        // [N] = [PREC] / [PREC] - [PREC] / [PREC]\\n        return int256(nTP / pACtpLstop[i_]) - int256(nTP / pACtp_);\\n    }\\n\\n    /**\\n     * @notice gets accumulated Pegged Token P&L\\n     * @param i_ Pegged Token index\\n     * @param pACtp_ Pegged Token price [PREC]\\n     * @return tpGain amount of Pegged Token to be minted during settlement [N]\\n     * @return adjPnLtpi total amount of P&L in Collateral Asset [N]\\n     */\\n    function _getPnLTP(uint256 i_, uint256 pACtp_) internal view returns (uint256 tpGain, uint256 adjPnLtpi) {\\n        // [N] = [N] + [N]\\n        int256 adjPnLtpiAux = tpiou[i_] + _calcOtfPnLTP(i_, pACtp_);\\n        if (adjPnLtpiAux > 0) {\\n            adjPnLtpi = uint256(adjPnLtpiAux);\\n            // [N] = (([PREC] * [PREC] / [PREC]) * [N]) / [PREC]\\n            tpGain = _mulPrec(_mulPrec(appreciationFactor, pACtp_), adjPnLtpi);\\n        }\\n        return (tpGain, adjPnLtpi);\\n    }\\n\\n    /**\\n     * @notice get amount of Collateral Asset locked by Pegged Token and\\n     *  amount of collateral asset to be distributed during settlement\\n     * @return lckAC [N]\\n     * @return nACgain [N]\\n     */\\n    function _getLckACandACgain() internal view returns (uint256 lckAC, uint256 nACgain) {\\n        uint256[] memory pACtps = _getPACtps();\\n        return _calcLckACandACgain(pACtps);\\n    }\\n\\n    /**\\n     * @notice calculates the amount of Collateral Asset locked by Pegged Token and\\n     *  amount of collateral asset to be distributed during settlement\\n     * @param pACtps_ array of all AC prices for each TP, with [PREC]\\n     * @return lckAC [N]\\n     * @return nACgain [N]\\n     */\\n    function _calcLckACandACgain(uint256[] memory pACtps_) internal view returns (uint256 lckAC, uint256 nACgain) {\\n        uint256 pegAmount = pegContainer.length;\\n        for (uint256 i = 0; i < pegAmount; i = unchecked_inc(i)) {\\n            uint256 pACtp = pACtps_[i];\\n            (uint256 tpGain, uint256 adjPnLtpi) = _getPnLTP(i, pACtp);\\n            // [N] = ([N] + [N]) * [PREC] / [PREC]\\n            lckAC += _divPrec(pegContainer[i].nTP + tpGain, pACtp);\\n            nACgain += adjPnLtpi;\\n        }\\n        // [N] = [N] * [PREC] / [PREC]\\n        nACgain = _mulPrec(nACgain, successFee);\\n        return (lckAC, nACgain);\\n    }\\n\\n    /**\\n     * @notice get total Collateral Asset available\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return totalACavailable [N]\\n     */\\n    function _getTotalACavailable(uint256 nACgain_) internal view returns (uint256 totalACavailable) {\\n        // [N] = [N] - [N]\\n        return nACcb - nACgain_;\\n    }\\n\\n    /**\\n     * @notice get Collateral Token price\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return pTCac [PREC]\\n     */\\n    function _getPTCac(uint256 lckAC_, uint256 nACgain_) internal view returns (uint256 pTCac) {\\n        // slither-disable-next-line incorrect-equality\\n        if (nTCcb == 0) return ONE;\\n        // [PREC] = ([N] - [N]) * [PREC]) / [N]\\n        return _divPrec((_getTotalACavailable(nACgain_) - lckAC_), nTCcb);\\n    }\\n\\n    /**\\n     * @notice get Collateral Token leverage\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return leverageTC [PREC]\\n     */\\n    function _getLeverageTC(uint256 lckAC_, uint256 nACgain_) internal view returns (uint256 leverageTC) {\\n        uint256 totalACavailable = _getTotalACavailable(nACgain_);\\n        // [PREC] = [N] * [PREC] / ([N] - [N])\\n        return _divPrec(totalACavailable, totalACavailable - lckAC_);\\n    }\\n\\n    /**\\n     * @notice get bucket global coverage\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [N]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     * @return cglob [PREC]\\n     */\\n    function _getCglb(uint256 lckAC_, uint256 nACgain_) internal view virtual returns (uint256 cglob) {\\n        // slither-disable-next-line incorrect-equality\\n        if (lckAC_ == 0) return UINT256_MAX;\\n        // [PREC] = [N] * [PREC] / [N]\\n        return _divPrec(_getTotalACavailable(nACgain_), lckAC_);\\n    }\\n\\n    function _tpi(address tpAddress) internal view returns (uint256) {\\n        PeggedTokenIndex storage ptIndex = peggedTokenIndex[tpAddress];\\n        if (!ptIndex.exists) revert InvalidAddress();\\n        return ptIndex.index;\\n    }\\n\\n    // ------- Public Functions -------\\n\\n    /**\\n     * @notice If liquidation is enabled, verifies if forced liquidation has been\\n     * reached, checking if globalCoverage <= liquidation\\n     * @return true if liquidation state is reached, false otherwise\\n     */\\n    function isLiquidationReached() public view returns (bool) {\\n        (uint256 lckAC, uint256 nACgain) = _getLckACandACgain();\\n        uint256 cglb = _getCglb(lckAC, nACgain);\\n        return cglb <= liqThrld;\\n    }\\n\\n    /**\\n     * @notice evaluates if liquidation threshold has been reached and liq is Enabled.\\n     * If so forces contracts liquidation, blocking all mint & redeem operations.\\n     *\\n     * May emit a {ContractLiquidated} event.\\n     */\\n    function evalLiquidation() external notPaused {\\n        if (liqEnabled && !liquidated && isLiquidationReached()) {\\n            liquidated = true;\\n            emit ContractLiquidated();\\n            tcToken.pause();\\n            // Freeze current Peg Price given the AC available\\n            settleLiquidationPrices();\\n        }\\n    }\\n\\n    /**\\n     * @notice get how many Pegged Token equal 1 Collateral Asset\\n     * @param tp_ Pegged Token address\\n     * @return price [PREC]\\n     */\\n    function getPACtp(address tp_) public view virtual returns (uint256) {\\n        IPriceProvider priceProvider = pegContainer[_tpi(tp_)].priceProvider;\\n        (uint256 price, bool has) = _peekPrice(priceProvider);\\n        if (!has) revert MissingProviderPrice(address(priceProvider));\\n        return price;\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * @notice get how many Pegged Token equal 1 Collateral Asset\\n     * @param i_ Pegged Token index\\n     * @return price [PREC]\\n     */\\n    function _getPACtp(uint256 i_) internal view virtual returns (uint256) {\\n        IPriceProvider priceProvider = pegContainer[i_].priceProvider;\\n        (uint256 price, bool has) = _peekPrice(priceProvider);\\n        if (!has) revert MissingProviderPrice(address(priceProvider));\\n        return price;\\n    }\\n\\n    /**\\n     * @notice ask to a price provider for its token price\\n     * @dev saves some contract size by using this function instead of calling the external directly\\n     * @param priceProvider_ Pegged Token index\\n     * @return price casted to uint256 [PREC]\\n     * @return has true if has a valid price\\n     */\\n    function _peekPrice(IPriceProvider priceProvider_) internal view returns (uint256, bool) {\\n        (bytes32 price, bool has) = priceProvider_.peek();\\n        return (uint256(price), has);\\n    }\\n\\n    /**\\n     * @notice gets all TP prices\\n     * @return pACtps All tps prices [PREC]\\n     */\\n    function _getPACtps() internal view returns (uint256[] memory pACtps) {\\n        uint256 pegAmount = pegContainer.length;\\n        pACtps = new uint256[](pegAmount);\\n        for (uint256 i = 0; i < pegAmount; i = unchecked_inc(i)) {\\n            pACtps[i] = _getPACtp(i);\\n        }\\n    }\\n\\n    // ------- Only Authorized Changer Functions -------\\n\\n    /**\\n     * @dev sets the fee pct to be retainer on AC fees payments as AC re-injection.\\n     * @param feeRetainer_  pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setFeeRetainer(uint256 feeRetainer_) external onlyAuthorizedChanger {\\n        feeRetainer = feeRetainer_;\\n    }\\n\\n    /**\\n     * @dev sets the fee charged on Token Collateral mint.\\n     * @param tcMintFee_ addition fee pct applied on Collateral Tokens mint [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setTcMintFee(uint256 tcMintFee_) external onlyAuthorizedChanger {\\n        tcMintFee = tcMintFee_;\\n    }\\n\\n    /**\\n     * @dev sets the fee charged on Token Collateral redeem.\\n     * @param tcRedeemFee_ addition fee pct applied on Collateral Tokens redeem [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setTcRedeemFee(uint256 tcRedeemFee_) external onlyAuthorizedChanger {\\n        tcRedeemFee = tcRedeemFee_;\\n    }\\n\\n    /**\\n     * @dev sets the fee charged when swap a Pegged Token for another Pegged Token.\\n     * @param swapTPforTPFee_ additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setSwapTPforTPFee(uint256 swapTPforTPFee_) external onlyAuthorizedChanger {\\n        swapTPforTPFee = swapTPforTPFee_;\\n    }\\n\\n    /**\\n     * @dev sets the fee charged when swap a Pegged Token for Collateral Token.\\n     * @param swapTPforTCFee_ additional fee pct applied on swap a Pegged Token for Collateral Token [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setSwapTPforTCFee(uint256 swapTPforTCFee_) external onlyAuthorizedChanger {\\n        swapTPforTCFee = swapTPforTCFee_;\\n    }\\n\\n    /**\\n     * @dev sets the fee charged when swap Collateral Token for a Pegged Token.\\n     * @param swapTCforTPFee_ additional fee pct applied on swap Collateral Token for a Pegged Token [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setSwapTCforTPFee(uint256 swapTCforTPFee_) external onlyAuthorizedChanger {\\n        swapTCforTPFee = swapTCforTPFee_;\\n    }\\n\\n    /**\\n     * @dev sets the fee charged when redeem Collateral Token and Pegged Token in one operation.\\n     * @param redeemTCandTPFee_ additional fee pct applied on redeem Collateral Token and Pegged Token [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setRedeemTCandTPFee(uint256 redeemTCandTPFee_) external onlyAuthorizedChanger {\\n        redeemTCandTPFee = redeemTCandTPFee_;\\n    }\\n\\n    /**\\n     * @dev sets the fee charged when mint Collateral Token and Pegged Token in one operation.\\n     * @param mintTCandTPFee_ additional fee pct applied on mint Collateral Token and Pegged Token [PREC]\\n     * 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setMintTCandTPFee(uint256 mintTCandTPFee_) external onlyAuthorizedChanger {\\n        mintTCandTPFee = mintTCandTPFee_;\\n    }\\n\\n    /**\\n     * @dev sets the fee applied on the top of the operation`s fee when using Fee Token as fee payment method.\\n     * @param feeTokenPct_ pct applied on the top of the operation`s fee when using Fee Token\\n     *  as fee payment method [PREC]\\n     *  e.g. if tcMintFee = 1%, FeeTokenPct = 50% => qFeeToken = 0.5%\\n     *  0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n     */\\n    function setFeeTokenPct(uint256 feeTokenPct_) external onlyAuthorizedChanger {\\n        feeTokenPct = feeTokenPct_;\\n    }\\n\\n    /**\\n     * @dev sets Moc Fee Flow contract address\\n     * @param mocFeeFlowAddress_ moc Fee Flow new contract address\\n     */\\n    function setMocFeeFlowAddress(address mocFeeFlowAddress_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        mocFeeFlowAddress = mocFeeFlowAddress_;\\n    }\\n\\n    /**\\n     * @dev sets Moc Appreciation Beneficiary Address\\n     * @param mocAppreciationBeneficiaryAddress_ moc Appreciation Beneficiary new address\\n     */\\n    function setMocAppreciationBeneficiaryAddress(\\n        address mocAppreciationBeneficiaryAddress_\\n    ) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        mocAppreciationBeneficiaryAddress = mocAppreciationBeneficiaryAddress_;\\n    }\\n\\n    /**\\n     * @dev sets Fee Token contract address\\n     * @param mocFeeTokenAddress_ Fee Token new contract address\\n     */\\n    function setFeeTokenAddress(address mocFeeTokenAddress_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        feeToken = IERC20(mocFeeTokenAddress_);\\n    }\\n\\n    /**\\n     * @dev sets Fee Token price provider contract address\\n     * @param mocFeeTokenPriceProviderAddress_ Fee Token price provider new contract address\\n     */\\n    function setFeeTokenPriceProviderAddress(address mocFeeTokenPriceProviderAddress_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        feeTokenPriceProvider = IPriceProvider(mocFeeTokenPriceProviderAddress_);\\n    }\\n\\n    /**\\n     * @dev sets the value of the protected threshold configuration param\\n     * @param protThrld_ coverage protected state threshold [PREC]\\n     */\\n    function setProtThrld(uint256 protThrld_) external onlyAuthorizedChanger {\\n        protThrld = protThrld_;\\n    }\\n\\n    /**\\n     * @dev sets the value of the liq threshold configuration param\\n     * @param liqThrld_ liquidation threshold\\n     */\\n    function setLiqThrld(uint256 liqThrld_) external onlyAuthorizedChanger {\\n        liqThrld = liqThrld_;\\n    }\\n\\n    /**\\n     * @dev enables and disables the liquidation mechanism.\\n     * @param liqEnabled_ is liquidation enabled\\n     */\\n    function setLiqEnabled(bool liqEnabled_) external onlyAuthorizedChanger {\\n        liqEnabled = liqEnabled_;\\n    }\\n\\n    /**\\n     * @dev sets success Fee value.\\n     * @param successFee_ pct of the gain because Pegged Tokens devaluation that is\\n     * transferred in Collateral Asset to Moc Fee Flow during the settlement [PREC]\\n     */\\n    function setSuccessFee(uint256 successFee_) external onlyAuthorizedChanger {\\n        successFee = successFee_;\\n    }\\n\\n    /**\\n     * @dev sets appreciation Factor value.\\n     * @param appreciationFactor_ pct of the gain because Pegged Tokens devaluation that is returned\\n     * in Pegged Tokens to appreciation beneficiary during the settlement [PREC]\\n     */\\n    function setAppreciationFactor(uint256 appreciationFactor_) external onlyAuthorizedChanger {\\n        appreciationFactor = appreciationFactor_;\\n    }\\n\\n    /**\\n     * @dev sets TC interest collector address\\n     * @param tcInterestCollectorAddress_ TC interest collector address\\n     */\\n    function setTCInterestCollectorAddress(address tcInterestCollectorAddress_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        tcInterestCollectorAddress = tcInterestCollectorAddress_;\\n    }\\n\\n    /**\\n     * @dev sets TC interest rate\\n     * @param tcInterestRate_ pct interest charged to TC holders on the total collateral in the protocol [PREC]\\n     */\\n    function setTCInterestRate(uint256 tcInterestRate_) external onlyAuthorizedChanger {\\n        tcInterestRate = tcInterestRate_;\\n    }\\n\\n    /**\\n     * @dev sets TC interest payment block span\\n     * @param tcInterestPaymentBlockSpan_ amount of blocks to wait for next TC interest payment\\n     * @dev nextTCInterestPayment is not automatically updated, you have to wait until next\\n     *  interest payment to be made : nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan\\n     */\\n    function setTCInterestPaymentBlockSpan(uint256 tcInterestPaymentBlockSpan_) external onlyAuthorizedChanger {\\n        tcInterestPaymentBlockSpan = tcInterestPaymentBlockSpan_;\\n    }\\n\\n    /**\\n     * @param bes_ number of blocks between settlements\\n     * @dev bns is not automatically updated, you have to wait until next\\n     * settlement to be made : bns = block.number + bes\\n     **/\\n    function setBes(uint256 bes_) external onlyAuthorizedChanger {\\n        bes = bes_;\\n    }\\n\\n    /**\\n     * @dev sets max absolute operation provider address\\n     * @param maxAbsoluteOpProviderAddress_ max absolute operation provider address\\n     */\\n    function setMaxAbsoluteOpProviderAddress(address maxAbsoluteOpProviderAddress_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        maxAbsoluteOpProvider = IDataProvider(maxAbsoluteOpProviderAddress_);\\n    }\\n\\n    /**\\n     * @dev sets max operation difference provider address\\n     * @param maxOpDiffProviderAddress_ max operation difference provider address\\n     */\\n    function setMaxOpDiffProviderAddress(address maxOpDiffProviderAddress_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        maxOpDiffProvider = IDataProvider(maxOpDiffProviderAddress_);\\n    }\\n\\n    /**\\n     * @dev sets flux capacitor decay block span\\n     * @param decayBlockSpan_ flux capacitor decay block span\\n     */\\n    function setDecayBlockSpan(uint256 decayBlockSpan_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        decayBlockSpan = decayBlockSpan_;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x74b5f8c5cb227f5dd002ee5b78f11495c0dbb6d72fe82c923d9b844b5cc2b0b4\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/core/MocCommons.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocVendors } from \\\"../vendors/MocVendors.sol\\\";\\nimport { MocEma } from \\\"./MocEma.sol\\\";\\nimport { IDataProvider } from \\\"../interfaces/IDataProvider.sol\\\";\\nimport { SignedMath } from \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n// ------- External Structs -------\\n\\nstruct PeggedTokenParams {\\n    // Pegged Token contract address to add\\n    address tpTokenAddress;\\n    // priceProviderAddress Pegged Token price provider contract address\\n    address priceProviderAddress;\\n    // Pegged Token target coverage [PREC]\\n    uint256 tpCtarg;\\n    // additional fee pct applied on mint [PREC]\\n    uint256 tpMintFee;\\n    // additional fee pct applied on redeem [PREC]\\n    uint256 tpRedeemFee;\\n    // initial Pegged Token exponential moving average [PREC]\\n    uint256 tpEma;\\n    // Pegged Token smoothing factor [PREC]\\n    uint256 tpEmaSf;\\n}\\n\\n//    +-----------------+\\n//    |  MocBaseBucket  |\\n//    +-----------------+\\n//            ^\\n//            | is\\n//            |\\n//    +-----------------+\\n//    |    MocEma       |\\n//    +-----------------+\\n//            ^\\n//            | is\\n//            |\\n//    +-----------------+ contains  +-----------------+\\n//    |    MocCommons   | ------>   |    MocVendors   |\\n//    +-----------------+           +-----------------+\\n//            ^\\n//            | is\\n//            | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n//            |                              |\\n//    +-----------------+ contains  +-----------------+\\n//    |     MocCore     | ------>   |MocCoreExpansion |\\n//    +-----------------+           +-----------------+\\n//            ^\\n//            | is\\n//            | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\\n//            |                              |\\n//    +-----------------+           +-----------------+\\n//    |  MocCACoinbase  |           |    MocCARC20    |\\n//    +-----------------+           +-----------------+\\n/**\\n * @title MocCommons\\n * @dev To bypass the 24kb size limitation on MocCore we use MocCoreExpansion contract. Some functions\\n *  are implemented there and MocCore delegates calls to it. To achieve that, we need both to have the\\n *  exact same storage layout and be able to access the same common functions.\\n *  MocCommons contract serves as the last shared ancestor in the line of inheritance for them,\\n *  and all storage variables must be either declared here or in a parent contract.\\n *  Declaring variables after this point could result in storage collisions.\\n */\\nabstract contract MocCommons is MocEma {\\n    // ------- Storage -------\\n\\n    // Address for MocVendors contract, provides fee markup information\\n    MocVendors public mocVendors;\\n\\n    // ------- Internal Structs -------\\n\\n    struct MintTCandTPParams {\\n        address tp;\\n        uint256 qTP;\\n        uint256 qACmax;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    struct RedeemTCandTPParams {\\n        address tp;\\n        uint256 qTC;\\n        uint256 qTP;\\n        uint256 qACmin;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    struct SwapTPforTPParams {\\n        address tpFrom;\\n        address tpTo;\\n        uint256 qTP;\\n        uint256 qTPmin;\\n        uint256 qACmax;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    struct SwapTPforTCParams {\\n        address tp;\\n        uint256 qTP;\\n        uint256 qTCmin;\\n        uint256 qACmax;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    struct SwapTCforTPParams {\\n        address tp;\\n        uint256 qTC;\\n        uint256 qTPmin;\\n        uint256 qACmax;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    struct RedeemTPParams {\\n        address tp;\\n        uint256 qTP;\\n        uint256 qACmin;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    struct FeeCalcs {\\n        uint256 qACFee;\\n        uint256 qFeeToken;\\n        uint256 qACVendorMarkup;\\n        uint256 qFeeTokenVendorMarkup;\\n    }\\n\\n    // ------- Custom Errors -------\\n\\n    error PeggedTokenAlreadyAdded();\\n    error InsufficientTPtoRedeem(uint256 qTP_, uint256 tpAvailableToRedeem_);\\n    error TransferFailed();\\n    error OnlyWhenLiquidated();\\n    error InsufficientQacSent(uint256 qACsent_, uint256 qACNeeded_);\\n    error InsufficientTPtoMint(uint256 qTP_, uint256 tpAvailableToMint_);\\n    error QtpBelowMinimumRequired(uint256 qTPmin_, uint256 qTP_);\\n    error QtcBelowMinimumRequired(uint256 qTCmin_, uint256 qTC_);\\n    error QacNeededMustBeGreaterThanZero();\\n    error InsufficientTCtoRedeem(uint256 qTC_, uint256 tcAvailableToRedeem_);\\n    error MissingProviderData(address dataProviderAddress_);\\n    error MaxFluxCapacitorOperationReached(uint256 max_, uint256 new_);\\n    error InvalidFluxCapacitorOperation();\\n    error InsufficientQtpSent(uint256 qTPsent_, uint256 qTPNeeded_);\\n    error QacBelowMinimumRequired(uint256 qACmin_, uint256 qACtoRedeem_);\\n\\n    // ------- Events -------\\n\\n    event LiqTPRedeemed(\\n        address indexed tp_,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTP_,\\n        uint256 qAC_\\n    );\\n    event PeggedTokenChange(uint256 i_, PeggedTokenParams peggedTokenParams_);\\n\\n    // ------- Initializer -------\\n\\n    /**\\n     * @notice contract initializer\\n     * @param mocVendors_ address for MocVendors contract.\\n     */\\n    function __MocCommons_init_unchained(address mocVendors_) internal onlyInitializing {\\n        mocVendors = MocVendors(mocVendors_);\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * @notice calc fees amount in qAC or Fee Token\\n     *  If `sender_` has enough Fee Token to pay fees, will be used. In another case will use qAC\\n     * @dev if qFeeToken > 0, qACFee = 0. If qACFee > 0, qFeeToken = 0.\\n     * @param sender_ address who executes the operation\\n     * @param qAC_ amount of AC involved in the operation, could be sent form sender for mint or\\n     *  sent to recipient for redeem [N]\\n     * @param qACFeePct_ additional fee pct applied on operation\\n     * @return qACSurcharges amount of AC needed to pay fees and markup. 0 if pays with Fee Token\\n     * @return qFeeTokenTotalNeeded amount of Fee Token needed to pay fees and markup. 0 if pays with AC\\n     * @return feeCalcs\\n     * @dev\\n     *      qACFee amount of AC needed to pay fees\\n     *      qFeeToken amount of Fee Token needed to pay fess\\n     *      qACVendorMarkup amount of AC needed to pay vendor markup\\n     *      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup\\n     */\\n    function _calcFees(\\n        address sender_,\\n        address vendor_,\\n        uint256 qAC_,\\n        uint256 qACFeePct_\\n    ) internal view returns (uint256 qACSurcharges, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs) {\\n        uint256 qACmarked = 0;\\n        if (vendor_ != address(0)) {\\n            // [PREC] = [N] * [PREC]\\n            qACmarked = qAC_ * mocVendors.vendorMarkup(vendor_);\\n        }\\n        uint256 senderAllowance = feeToken.allowance(sender_, address(this));\\n        if (senderAllowance > 0) {\\n            (uint256 feeTokenPrice, bool hasFeeTokenPrice) = _peekPrice(feeTokenPriceProvider);\\n            if (hasFeeTokenPrice) {\\n                // calculates Fee Token to be charged as fee\\n                // [N] = ([N] * [PREC] * [PREC] / [PREC]) / [PREC]\\n                // TODO: define if will not be necessary a feeTokenPct for each operation\\n                feeCalcs.qFeeToken = _mulPrec(qAC_ * qACFeePct_, feeTokenPct) / feeTokenPrice;\\n                if (qACmarked > 0) {\\n                    // [N] = [N] * [PREC] / [PREC]\\n                    feeCalcs.qFeeTokenVendorMarkup = qACmarked / feeTokenPrice;\\n                    // [N] = [N] + [N]\\n                    qFeeTokenTotalNeeded = feeCalcs.qFeeToken + feeCalcs.qFeeTokenVendorMarkup;\\n                } else {\\n                    qFeeTokenTotalNeeded = feeCalcs.qFeeToken;\\n                }\\n                // TODO: if feeTokenPct == 0 should use qAC too?\\n                if (senderAllowance < qFeeTokenTotalNeeded || feeToken.balanceOf(sender_) < qFeeTokenTotalNeeded) {\\n                    feeCalcs.qFeeToken = 0;\\n                    feeCalcs.qFeeTokenVendorMarkup = 0;\\n                    qFeeTokenTotalNeeded = 0;\\n                }\\n            }\\n        }\\n        // if sender hasn't got enough feeToken balance or allowance or price provider hasn't got a valid price\\n        // then qFeeToken == 0 and sender pays fees with AC\\n        // slither-disable-next-line incorrect-equality\\n        if (feeCalcs.qFeeToken == 0) {\\n            // calculates qAC to be charged as fee\\n            // [N] = [N] * [PREC] / [PREC]\\n            feeCalcs.qACFee = _mulPrec(qAC_, qACFeePct_);\\n            if (qACmarked > 0) {\\n                // [N] = [PREC] / [PREC]\\n                feeCalcs.qACVendorMarkup = qACmarked / PRECISION;\\n                // [N] = [N] + [N]\\n                qACSurcharges = feeCalcs.qACFee + feeCalcs.qACVendorMarkup;\\n            } else {\\n                qACSurcharges = feeCalcs.qACFee;\\n            }\\n        }\\n        return (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice evaluates if there are enough Pegged Token available to mint, reverts if it`s not\\n     * @param i_ Pegged Token index\\n     * @param qTP_ amount of Pegged Token to mint [N]\\n     * @param pACtp_ Pegged Token price [PREC]\\n     * @param ctargemaCA_ target coverage adjusted by the moving average of the value of the Collateral Asset [PREC]\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [PREC]\\n     * @param nACgain_ amount of collateral asset to be distributed during settlement [N]\\n     */\\n    function _evalTPavailableToMint(\\n        uint256 i_,\\n        uint256 qTP_,\\n        uint256 pACtp_,\\n        uint256 ctargemaCA_,\\n        uint256 lckAC_,\\n        uint256 nACgain_\\n    ) internal view {\\n        uint256 ctargemaTP = _getCtargemaTP(i_, pACtp_);\\n        uint256 tpAvailableToMint = _getTPAvailableToMint(ctargemaCA_, ctargemaTP, pACtp_, lckAC_, nACgain_);\\n        // check if there are enough TP available to mint\\n        if (tpAvailableToMint < qTP_) revert InsufficientTPtoMint(qTP_, tpAvailableToMint);\\n    }\\n\\n    /**\\n     * @notice evaluates if there is enough Collateral Token available to redeem, reverts if there's not\\n     * @param qTC_ amount of Collateral Token to redeem [N]\\n     * @param ctargemaCA_ target coverage adjusted by the moving average of the value of the Collateral Asset [PREC]\\n     * @param lckAC_ amount of Collateral Asset locked by Pegged Token [PREC]\\n     * @param nACgain_ amount of Collateral Asset that will be distributed at\\n     *         settlement because Pegged Token devaluation [N]\\n     */\\n    function _evalTCAvailableToRedeem(\\n        uint256 qTC_,\\n        uint256 ctargemaCA_,\\n        uint256 lckAC_,\\n        uint256 nACgain_\\n    ) internal view {\\n        uint256 tcAvailableToRedeem = _getTCAvailableToRedeem(ctargemaCA_, lckAC_, nACgain_);\\n        // check if there are enough TC available to redeem\\n        if (tcAvailableToRedeem < qTC_) revert InsufficientTCtoRedeem(qTC_, tcAvailableToRedeem);\\n    }\\n\\n    /**\\n     * @notice ask to oracles for flux capacitor settings\\n     * @return absolute maximum transaction allowed for a certain number of blocks\\n     * @return differential maximum transaction allowed for a certain number of blocks\\n     */\\n    function _peekFluxCapacitorSettings() internal view returns (uint256, uint256) {\\n        bytes32 maxAbsoluteOp;\\n        bytes32 maxOpDiff;\\n        bool has;\\n        // get max absolute operation\\n        IDataProvider dataProvider = maxAbsoluteOpProvider;\\n        (maxAbsoluteOp, has) = dataProvider.peek();\\n        if (!has) revert MissingProviderData(address(dataProvider));\\n        // get max operational difference\\n        dataProvider = maxOpDiffProvider;\\n        (maxOpDiff, has) = dataProvider.peek();\\n        if (!has) revert MissingProviderData(address(dataProvider));\\n        return (uint256(maxAbsoluteOp), uint256(maxOpDiff));\\n    }\\n\\n    /**\\n     * @notice returns lineal decay factor\\n     * @param blocksAmount_ amount of blocks to ask for the decay\\n     * @return newAbsoluteAccumulator absolute accumulator updated by lineal decay factor [N]\\n     * @return newDifferentialAccumulator differential accumulator updated by lineal decay factor [N]\\n     */\\n    function _calcAccWithDecayFactor(\\n        uint256 blocksAmount_\\n    ) internal view returns (uint256 newAbsoluteAccumulator, int256 newDifferentialAccumulator) {\\n        unchecked {\\n            // [N] = [N] - [N]\\n            uint256 blocksElapsed = block.number + blocksAmount_ - lastOperationBlockNumber;\\n            // [PREC] = [N] * [PREC] / [N]\\n            uint256 blocksRatio = (blocksElapsed * PRECISION) / decayBlockSpan;\\n            if (blocksRatio >= ONE) return (0, 0);\\n            uint256 decayFactor = ONE - blocksRatio;\\n            // [N] = [N] * [PREC] / [PREC]\\n            newAbsoluteAccumulator = (absoluteAccumulator * decayFactor) / PRECISION;\\n            // [N] = [N] * [PREC] / [PREC]\\n            newDifferentialAccumulator = (differentialAccumulator * int256(decayFactor)) / int256(PRECISION);\\n            return (newAbsoluteAccumulator, newDifferentialAccumulator);\\n        }\\n    }\\n\\n    /**\\n     * @notice common function used to update accumulators during a TP operation\\n     *  reverts if not allowed\\n     * @dev the only difference between a redeem and a mint operation is that in the first one,\\n     * the qAC is subtracted on newDifferentialAccumulator instead of added\\n     * @param qAC_ amount of Collateral Asset used to mint\\n     * @param redeemFlag_ true if it is a redeem TP operation\\n     */\\n    function _updateAccumulators(uint256 qAC_, bool redeemFlag_) internal {\\n        (uint256 maxAbsoluteOperation, uint256 maxOperationalDifference) = _peekFluxCapacitorSettings();\\n        (uint256 newAbsoluteAccumulator, int256 newDifferentialAccumulator) = _calcAccWithDecayFactor(0);\\n        unchecked {\\n            newAbsoluteAccumulator += qAC_;\\n            int256 qACInt = int256(qAC_);\\n            if (redeemFlag_) qACInt = -qACInt;\\n            newDifferentialAccumulator += qACInt;\\n            // cannot underflow, always newDifferentialAccumulator <= newAbsoluteAccumulator\\n            uint256 operationalDifference = newAbsoluteAccumulator - SignedMath.abs(newDifferentialAccumulator);\\n            if (newAbsoluteAccumulator > maxAbsoluteOperation) {\\n                if (qAC_ > maxAbsoluteOperation) revert InvalidFluxCapacitorOperation();\\n                revert MaxFluxCapacitorOperationReached(maxAbsoluteOperation, newAbsoluteAccumulator);\\n            }\\n            if (operationalDifference > maxOperationalDifference)\\n                revert MaxFluxCapacitorOperationReached(maxOperationalDifference, operationalDifference);\\n            // update storage\\n            absoluteAccumulator = newAbsoluteAccumulator;\\n            differentialAccumulator = newDifferentialAccumulator;\\n            lastOperationBlockNumber = block.number;\\n        }\\n    }\\n\\n    /**\\n     * @notice update accumulators during a mint TP operation\\n     *  reverts if not allowed\\n     * @param qAC_ amount of Collateral Asset used to mint\\n     */\\n    function _updateAccumulatorsOnMintTP(uint256 qAC_) internal {\\n        _updateAccumulators(qAC_, false);\\n    }\\n\\n    /**\\n     * @notice update accumulators during a redeem operation\\n     *  reverts if not allowed\\n     * @param qAC_ reserve amount used for redeem\\n     */\\n    function _updateAccumulatorsOnRedeemTP(uint256 qAC_) internal {\\n        _updateAccumulators(qAC_, true);\\n    }\\n\\n    /**\\n     * @notice internal common function used to calc max AC allowed to mint or redeem TP\\n     *  due to accumulators\\n     * // TODO: move this function to a MocView contract\\n     * @param newAbsoluteAccumulator_ absolute accumulator updated by lineal decay factor [N]\\n     * @param a_ on mint = AA - DA ; on redeem = AA + DA\\n     * @param b_ on mint = AA + DA ; on redeem = AA - DA\\n     * @return maxQAC minimum regarding maxAbsoluteOperation and maxOperationalDifference\\n     */\\n    function _calcMaxQACToOperateTP(\\n        uint256 newAbsoluteAccumulator_,\\n        uint256 a_,\\n        uint256 b_\\n    ) internal view returns (uint256 maxQAC) {\\n        (uint256 maxAbsoluteOperation, uint256 maxOperationalDifference) = _peekFluxCapacitorSettings();\\n        if (newAbsoluteAccumulator_ >= maxAbsoluteOperation) return 0;\\n        uint256 absoluteAccAllowed = maxAbsoluteOperation - newAbsoluteAccumulator_;\\n\\n        if (a_ <= maxOperationalDifference) return absoluteAccAllowed;\\n        if (b_ >= maxOperationalDifference) return 0;\\n        uint256 differentialAccAllowed = (maxOperationalDifference - b_) / 2;\\n        return Math.min(absoluteAccAllowed, differentialAccAllowed);\\n    }\\n\\n    /**\\n     * @notice gets the max amount of AC allowed to operate to mint TP with, restricted by accumulators\\n     * // TODO: move this function to a MocView contract\\n     * @return maxQAC minimum regarding maxAbsoluteOperation and maxOperationalDifference\\n     */\\n    function maxQACToMintTP() external view returns (uint256 maxQAC) {\\n        (uint256 newAbsoluteAccumulator, int256 newDifferentialAccumulator) = _calcAccWithDecayFactor(1);\\n        // X = mint amount\\n        // (AA + X) - |DA + X| <= MODA && X >= 0\\n        // 1) if DA + X >= 0 ---> AA + X - DA - X <= MODA ---> AA - DA <= MODA\\n        // 2) if DA + X < 0 ---> X <= (MODA - (AA + DA)) / 2\\n\\n        // AA >= |DA|\\n        uint256 a = uint256(int256(newAbsoluteAccumulator) - newDifferentialAccumulator);\\n        uint256 b = uint256(int256(newAbsoluteAccumulator) + newDifferentialAccumulator);\\n        return _calcMaxQACToOperateTP(newAbsoluteAccumulator, a, b);\\n    }\\n\\n    /**\\n     * @notice gets the max amount of AC allowed to operate to redeem TP with, restricted by accumulators\\n     * // TODO: move this function to a MocView contract\\n     * @return maxQAC minimum regarding maxAbsoluteOperation and maxOperationalDifference\\n     */\\n    function maxQACToRedeemTP() external view returns (uint256 maxQAC) {\\n        (uint256 newAbsoluteAccumulator, int256 newDifferentialAccumulator) = _calcAccWithDecayFactor(1);\\n        // X = redeem amount\\n        // (AA + X) - |DA - X| <= MODA && X >= 0\\n        // 1) if DA - X < 0 ---> AA + X + DA - X <= MODA ---> AA + DA <= MODA\\n        // 2) if DA - X >= 0 ---> X <= (MODA - (AA - DA)) / 2\\n\\n        // AA >= |DA|\\n        uint256 a = uint256(int256(newAbsoluteAccumulator) + newDifferentialAccumulator);\\n        uint256 b = uint256(int256(newAbsoluteAccumulator) - newDifferentialAccumulator);\\n        return _calcMaxQACToOperateTP(newAbsoluteAccumulator, a, b);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa8439e6ad308b52d7a868760aaf7cb2b0395e33935aee0a03e10bc671c42dbd4\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/core/MocCore.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocCommons, PeggedTokenParams, MocVendors } from \\\"./MocCommons.sol\\\";\\nimport { MocCoreExpansion } from \\\"./MocCoreExpansion.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @title MocCore\\n * @notice MocCore nucleates all the basic MoC functionality and tool set. It allows Collateral\\n * asset aware contracts to implement the main mint/redeem operations.\\n */\\nabstract contract MocCore is MocCommons {\\n    // ------- Events -------\\n    event SuccessFeeDistributed(uint256 mocGain_, uint256[] tpGain_);\\n    event SettlementExecuted();\\n    event TCInterestPayment(uint256 interestAmount_);\\n    // ------- Custom Errors -------\\n    error MissingBlocksToSettlement();\\n    error MissingBlocksToTCInterestPayment();\\n    // ------- Structs -------\\n\\n    struct InitializeCoreParams {\\n        InitializeBaseBucketParams initializeBaseBucketParams;\\n        // The address that will define when a change contract is authorized\\n        address governorAddress;\\n        // The address that is authorized to pause this contract\\n        address pauserAddress;\\n        // Moc Core Expansion contract address\\n        address mocCoreExpansion;\\n        // amount of blocks to wait between Pegged ema calculation\\n        uint256 emaCalculationBlockSpan;\\n        // address for MocVendors\\n        address mocVendors;\\n    }\\n\\n    // ------- Storage -------\\n    // Moc Core Expansion contract address, used to expand 24kb size limit\\n    address internal mocCoreExpansion;\\n\\n    // ------- Initializer -------\\n    /**\\n     * @notice contract initializer\\n     * @dev this function must be execute by the AC implementation at initialization\\n     * @param initializeCoreParams_ contract initializer params\\n     *        governorAddress The address that will define when a change contract is authorized\\n     *        pauserAddress_ The address that is authorized to pause this contract\\n     *        mocCoreExpansion Moc Core Expansion contract address\\n     *        feeTokenAddress Fee Token contract address\\n     *        feeTokenPriceProviderAddress Fee Token price provider contract address\\n     *        tcTokenAddress Collateral Token contract address\\n     *        mocFeeFlowAddress Moc Fee Flow contract address\\n     *        mocAppreciationBeneficiaryAddress Moc appreciation beneficiary address\\n     *        protThrld protected state threshold [PREC]\\n     *        liqThrld liquidation coverage threshold [PREC]\\n     *        feeRetainer pct retain on fees to be re-injected as Collateral, while paying fees with AC [PREC]\\n     *        tcMintFee additional fee pct applied on mint Collateral Tokens operations [PREC]\\n     *        tcRedeemFee additional fee pct applied on redeem Collateral Tokens operations [PREC]\\n     *        swapTPforTPFee additional fee pct applied on swap a Pegged Token for another Pegged Token [PREC]\\n     *        swapTPforTCFee additional fee pct applied on swap a Pegged Token for Collateral Token [PREC]\\n     *        swapTCforTPFee additional fee pct applied on swap Collateral Token for a Pegged Token [PREC]\\n     *        redeemTCandTPFee additional fee pct applied on redeem Collateral Token and Pegged Token [PREC]\\n     *        mintTCandTPFee additional fee pct applied on mint Collateral Token and Pegged Token [PREC]\\n     *        feeTokenPct pct applied on the top of the operation`s fee when using\\n     *          Fee Token as fee payment method [PREC]\\n     *        successFee pct of the gain because Pegged Tokens devaluation that is transferred\\n     *          in Collateral Asset to Moc Fee Flow during the settlement [PREC]\\n     *        appreciationFactor pct of the gain because Pegged Tokens devaluation that is returned\\n     *          in Pegged Tokens to appreciation beneficiary during the settlement [PREC]]\\n     *        bes number of blocks between settlements\\n     *        tcInterestCollectorAddress TC interest collector address\\n     *        tcInterestRate pct interest charged to TC holders on the total collateral in the protocol [PREC]\\n     *        tcInterestPaymentBlockSpan amount of blocks to wait for next TC interest payment\\n     *        maxAbsoluteOpProviderAddress max absolute operation provider address\\n     *        maxOpDiffProviderAddress max operation difference provider address\\n     *        decayBlockSpan number of blocks that have to elapse for the linear decay factor to be 0\\n     *        emaCalculationBlockSpan amount of blocks to wait between Pegged ema calculation\\n     *        mocVendors address for MocVendors contract.\\n     */\\n    function __MocCore_init(InitializeCoreParams calldata initializeCoreParams_) internal onlyInitializing {\\n        mocCoreExpansion = initializeCoreParams_.mocCoreExpansion;\\n        __MocUpgradable_init(initializeCoreParams_.governorAddress, initializeCoreParams_.pauserAddress);\\n        __MocBaseBucket_init_unchained(initializeCoreParams_.initializeBaseBucketParams);\\n        __MocEma_init_unchained(initializeCoreParams_.emaCalculationBlockSpan);\\n        __MocCommons_init_unchained(initializeCoreParams_.mocVendors);\\n    }\\n\\n    // ------- Internal abstract Functions -------\\n\\n    /**\\n     * @notice transfer Collateral Asset\\n     * @dev this function must be overridden by the AC implementation\\n     *  and revert if transfer fails.\\n     * IMPORTANT: if ac transfer could trigger custom gas consumption for the Collateral\\n     * used (like coinbase fallback or ERC777), gasLimit should be capped\\n     * @param to_ address who receives the Collateral Asset\\n     * @param amount_ amount of Collateral Asset to transfer\\n     */\\n    function acTransfer(address to_, uint256 amount_) internal virtual;\\n\\n    /**\\n     * @notice Collateral Asset balance\\n     * @dev this function must be overridden by the AC implementation\\n     * @param account address who's Collateral Asset balance we want to know of\\n     * @return balance `account`'s total amount of Collateral Asset\\n     */\\n    function acBalanceOf(address account) internal view virtual returns (uint256 balance);\\n\\n    /**\\n     * @notice hook before any AC reception involving operation\\n     * @dev this function must be overridden by the AC implementation\\n     * @param qACMax_ max amount of AC available\\n     * @param qACNeeded_ amount of AC needed\\n     * @return change amount needed to be return to the sender after the operation is complete\\n     */\\n    function _onACNeededOperation(uint256 qACMax_, uint256 qACNeeded_) internal virtual returns (uint256 change);\\n\\n    /**\\n     * @notice hook after the TC is minted, with operation information result\\n     * @param params_ mintTCto function params\\n     * @param qACtotalNeeded_ amount of AC used to mint qTC\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTCMinted(\\n        MintTCParams memory params_,\\n        uint256 qACtotalNeeded_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice hook after the TC is redeemed, with operation information result\\n     * @param params_ mintTCto function params\\n     * @param qACRedeemed_ amount of AC redeemed\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTCRedeemed(\\n        RedeemTCParams memory params_,\\n        uint256 qACRedeemed_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice hook after the TP is minted, with operation information result\\n     * @param params_ mintTP functions params\\n     * @param qACtotalNeeded_ amount of AC needed to mint qTP\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTPMinted(\\n        MintTPParams memory params_,\\n        uint256 qACtotalNeeded_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Hook after the TP is redeemed, with operation information result\\n     * @param params_ redeemTPto function params\\n     * @param qACRedeem_ amount of AC redeemed\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTPRedeemed(\\n        RedeemTPParams memory params_,\\n        uint256 qACRedeem_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Hook after the TC and TP are minted, with operation information result\\n     * @param params_ mintTCandTPto function params\\n     * @param qTCMinted_ amount of qTC minted for the given qTP\\n     * @param qACtotalNeeded_ total amount of AC needed to mint qTC and qTP\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTCandTPMinted(\\n        MintTCandTPParams memory params_,\\n        uint256 qTCMinted_,\\n        uint256 qACtotalNeeded_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Hook after the TC and TP are redeemed, with operation information result\\n     * @param params_ redeemTCandTPto function params\\n     * @param qTPRedeemed_ total amount of TP redeemed\\n     * @param qACRedeemed_ total amount of AC redeemed\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTCandTPRedeemed(\\n        RedeemTCandTPParams memory params_,\\n        uint256 qTPRedeemed_,\\n        uint256 qACRedeemed_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Hook after the TC is swapped for TP, with operation information result\\n     * @param params_ swapTCforTP function params\\n     * @param qTPMinted_ total amount of TP minted\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTCSwappedForTP(\\n        SwapTCforTPParams memory params_,\\n        uint256 qTPMinted_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Hook after the TP is swapped for TC, with operation information result\\n     * @param params_ swapTPforTC function params\\n     * @param qTCMinted_ total amount of TC minted\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTPSwappedForTC(\\n        SwapTPforTCParams memory params_,\\n        uint256 qTCMinted_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    /**\\n     * @notice Hook after the TP is swapped for another TP, with operation information result\\n     * @param params_ swapTPforTP function params\\n     * @param qTPMinted_ total amount of TP minted\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function onTPSwappedForTP(\\n        SwapTPforTPParams memory params_,\\n        uint256 qTPMinted_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal virtual;\\n\\n    // ------- Internal Functions -------\\n\\n    struct MintTCParams {\\n        uint256 qTC;\\n        uint256 qACmax;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    /**\\n     * @notice mint Collateral Token in exchange for Collateral Asset\\n     * @param params_ mintTCto function params\\n     * @dev\\n     *      qTC_ amount of Collateral Token to mint\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent\\n     *      sender_ address who sends the Collateral Asset, all unspent amount is returned to it\\n     *      recipient_ address who receives the Collateral Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtotalNeeded amount of AC used to mint qTC\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _mintTCto(\\n        MintTCParams memory params_\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACtotalNeeded, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        uint256[] memory pACtps = _getPACtps();\\n        // evaluates whether or not the system coverage is healthy enough to mint TC, reverts if it's not\\n        (uint256 lckAC, uint256 nACgain) = _evalCoverage(protThrld, pACtps);\\n        // calculates how many qAC are needed to mint TC\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 qACNeededToMint = _mulPrec(params_.qTC, _getPTCac(lckAC, nACgain));\\n        uint256 qACSurcharges;\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACNeededToMint,\\n            tcMintFee\\n        );\\n        qACtotalNeeded = qACNeededToMint + qACSurcharges;\\n        if (qACtotalNeeded > params_.qACmax) revert InsufficientQacSent(params_.qACmax, qACtotalNeeded);\\n        // if is 0 reverts because it is trying to redeem an amount below precision\\n        // slither-disable-next-line incorrect-equality\\n        if (qACtotalNeeded == 0) revert QacNeededMustBeGreaterThanZero();\\n        onTCMinted(params_, qACtotalNeeded, feeCalcs);\\n        _depositAndMintTC(params_.qTC, qACNeededToMint, params_.recipient);\\n        uint256 acChange = _onACNeededOperation(params_.qACmax, qACtotalNeeded);\\n        // transfers any AC change to the sender and distributes fees\\n        _distOpResults(params_.sender, params_.sender, acChange, params_.vendor, feeCalcs);\\n    }\\n\\n    struct RedeemTCParams {\\n        uint256 qTC;\\n        uint256 qACmin;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    /**\\n     * @notice redeem Collateral Asset in exchange for Collateral Token\\n     * @param params_ redeemTCto function params\\n     * @param operator_ address that will provide the TC liquidity to redeem\\n     * @dev\\n     *      qTC_ amount of Collateral Token to redeem\\n     *      qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     *      sender_ address who sends the Collateral Token\\n     *      recipient_ address who receives the Collateral Asset\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtoRedeem amount of AC sent to `recipient_`\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n\\n    function _redeemTCto(\\n        RedeemTCParams memory params_,\\n        address operator_\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACtoRedeem, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        (uint256 ctargemaCA, uint256[] memory pACtps) = _updateEmasAndCalcCtargemaCA();\\n        // evaluates whether or not the system coverage is healthy enough to redeem TC\\n        // given the target coverage adjusted by the moving average, reverts if it's not\\n        (uint256 lckAC, uint256 nACgain) = _evalCoverage(ctargemaCA, pACtps);\\n        // evaluates if there are enough Collateral Tokens available to redeem, reverts if there are not\\n        _evalTCAvailableToRedeem(params_.qTC, ctargemaCA, lckAC, nACgain);\\n        // calculate how many total qAC are redeemed\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 qACtotalToRedeem = _mulPrec(params_.qTC, _getPTCac(lckAC, nACgain));\\n        // if is 0 reverts because it is trying to redeem an amount below precision\\n        // slither-disable-next-line incorrect-equality\\n        if (qACtotalToRedeem == 0) revert QacNeededMustBeGreaterThanZero();\\n        uint256 qACSurcharges;\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACtotalToRedeem,\\n            tcRedeemFee\\n        );\\n        qACtoRedeem = qACtotalToRedeem - qACSurcharges;\\n        if (qACtoRedeem < params_.qACmin) revert QacBelowMinimumRequired(params_.qACmin, qACtoRedeem);\\n        onTCRedeemed(params_, qACtoRedeem, feeCalcs);\\n        // use msg.sender, as the token \\\"source\\\" is always the actual tx sender\\n        _withdrawAndBurnTC(params_.qTC, qACtotalToRedeem, operator_);\\n        // transfers qAC to the recipient and distributes fees\\n        _distOpResults(params_.sender, params_.recipient, qACtoRedeem, params_.vendor, feeCalcs);\\n    }\\n\\n    struct MintTPParams {\\n        address tp;\\n        uint256 qTP;\\n        uint256 qACmax;\\n        address sender;\\n        address recipient;\\n        address vendor;\\n    }\\n\\n    /**\\n     * @notice mint Pegged Token in exchange for Collateral Asset\\n     * @param params_ mint TP function params\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTP_ amount of Pegged Token to mint\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent\\n     *      sender_ address who sends the Collateral Asset, all unspent amount is returned to it\\n     *      recipient_ address who receives the Pegged Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtotalNeeded amount of AC used to mint qTP\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _mintTPto(\\n        MintTPParams memory params_\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACtotalNeeded, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        (uint256 ctargemaCA, uint256[] memory pACtps) = _updateEmasAndCalcCtargemaCA();\\n        uint256 i = _tpi(params_.tp);\\n        uint256 pACtp = pACtps[i];\\n        _updateTPtracking(i, pACtp);\\n        // evaluates whether or not the system coverage is healthy enough to mint TP\\n        // given the target coverage adjusted by the moving average, reverts if it's not\\n        (uint256 lckAC, uint256 nACgain) = _evalCoverage(ctargemaCA, pACtps);\\n        // evaluates if there are enough TP available to mint, reverts if it's not\\n        _evalTPavailableToMint(i, params_.qTP, pACtp, ctargemaCA, lckAC, nACgain);\\n        // calculate how many qAC are needed to mint TP\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 qACNeededtoMint = _divPrec(params_.qTP, pACtp);\\n        uint256 qACSurcharges;\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACNeededtoMint,\\n            tpMintFees[params_.tp]\\n        );\\n        qACtotalNeeded = qACNeededtoMint + qACSurcharges;\\n        if (qACtotalNeeded > params_.qACmax) revert InsufficientQacSent(params_.qACmax, qACtotalNeeded);\\n        // if is 0 reverts because it is trying to mint an amount below precision\\n        // slither-disable-next-line incorrect-equality\\n        if (qACtotalNeeded == 0) revert QacNeededMustBeGreaterThanZero();\\n        onTPMinted(params_, qACtotalNeeded, feeCalcs);\\n        // update flux capacitor and reverts if not allowed by accumulators\\n        _updateAccumulatorsOnMintTP(qACNeededtoMint);\\n        // update bucket and mint\\n        _depositAndMintTP(i, params_.qTP, qACNeededtoMint, params_.recipient);\\n        uint256 acChange = _onACNeededOperation(params_.qACmax, qACtotalNeeded);\\n        // transfers any AC change to the sender and distributes fees\\n        _distOpResults(params_.sender, params_.sender, acChange, params_.vendor, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice redeem Collateral Asset in exchange for Pegged Token\\n     * @param params_ redeem CA function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTP_ amount of Pegged Token to redeem\\n     *      qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     *      sender_ address who sends the Pegged Token\\n     *      recipient_ address who receives the Collateral Asset\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtoRedeem amount of AC sent to `recipient_`\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _redeemTPto(\\n        RedeemTPParams memory params_,\\n        address operator\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACtoRedeem, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        uint256[] memory pACtps = _getPACtps();\\n        uint256 i = _tpi(params_.tp);\\n        uint256 pACtp = pACtps[i];\\n        _updateTPtracking(i, pACtp);\\n        // evaluates whether or not the system coverage is healthy enough to redeem TP, reverts if it's not\\n        _evalCoverage(protThrld, pACtps);\\n        // calculate how many total qAC are redeemed\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 qACtotalToRedeem = _divPrec(params_.qTP, pACtp);\\n        uint256 qACSurcharges;\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACtotalToRedeem,\\n            tpRedeemFees[params_.tp]\\n        );\\n        qACtoRedeem = qACtotalToRedeem - qACSurcharges;\\n        // if is 0 reverts because it is trying to redeem an amount below precision\\n        // slither-disable-next-line incorrect-equality\\n        if (qACtotalToRedeem == 0) revert QacNeededMustBeGreaterThanZero();\\n        if (qACtoRedeem < params_.qACmin) revert QacBelowMinimumRequired(params_.qACmin, qACtoRedeem);\\n        onTPRedeemed(params_, qACtoRedeem, feeCalcs);\\n        // update flux capacitor and reverts if not allowed by accumulators\\n        _updateAccumulatorsOnRedeemTP(qACtoRedeem);\\n        _withdrawAndBurnTP(i, params_.qTP, qACtotalToRedeem, operator);\\n        // transfers qAC to the recipient and distributes fees\\n        _distOpResults(params_.sender, params_.recipient, qACtoRedeem, params_.vendor, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice mint Collateral Token and Pegged Token in exchange for Collateral Asset\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are minted in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qAC sent are insufficient.\\n     * @param params_ mint TC and TP function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTP_ amount of Pegged Token to mint\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent\\n     *      sender_ address who sends Collateral Asset\\n     *      recipient_ address who receives the Collateral Token and Pegged Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtotalNeeded amount of AC used to mint Collateral Token and Pegged Token\\n     * @return qTCtoMint amount of Collateral Token minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _mintTCandTPto(\\n        MintTCandTPParams memory params_\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACtotalNeeded, uint256 qTCtoMint, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        bytes memory payload = abi.encodeCall(MocCoreExpansion(mocCoreExpansion).mintTCandTPto, (params_));\\n        (qACtotalNeeded, qTCtoMint, qFeeTokenTotalNeeded, feeCalcs) = abi.decode(\\n            Address.functionDelegateCall(mocCoreExpansion, payload),\\n            (uint256, uint256, uint256, FeeCalcs)\\n        );\\n        onTCandTPMinted(params_, qTCtoMint, qACtotalNeeded, feeCalcs);\\n        uint256 acChange = _onACNeededOperation(params_.qACmax, qACtotalNeeded);\\n        // transfers qAC to the sender and distributes fees\\n        _distOpResults(params_.sender, params_.sender, acChange, params_.vendor, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice redeem Collateral Asset in exchange for Collateral Token and Pegged Token\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qTP sent are insufficient.\\n     * @param params_ redeem TC and TP function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTC_ amount of Collateral Token to redeem\\n     *      qTP_ maximum amount of Pegged Token to redeem\\n     *      qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     *      sender_ address who sends Collateral Token and Pegged Token\\n     *      recipient_ address who receives the Collateral Asset\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtoRedeem amount of AC sent to `recipient_`\\n     * @return qTPtoRedeem amount of Pegged Token redeemed\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _redeemTCandTPto(\\n        RedeemTCandTPParams memory params_,\\n        address operator\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACtoRedeem, uint256 qTPtoRedeem, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        bytes memory payload = abi.encodeCall(MocCoreExpansion(mocCoreExpansion).redeemTCandTPto, (params_, operator));\\n        (qACtoRedeem, qTPtoRedeem, qFeeTokenTotalNeeded, feeCalcs) = abi.decode(\\n            Address.functionDelegateCall(mocCoreExpansion, payload),\\n            (uint256, uint256, uint256, FeeCalcs)\\n        );\\n        onTCandTPRedeemed(params_, qTPtoRedeem, qACtoRedeem, feeCalcs);\\n\\n        // transfers qAC to the recipient and distributes fees\\n        _distOpResults(params_.sender, params_.recipient, qACtoRedeem, params_.vendor, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice swap Pegged Token to another one\\n     *  This operation is done without checking coverage unless the target coverage for\\n     *  received Pegged Token is greater than the Pegged Token sent\\n     * @param params_ swap TP for TP function parameters\\n     * @dev\\n     *      iFrom_ owned Pegged Token index\\n     *      iTo_ target Pegged Token index\\n     *      qTP_ amount of owned Pegged Token to swap\\n     *      qTPmin_ minimum amount of target Pegged Token that `recipient_` expects to receive\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     *      sender_ address who sends the Pegged Token\\n     *      recipient_ address who receives the target Pegged Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACSurcharges amount of AC used to pay fees and markup\\n     * @return qTPMinted amount of Pegged Token minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _swapTPforTPto(\\n        SwapTPforTPParams memory params_,\\n        address operator\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACSurcharges, uint256 qTPMinted, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        bytes memory payload = abi.encodeCall(MocCoreExpansion(mocCoreExpansion).swapTPforTPto, (params_, operator));\\n        (qACSurcharges, qTPMinted, qFeeTokenTotalNeeded, feeCalcs) = abi.decode(\\n            Address.functionDelegateCall(mocCoreExpansion, payload),\\n            (uint256, uint256, uint256, FeeCalcs)\\n        );\\n        onTPSwappedForTP(params_, qTPMinted, feeCalcs);\\n        // AC is only used to pay fees and markup\\n        uint256 acChange = _onACNeededOperation(params_.qACmax, qACSurcharges);\\n        // transfer any qAC change to the sender and distribute fees\\n        _distOpResults(params_.sender, params_.sender, acChange, params_.vendor, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice swap Pegged Token to Collateral Token\\n     * @param params_ swap TP for TC function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTP_ amount Pegged Token to swap\\n     *      qTCmin_ minimum amount of Collateral Token that `recipient_` expects to receive\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     *      sender_ address who sends the Pegged Token\\n     *      recipient_ address who receives Collateral Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACSurcharges amount of AC used to pay fees and markup\\n     * @return qTCMinted amount of TC minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _swapTPforTCto(\\n        SwapTPforTCParams memory params_,\\n        address operator\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACSurcharges, uint256 qTCMinted, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        bytes memory payload = abi.encodeCall(MocCoreExpansion(mocCoreExpansion).swapTPforTCto, (params_, operator));\\n        (qACSurcharges, qTCMinted, qFeeTokenTotalNeeded, feeCalcs) = abi.decode(\\n            Address.functionDelegateCall(mocCoreExpansion, payload),\\n            (uint256, uint256, uint256, FeeCalcs)\\n        );\\n        onTPSwappedForTC(params_, qTCMinted, feeCalcs);\\n        // AC is only used to pay fees and markup\\n        uint256 acChange = _onACNeededOperation(params_.qACmax, qACSurcharges);\\n        // transfer any qAC change to the sender and distribute fees\\n        _distOpResults(params_.sender, params_.sender, acChange, params_.vendor, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice swap Collateral Token to Pegged Token\\n     * @param params_ swap TC for TP function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTC_ amount of Collateral Token to swap\\n     *      qTPmin_ minimum amount of Pegged Token Token that `recipient_` expects to receive\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     *      sender_ address who sends the Collateral Token\\n     *      recipient_ address who receives the Pegged Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACSurcharges amount of AC used to pay fees and markup\\n     * @return qTPtoMint amount of Pegged Token minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function _swapTCforTPto(\\n        SwapTCforTPParams memory params_,\\n        address operator\\n    )\\n        internal\\n        notLiquidated\\n        notPaused\\n        returns (uint256 qACSurcharges, uint256 qTPtoMint, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        bytes memory payload = abi.encodeCall(MocCoreExpansion(mocCoreExpansion).swapTCforTPto, (params_, operator));\\n        (qACSurcharges, qTPtoMint, qFeeTokenTotalNeeded, feeCalcs) = abi.decode(\\n            Address.functionDelegateCall(mocCoreExpansion, payload),\\n            (uint256, uint256, uint256, FeeCalcs)\\n        );\\n        onTCSwappedForTP(params_, qTPtoMint, feeCalcs);\\n\\n        // AC is only used to pay fees and markup\\n        uint256 acChange = _onACNeededOperation(params_.qACmax, qACSurcharges);\\n        // transfer any qAC change to the sender and distribute fees\\n        _distOpResults(params_.sender, params_.sender, acChange, params_.vendor, feeCalcs);\\n    }\\n\\n    /**\\n     * @notice Allow redeem on liquidation state, user Peg balance gets burned and he receives\\n     * the equivalent AC given the liquidation frozen price.\\n     * @dev This function is implemented in MocCoreExpansion but with this contract context\\n     * @param tp_ Pegged Token address\\n     * @param sender_ address owner of the TP to be redeemed\\n     * @param recipient_ address who receives the AC\\n     * @return qACRedeemed amount of AC sent to `recipient_`\\n     */\\n    function _liqRedeemTPTo(\\n        address tp_,\\n        address sender_,\\n        address recipient_\\n    ) internal notPaused nonReentrant returns (uint256 qACRedeemed) {\\n        bytes memory payload = abi.encodeCall(\\n            MocCoreExpansion(mocCoreExpansion).liqRedeemTPTo,\\n            (tp_, sender_, recipient_, acBalanceOf(address(this)))\\n        );\\n        qACRedeemed = abi.decode(Address.functionDelegateCall(mocCoreExpansion, payload), (uint256));\\n        // transfer qAC to the recipient, reverts if fail\\n        acTransfer(recipient_, qACRedeemed);\\n        return qACRedeemed;\\n    }\\n\\n    /**\\n     * @notice Distributes Operation results to the different recipients\\n     * @param sender_ address who executes the operation\\n     * @param operatorsAddress_ operator's address to receive `operatorsQAC_`\\n     * @param operatorsQAC_ amount of AC to transfer operator [N]\\n     * @param vendor_ vendors address to pay markup to\\n     * @param feeCalcs_ struct with:\\n     * @dev\\n     *      qACFee amount of AC needed to pay fees\\n     *      qFeeToken amount of Fee Token needed to pay fess\\n     *      qACVendorMarkup amount of AC needed to pay vendor markup\\n     *      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup\\n     */\\n    function _distOpResults(\\n        address sender_,\\n        address operatorsAddress_,\\n        uint256 operatorsQAC_,\\n        address vendor_,\\n        FeeCalcs memory feeCalcs_\\n    ) internal nonReentrant {\\n        if (feeCalcs_.qACFee > 0) {\\n            // [N] = [PREC] * [N] / [PREC]\\n            uint256 qACFeeRetained = _mulPrec(feeRetainer, feeCalcs_.qACFee);\\n            // Increase collateral in the retain amount\\n            nACcb += qACFeeRetained;\\n            // transfer qAC fee to Moc Fee Flow\\n            acTransfer(mocFeeFlowAddress, feeCalcs_.qACFee - qACFeeRetained);\\n            // transfer qAC markup to vendor\\n            acTransfer(vendor_, feeCalcs_.qACVendorMarkup);\\n        }\\n        // if qACFee == 0 then the fees are paid in Fee Token\\n        else {\\n            // transfer Fee Token to Moc Fee Flow\\n            _feeTokenTransfer(sender_, mocFeeFlowAddress, feeCalcs_.qFeeToken);\\n            // transfer Fee Token to vendor\\n            _feeTokenTransfer(sender_, vendor_, feeCalcs_.qFeeTokenVendorMarkup);\\n        }\\n        // transfer qAC to operator\\n        acTransfer(operatorsAddress_, operatorsQAC_);\\n    }\\n\\n    /**\\n     * @notice transfer Fee Tokens from an address to another\\n     * @dev this function could revert during safeTransfer call.\\n     *  safeTransfer will revert if token transfer reverts or returns 0\\n     * @param from_ address who sends the Fee Token\\n     * @param to_ address who receives the Fee Token\\n     * @param amount_ amount of Fee Token to transfer\\n     */\\n    function _feeTokenTransfer(address from_, address to_, uint256 amount_) internal {\\n        if (amount_ > 0) SafeERC20.safeTransferFrom(feeToken, from_, to_, amount_);\\n    }\\n\\n    // ------- Public Functions -------\\n\\n    /**\\n     * @notice Allow redeem on liquidation state, user Peg balance gets burned and he receives\\n     * the equivalent AC given the liquidation frozen price.\\n     * @param tp_ Pegged Token address\\n     * @return qACRedeemed amount of AC sent to sender\\n     */\\n    function liqRedeemTP(address tp_) external returns (uint256 qACRedeemed) {\\n        return _liqRedeemTPTo(tp_, msg.sender, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Allow redeem on liquidation state, user Peg balance gets burned and he receives\\n     * the equivalent AC given the liquidation frozen price.\\n     * @param tp_ Pegged Token address\\n     * @param recipient_ address who receives the AC\\n     * @return qACRedeemed amount of AC sent to `recipient_`\\n     */\\n    function liqRedeemTPto(address tp_, address recipient_) external returns (uint256 qACRedeemed) {\\n        return _liqRedeemTPTo(tp_, msg.sender, recipient_);\\n    }\\n\\n    /**\\n     * @notice distribute appreciation factor to beneficiary and success fee to Moc Fee Flow\\n     */\\n    function _distributeSuccessFee() internal nonReentrant {\\n        uint256 mocGain = 0;\\n        uint256 pegAmount = pegContainer.length;\\n        uint256[] memory tpToMint = new uint256[](pegAmount);\\n        for (uint256 i = 0; i < pegAmount; i = unchecked_inc(i)) {\\n            uint256 pACtp = _getPACtp(i);\\n            _updateTPtracking(i, pACtp);\\n            int256 iou = tpiou[i];\\n            if (iou > 0) {\\n                // [N] = (([PREC] * [PREC] / [PREC]) * [N]) / [PREC]\\n                tpToMint[i] = _mulPrec(_mulPrec(appreciationFactor, pACtp), uint256(iou));\\n                // [N] = [N] + [N]\\n                mocGain += uint256(iou);\\n                // reset TP profit\\n                tpiou[i] = 0;\\n                _depositAndMintTP(i, tpToMint[i], 0, mocAppreciationBeneficiaryAddress);\\n            }\\n        }\\n        if (mocGain != 0) {\\n            // [N] = [N] * [PREC] / [PREC]\\n            mocGain = _mulPrec(mocGain, successFee);\\n            // sub qAC from the Bucket\\n            nACcb -= mocGain;\\n            // transfer the mocGain AC to Moc Fee Flow\\n            acTransfer(mocFeeFlowAddress, mocGain);\\n        }\\n        emit SuccessFeeDistributed(mocGain, tpToMint);\\n    }\\n\\n    // ------- External Functions -------\\n\\n    /**\\n     * @notice this function is executed during settlement.\\n     *  stores amount of locked AC by Pegged Tokens at this moment and distribute success fee\\n     */\\n    function execSettlement() external notPaused {\\n        // check if it is in the corresponding block to execute the settlement\\n        if (block.number < bns) revert MissingBlocksToSettlement();\\n        unchecked {\\n            bns = block.number + bes;\\n        }\\n        emit SettlementExecuted();\\n        _distributeSuccessFee();\\n    }\\n\\n    /**\\n     * @notice executes the interest payment of the TC holders\\n     *  can only be executed after a block span\\n     * @dev\\n     *  -   The amount is not differential, it's a snapshot of the moment it's executed\\n     *  -   It does not check coverage\\n     */\\n    function tcHoldersInterestPayment() external notPaused nonReentrant {\\n        // check if it is in the corresponding block to execute the interest payment\\n        if (block.number < nextTCInterestPayment) revert MissingBlocksToTCInterestPayment();\\n        unchecked {\\n            nextTCInterestPayment = block.number + tcInterestPaymentBlockSpan;\\n        }\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 interestAmount = _mulPrec(nACcb, tcInterestRate);\\n        emit TCInterestPayment(interestAmount);\\n        // transfer interests to the interest collector address, reverts if fail\\n        acTransfer(tcInterestCollectorAddress, interestAmount);\\n    }\\n\\n    // ------- Only Authorized Changer Functions -------\\n\\n    /**\\n     * @dev sets Moc Core Expansion contract address\\n     * @param mocCoreExpansion_ moc core expansion new contract address\\n     */\\n    function setMocCoreExpansion(address mocCoreExpansion_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        mocCoreExpansion = mocCoreExpansion_;\\n    }\\n\\n    /**\\n     * @notice add a Pegged Token to the protocol\\n     * @dev Note that the ema value, should consider `nextEmaCalculation`\\n     *  This function is implemented in MocCoreExpansion but with this contract context\\n     * @param peggedTokenParams_ params of Pegged Token to add\\n     * @dev\\n     *      tpTokenAddress Pegged Token contract address to add\\n     *      priceProviderAddress Pegged Token price provider contract address\\n     *      tpCtarg Pegged Token target coverage [PREC]\\n     *      tpMintFee additional fee pct applied on mint [PREC]\\n     *      tpRedeemFee additional fee pct applied on redeem [PREC]\\n     *      tpEma initial Pegged Token exponential moving average [PREC]\\n     *      tpEmaSf Pegged Token smoothing factor [PREC]\\n     *\\n     *  Requirements:\\n     *\\n     * - the caller must have governance authorization.\\n     * - tpTokenAddress must be a MocRC20, with mint, burn roles already settled\\n     *  for this contract\\n     */\\n    function addPeggedToken(PeggedTokenParams calldata peggedTokenParams_) external onlyAuthorizedChanger {\\n        bytes memory payload = abi.encodeCall(MocCoreExpansion(mocCoreExpansion).addPeggedToken, (peggedTokenParams_));\\n        // slither-disable-next-line unused-return\\n        Address.functionDelegateCall(mocCoreExpansion, payload);\\n    }\\n\\n    /**\\n     * @notice modifies a Pegged Token of the protocol\\n     * @dev Note that the ema value, should consider `nextEmaCalculation`\\n     *  This function is implemented in MocCoreExpansion but with this contract context\\n     * @param peggedTokenParams_ params of Pegged Token to add\\n     * @dev\\n     *      tpTokenAddress Pegged Token contract address to identify the token to edit\\n     *      priceProviderAddress Pegged Token price provider contract address\\n     *      tpCtarg Pegged Token target coverage [PREC]\\n     *      tpMintFee additional fee pct applied on mint [PREC]\\n     *      tpRedeemFee additional fee pct applied on redeem [PREC]\\n     *      tpEma initial Pegged Token exponential moving average [PREC]\\n     *      tpEmaSf Pegged Token smoothing factor [PREC]\\n     *\\n     *  Requirements:\\n     *\\n     * - the caller must have governance authorization.\\n     * - the tpTokenAddress must exists\\n     */\\n    function editPeggedToken(PeggedTokenParams calldata peggedTokenParams_) external onlyAuthorizedChanger {\\n        bytes memory payload = abi.encodeCall(MocCoreExpansion(mocCoreExpansion).editPeggedToken, (peggedTokenParams_));\\n        // slither-disable-next-line unused-return\\n        Address.functionDelegateCall(mocCoreExpansion, payload);\\n    }\\n\\n    /**\\n     * @dev sets Moc Vendors contract address\\n     * @param mocVendors_ moc Vendors new contract address\\n     */\\n    function setMocVendors(address mocVendors_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        mocVendors = MocVendors(mocVendors_);\\n    }\\n\\n    // ------- Getters Functions -------\\n\\n    /**\\n     * @notice get Collateral Token price\\n     * @return pTCac [PREC]\\n     */\\n    function getPTCac() external view returns (uint256 pTCac) {\\n        (uint256 lckAC, uint256 nACgain) = _getLckACandACgain();\\n        return _getPTCac(lckAC, nACgain);\\n    }\\n\\n    /**\\n     * @notice get bucket global coverage\\n     * @return cglob [PREC]\\n     */\\n    function getCglb() external view returns (uint256 cglob) {\\n        (uint256 lckAC, uint256 nACgain) = _getLckACandACgain();\\n        return _getCglb(lckAC, nACgain);\\n    }\\n\\n    /**\\n     * @notice get amount of Collateral Asset locked by Pegged Token\\n     * @return lckAC [PREC]\\n     */\\n    function getLckAC() external view returns (uint256 lckAC) {\\n        (lckAC, ) = _getLckACandACgain();\\n        return lckAC;\\n    }\\n\\n    /**\\n     * @notice get amount of Collateral Token available to redeem\\n     * @dev because it is a view function we are not calculating the new ema,\\n     *  since we are using the last ema calculation, this may differ a little from the real amount\\n     *  of TC available to redeem. Consider it an approximation.\\n     * @return tcAvailableToRedeem [N]\\n     */\\n    function getTCAvailableToRedeem() external view returns (int256 tcAvailableToRedeem) {\\n        (uint256 ctargemaCA, uint256[] memory pACtps) = _calcCtargemaCA();\\n        (uint256 lckAC, uint256 nACgain) = _calcLckACandACgain(pACtps);\\n        return _getTCAvailableToRedeemSigned(ctargemaCA, lckAC, nACgain);\\n    }\\n\\n    /**\\n     * @notice get amount of Pegged Token available to mint\\n     * @dev because it is a view function we are not calculating the new ema,\\n     *  since we are using the last ema calculation, this may differ a little from the real amount\\n     *  of TP available to mint. Consider it an approximation.\\n     * @param tp_ Pegged Token address\\n     * @return tpAvailableToMint [N]\\n     */\\n    function getTPAvailableToMint(address tp_) external view returns (int256 tpAvailableToMint) {\\n        (uint256 ctargemaCA, uint256[] memory pACtps) = _calcCtargemaCA();\\n        uint256 i = _tpi(tp_);\\n        uint256 pACtp = pACtps[i];\\n        (uint256 lckAC, uint256 nACgain) = _calcLckACandACgain(pACtps);\\n        return _getTPAvailableToMintSigned(ctargemaCA, _getCtargemaTP(i, pACtp), pACtp, lckAC, nACgain);\\n    }\\n\\n    /**\\n     * @notice get total Collateral Asset available\\n     * @return totalACavailable [N]\\n     */\\n    function getTotalACavailable() external view returns (uint256 totalACavailable) {\\n        (, uint256 nACgain) = _getLckACandACgain();\\n        return _getTotalACavailable(nACgain);\\n    }\\n\\n    /**\\n     * @notice get Collateral Token leverage\\n     * @return leverageTC [PREC]\\n     */\\n    function getLeverageTC() external view returns (uint256 leverageTC) {\\n        (uint256 lckAC, uint256 nACgain) = _getLckACandACgain();\\n        return _getLeverageTC(lckAC, nACgain);\\n    }\\n\\n    /**\\n     * @notice get the number of blocks remaining for settlement\\n     */\\n    function getBts() external view returns (uint256) {\\n        if (block.number >= bns) return 0;\\n        return bns - block.number;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x16a4285c2225d77647a04be98f8527e4f0a4c15086d89e9b461b3ae1d169a3f8\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/core/MocCoreExpansion.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocCommons, PeggedTokenParams } from \\\"./MocCommons.sol\\\";\\nimport { IMocRC20 } from \\\"../interfaces/IMocRC20.sol\\\";\\nimport { IPriceProvider } from \\\"../interfaces/IPriceProvider.sol\\\";\\nimport { IDataProvider } from \\\"../interfaces/IDataProvider.sol\\\";\\n\\n/**\\n * @title MocCoreExpansion\\n * @notice This contract is used as an expansion of MocCore because 24kb size limitation\\n *  MocCore delegate some function calls to it.\\n * @dev IMPORTANT NOTES:\\n *  1. MocCore and MocCoreExpansion must have always the same storage layout to avoid collisions\\n *  2. Because MocCore is upgradeable and delegates calls to MocCoreExpansion, it cannot be upgradeable because\\n *      a proxy contract cannot delegate calls to another proxy contract. So, for any MocCoreExpansion upgrade\\n *      you must deploy a new implementation and set it to MocCore.\\n */\\ncontract MocCoreExpansion is MocCommons {\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice add a Pegged Token to the protocol\\n     * @dev Note that the ema value, should consider `nextEmaCalculation`\\n     *  This function is called by MocCore contract using it's context with delegate call\\n     *  Checks done there:\\n     *  -  onlyAuthorizedChanger: the caller must have governance authorization.\\n     * @param peggedTokenParams_ params of Pegged Token to add\\n     * @dev tpTokenAddress Pegged Token contract address to add\\n     *      priceProviderAddress Pegged Token price provider contract address\\n     *      tpCtarg Pegged Token target coverage [PREC]\\n     *      tpMintFee additional fee pct applied on mint [PREC]\\n     *      tpRedeemFee additional fee pct applied on redeem [PREC]\\n     *      tpEma initial Pegged Token exponential moving average [PREC]\\n     *      tpEmaSf Pegged Token smoothing factor [PREC]\\n     *\\n     *  Requirements:\\n     *\\n     *  - tpTokenAddress must be a MocRC20, with mint, burn roles already settled\\n     *  for this contract\\n     */\\n    function addPeggedToken(PeggedTokenParams calldata peggedTokenParams_) external {\\n        IMocRC20 tpToken = IMocRC20(peggedTokenParams_.tpTokenAddress);\\n\\n        IPriceProvider priceProvider = IPriceProvider(peggedTokenParams_.priceProviderAddress);\\n        if (peggedTokenIndex[address(tpToken)].exists) revert PeggedTokenAlreadyAdded();\\n        uint256 newTPindex = uint256(tpTokens.length);\\n        peggedTokenIndex[address(tpToken)] = PeggedTokenIndex({ index: newTPindex, exists: true });\\n\\n        // set Pegged Token address\\n        tpTokens.push(tpToken);\\n        // set peg container item\\n        pegContainer.push(PegContainerItem({ nTP: 0, priceProvider: priceProvider }));\\n        // set target coverage\\n        tpCtarg.push(peggedTokenParams_.tpCtarg);\\n        // set mint fee pct\\n        tpMintFees[peggedTokenParams_.tpTokenAddress] = peggedTokenParams_.tpMintFee;\\n        // set redeem fee pct\\n        tpRedeemFees[peggedTokenParams_.tpTokenAddress] = peggedTokenParams_.tpRedeemFee;\\n        // set EMA initial value and smoothing factor\\n        tpEma.push(EmaItem({ ema: peggedTokenParams_.tpEma, sf: peggedTokenParams_.tpEmaSf }));\\n        tpiou.push();\\n        // reverts if price provider is invalid\\n        pACtpLstop.push(_getPACtp(newTPindex));\\n        // emit the event\\n        emit PeggedTokenChange(newTPindex, peggedTokenParams_);\\n    }\\n\\n    /**\\n     * @notice modifies a Pegged Token of the protocol\\n     * @dev Note that the ema value, should consider `nextEmaCalculation`\\n     *  This function is called by MocCore contract using it's context with delegate call\\n     *  Checks done there:\\n     *  -  onlyAuthorizedChanger: the caller must have governance authorization.\\n     * @param peggedTokenParams_ params of Pegged Token to add\\n     * @dev tpTokenAddress Pegged Token contract address to identify the token to edit\\n     *      priceProviderAddress Pegged Token price provider contract address\\n     *      tpCtarg Pegged Token target coverage [PREC]\\n     *      tpMintFee additional fee pct applied on mint [PREC]\\n     *      tpRedeemFee additional fee pct applied on redeem [PREC]\\n     *      tpEma initial Pegged Token exponential moving average [PREC]\\n     *      tpEmaSf Pegged Token smoothing factor [PREC]\\n     *\\n     *  Requirements:\\n     *\\n     * - the tpTokenAddress must exists\\n     */\\n    function editPeggedToken(PeggedTokenParams calldata peggedTokenParams_) external {\\n        PeggedTokenIndex memory ptIndex = peggedTokenIndex[peggedTokenParams_.tpTokenAddress];\\n        if (!ptIndex.exists) revert InvalidAddress();\\n        uint256 i = ptIndex.index;\\n        // if being edited, verifies it is a valid priceProvider\\n        if (peggedTokenParams_.priceProviderAddress != address(pegContainer[i].priceProvider)) {\\n            IPriceProvider priceProvider = IPriceProvider(peggedTokenParams_.priceProviderAddress);\\n            (, bool has) = priceProvider.peek();\\n            if (!has) revert InvalidAddress();\\n            pegContainer[i].priceProvider = priceProvider;\\n        }\\n        // set target coverage\\n        tpCtarg[i] = peggedTokenParams_.tpCtarg;\\n        // set mint fee pct\\n        tpMintFees[peggedTokenParams_.tpTokenAddress] = peggedTokenParams_.tpMintFee;\\n        // set redeem fee pct\\n        tpRedeemFees[peggedTokenParams_.tpTokenAddress] = peggedTokenParams_.tpRedeemFee;\\n        // set EMA initial value and smoothing factor\\n        tpEma[i].sf = peggedTokenParams_.tpEmaSf;\\n        // emit the event\\n        emit PeggedTokenChange(i, peggedTokenParams_);\\n    }\\n\\n    /**\\n     * @notice Allow redeem on liquidation state, user Peg balance gets burned\\n     * @dev This function is called by MocCore contract using it's context with delegate call\\n     *  The equivalent AC given the liquidation frozen price(qACRedeemed) is transferred\\n     *  to the `recipient_` by MocCore contract\\n     *  Checks done there:\\n     *  -  notPaused: the contract must be unpaused\\n     * @param tp_ Pegged Token address\\n     * @param sender_ address owner of the TP to be redeemed\\n     * @param recipient_ address who receives the AC\\n     * @return qACRedeemed amount of AC sent to `recipient_`\\n     */\\n    function liqRedeemTPTo(\\n        address tp_,\\n        address sender_,\\n        address recipient_,\\n        uint256 mocACBalance\\n    ) external returns (uint256 qACRedeemed) {\\n        if (!liquidated) revert OnlyWhenLiquidated();\\n        uint256 i = _tpi(tp_);\\n        uint256 qTP = tpTokens[i].balanceOf(sender_);\\n        // slither-disable-next-line incorrect-equality\\n        if (qTP == 0) revert InsufficientTPtoRedeem(qTP, qTP);\\n        // [PREC]\\n        uint256 liqPACtp = tpLiqPrices[i];\\n        // [PREC] = [N] * [PREC] / [PREC]\\n        qACRedeemed = _divPrec(qTP, liqPACtp);\\n        // Given rounding errors, the last redeemer might receive a little less\\n        if (mocACBalance < qACRedeemed) qACRedeemed = mocACBalance;\\n        // in liquidation doesn't pay fees or markup\\n        // qACfee, qFeeToken, qACVendorMarkup, qFeeTokenVendorMarkup  = (0, 0, 0, 0)\\n        // TODO use a function instead\\n        emit LiqTPRedeemed(tp_, sender_, recipient_, qTP, qACRedeemed);\\n        // burn qTP from the sender\\n        tpTokens[i].burn(sender_, qTP);\\n    }\\n\\n    /**\\n     * @notice mint Collateral Token and Pegged Token in exchange for Collateral Asset\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are minted in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qAC sent are insufficient.\\n     * @param params_ mint TC and TP function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTP_ amount of Pegged Token to mint\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent\\n     *      sender_ address who sends Collateral Asset\\n     *      recipient_ address who receives the Collateral Token and Pegged Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtotalNeeded amount of AC used to mint Collateral Token and Pegged Token\\n     * @return qTCtoMint amount of Collateral Token minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function mintTCandTPto(\\n        MintTCandTPParams memory params_\\n    )\\n        external\\n        payable\\n        returns (uint256 qACtotalNeeded, uint256 qTCtoMint, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        uint256 qACNeededtoMint;\\n        uint256 qACtoMintTP;\\n        uint256[] memory pACtps = _getPACtps();\\n        uint256 i = _tpi(params_.tp);\\n        uint256 pACtp = pACtps[i];\\n        _updateTPtracking(i, pACtp);\\n        // evaluates that the system is not below the liquidation threshold\\n        // one of the reasons is to prevent it from failing due to underflow because the lckAC > totalACavailable\\n        (uint256 lckAC, uint256 nACgain) = _evalCoverage(liqThrld, pACtps);\\n        (qTCtoMint, qACNeededtoMint, qACtoMintTP) = _calcQACforMintTCandTP(\\n            params_.qTP,\\n            pACtp,\\n            _getCtargemaTP(i, pACtp),\\n            _getPTCac(lckAC, nACgain)\\n        );\\n        uint256 qACSurcharges;\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACNeededtoMint,\\n            mintTCandTPFee\\n        );\\n        qACtotalNeeded = qACNeededtoMint + qACSurcharges;\\n        if (qACtotalNeeded > params_.qACmax) revert InsufficientQacSent(params_.qACmax, qACtotalNeeded);\\n        // if is 0 reverts because it is trying to mint an amount below precision\\n        // slither-disable-next-line incorrect-equality\\n        if (qACtotalNeeded == 0) revert QacNeededMustBeGreaterThanZero();\\n        // update flux capacitor and reverts if not allowed by accumulators\\n        _updateAccumulatorsOnMintTP(qACtoMintTP);\\n        _depositAndMintTC(qTCtoMint, qACNeededtoMint, params_.recipient);\\n        _depositAndMintTP(i, params_.qTP, 0, params_.recipient);\\n    }\\n\\n    /**\\n     * @notice redeem Collateral Asset in exchange for Collateral Token and Pegged Token\\n     *  This operation is done without checking coverage\\n     *  Collateral Token and Pegged Token are redeemed in equivalent proportions so that its price\\n     *  and global coverage are not modified.\\n     *  Reverts if qTP sent are insufficient.\\n     * @param params_ redeem TC and TP function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTC_ amount of Collateral Token to redeem\\n     *      qTP_ maximum amount of Pegged Token to redeem\\n     *      qACmin_ minimum amount of Collateral Asset that `recipient_` expects to receive\\n     *      sender_ address who sends Collateral Token and Pegged Token\\n     *      recipient_ address who receives the Collateral Asset\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACtoRedeem amount of AC sent to `recipient_`\\n     * @return qTPtoRedeem amount of Pegged Token redeemed\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs platform fee detail breakdown\\n     */\\n    function redeemTCandTPto(\\n        RedeemTCandTPParams memory params_,\\n        address operator\\n    )\\n        external\\n        payable\\n        returns (uint256 qACtoRedeem, uint256 qTPtoRedeem, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        (uint256 ctargemaCA, uint256[] memory pACtps) = _updateEmasAndCalcCtargemaCA();\\n        uint256 i = _tpi(params_.tp);\\n        uint256 pACtp = pACtps[i];\\n        _updateTPtracking(i, pACtp);\\n        // evaluates that the system is not below the liquidation threshold\\n        // one of the reasons is to prevent it from failing due to underflow because the lckAC > totalACavailable\\n        (uint256 lckAC, uint256 nACgain) = _evalCoverage(liqThrld, pACtps);\\n        // calculate how many TP are needed to redeem TC and not change coverage\\n        // qTPtoRedeem = (qTC * pACtp * pTCac)(ctargemaCA - 1) / (cglb - 1)(ctargemaTP - 1)\\n        // pTCac = (totalACavailable - lckAC) / nTCcb\\n        // cglb = totalACavailable / lckAC => cglb - 1 = (totalACavailable - lckAC) / lckAC\\n        // qTPtoRedeem = (qTC * pACtp * (totalACavailable - lckAC)(ctargemaCA - 1) / nTCcb) / ...\\n        // ...((totalACavailable - lckAC) / lckAC)(ctargemaTP - 1)\\n        // So, we can simplify (totalACavailable - lckAC)\\n        // [PREC] = [PREC] * [PREC] / [PREC]\\n        uint256 aux = (pACtp * (ctargemaCA - ONE)) / (_getCtargemaTP(i, pACtp) - ONE);\\n        // [N] = ([N] * [N] * [PREC] / [N]) / [PREC]\\n        qTPtoRedeem = ((params_.qTC * lckAC * aux) / nTCcb) / PRECISION;\\n        if (qTPtoRedeem > params_.qTP) revert InsufficientQtpSent(params_.qTP, qTPtoRedeem);\\n        // if qTC == 0 => qTPtoRedeem == 0 and will revert because QacNeededMustBeGreaterThanZero\\n        (uint256 qACtotalToRedeem, uint256 qACtoRedeemTP) = _calcQACforRedeemTCandTP(\\n            params_.qTC,\\n            qTPtoRedeem,\\n            pACtp,\\n            _getPTCac(lckAC, nACgain)\\n        );\\n        uint256 qACSurcharges;\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACtotalToRedeem,\\n            redeemTCandTPFee\\n        );\\n        qACtoRedeem = qACtotalToRedeem - qACSurcharges;\\n        if (qACtoRedeem < params_.qACmin) revert QacBelowMinimumRequired(params_.qACmin, qACtoRedeem);\\n        // update flux capacitor and reverts if not allowed by accumulators\\n        _updateAccumulatorsOnRedeemTP(qACtoRedeemTP);\\n        _withdrawAndBurnTC(params_.qTC, qACtotalToRedeem, operator);\\n        _withdrawAndBurnTP(i, qTPtoRedeem, 0, operator);\\n    }\\n\\n    /**\\n     * @notice swap Pegged Token to another one\\n     *  This operation is done without checking coverage unless the target coverage for\\n     *  received Pegged Token is greater than the Pegged Token sent\\n     * @dev This function is called by MocCore contract using it's context with delegate call\\n     * @param params_ swap TP for TP function parameters\\n     * @dev\\n     *      iFrom_ owned Pegged Token index\\n     *      iTo_ target Pegged Token index\\n     *      qTP_ amount of owned Pegged Token to swap\\n     *      qTPmin_ minimum amount of target Pegged Token that `recipient_` expects to receive\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     *      sender_ address who sends the Pegged Token\\n     *      recipient_ address who receives the target Pegged Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACSurcharges amount of AC used to pay fees and markup\\n     * @return qTPtoMint amount of Pegged Token minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs struct with:\\n     * @dev\\n     *      qACFee amount of AC needed to pay fees\\n     *      qFeeToken amount of Fee Token needed to pay fess\\n     *      qACVendorMarkup amount of AC needed to pay vendor markup\\n     *      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup\\n     */\\n    function swapTPforTPto(\\n        SwapTPforTPParams memory params_,\\n        address operator\\n    )\\n        external\\n        payable\\n        returns (uint256 qACSurcharges, uint256 qTPtoMint, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        if (params_.tpFrom == params_.tpTo) revert InvalidValue();\\n        uint256 iFrom = _tpi(params_.tpFrom);\\n        uint256 iTo = _tpi(params_.tpTo);\\n        uint256 pACtpFrom = _getPACtp(iFrom);\\n        uint256 pACtpTo = _getPACtp(iTo);\\n        _updateTPtracking(iFrom, pACtpFrom);\\n        _updateTPtracking(iTo, pACtpTo);\\n        // calculate how many total qAC are redeemed\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 qACtotalToRedeem = _divPrec(params_.qTP, pACtpFrom);\\n        // calculate how many qTP can mint with the given qAC\\n        // [N] = [N] * [PREC] / [PREC]\\n        qTPtoMint = (params_.qTP * pACtpTo) / pACtpFrom;\\n        if (qTPtoMint < params_.qTPmin || qTPtoMint == 0) revert QtpBelowMinimumRequired(params_.qTPmin, qTPtoMint);\\n\\n        // if ctargemaTPto > ctargemaTPfrom we need to check coverage\\n        if (_getCtargemaTP(iTo, pACtpTo) > _getCtargemaTP(iFrom, pACtpFrom)) {\\n            (uint256 ctargemaCA, uint256[] memory pACtps) = _updateEmasAndCalcCtargemaCA();\\n            // evaluates whether or not the system coverage is healthy enough to mint TP\\n            // given the target coverage adjusted by the moving average, reverts if it's not\\n            (uint256 lckAC, uint256 nACgain) = _evalCoverage(ctargemaCA, pACtps);\\n            // evaluates if there are enough TP available to mint, reverts if it's not\\n            _evalTPavailableToMint(iTo, qTPtoMint, pACtpTo, ctargemaCA, lckAC, nACgain);\\n        }\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACtotalToRedeem,\\n            swapTPforTPFee\\n        );\\n        if (qACSurcharges > params_.qACmax) revert InsufficientQacSent(params_.qACmax, feeCalcs.qACFee);\\n        _depositAndMintTP(iTo, qTPtoMint, 0, params_.recipient);\\n        _withdrawAndBurnTP(iFrom, params_.qTP, 0, operator);\\n    }\\n\\n    /**\\n     * @notice swap Pegged Token to Collateral Token\\n     * @dev This function is called by MocCore contract using it's context with delegate call\\n     * @param params_ swap TP for TC function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTP_ amount Pegged Token to swap\\n     *      qTCmin_ minimum amount of Collateral Token that `recipient_` expects to receive\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     *      sender_ address who sends the Pegged Token\\n     *      recipient_ address who receives Collateral Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACSurcharges amount of AC used to pay fees and markup\\n     * @return qTCtoMint amount of Collateral Token minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @return feeCalcs struct with:\\n     * @dev\\n     *      qACFee amount of AC needed to pay fees\\n     *      qFeeToken amount of Fee Token needed to pay fess\\n     *      qACVendorMarkup amount of AC needed to pay vendor markup\\n     *      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup\\n     */\\n    function swapTPforTCto(\\n        SwapTPforTCParams memory params_,\\n        address operator\\n    )\\n        external\\n        payable\\n        returns (uint256 qACSurcharges, uint256 qTCtoMint, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        uint256[] memory pACtps = _getPACtps();\\n        uint256 i = _tpi(params_.tp);\\n        uint256 pACtp = pACtps[i];\\n        _updateTPtracking(i, pACtp);\\n        // evaluates whether or not the system coverage is healthy enough to mint TC, reverts if it's not\\n        (uint256 lckAC, uint256 nACgain) = _evalCoverage(protThrld, pACtps);\\n        // calculate how many total qAC are redeemed TP\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 qACtotalToRedeem = _divPrec(params_.qTP, pACtp);\\n        // calculate how many qTC can mint with the given qAC\\n        // qTCtoMint = qTP / pTCac / pACtp\\n        // [N] = [N] * [N] * [PREC] / ([N] - [N]) * [PREC]\\n        qTCtoMint = _divPrec(params_.qTP * nTCcb, (_getTotalACavailable(nACgain) - lckAC) * pACtp);\\n        // slither-disable-next-line incorrect-equality\\n        if (qTCtoMint < params_.qTCmin || qTCtoMint == 0) revert QtcBelowMinimumRequired(params_.qTCmin, qTCtoMint);\\n\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACtotalToRedeem,\\n            swapTPforTCFee\\n        );\\n        if (qACSurcharges > params_.qACmax) revert InsufficientQacSent(params_.qACmax, feeCalcs.qACFee);\\n        // update flux capacitor and reverts if not allowed by accumulators\\n        _updateAccumulatorsOnRedeemTP(qACtotalToRedeem);\\n        _withdrawAndBurnTP(i, params_.qTP, 0, operator);\\n        _depositAndMintTC(qTCtoMint, 0, params_.recipient);\\n    }\\n\\n    /**\\n     * @notice swap Collateral Token to Pegged Token\\n     * @dev This function is called by MocCore contract using it's context with delegate call\\n     * @param params_ swap TC for TP function parameters\\n     * @dev\\n     *      i_ Pegged Token index\\n     *      qTC_ amount of Collateral Token to swap\\n     *      qTPmin_ minimum amount of Pegged Token Token that `recipient_` expects to receive\\n     *      qACmax_ maximum amount of Collateral Asset that can be spent in fees\\n     *      sender_ address who sends the Collateral Token\\n     *      recipient_ address who receives the Pegged Token\\n     *      vendor_ address who receives a markup. If its address(0) no markup is applied\\n     * @return qACSurcharges amount of AC used to pay fees and markup\\n     * @return qTPtoMint amount of Pegged Token minted\\n     * @return qFeeTokenTotalNeeded amount of Fee Token used by `sender_` to pay fees. 0 if qAC is used instead\\n     * @dev\\n     *      qACFee amount of AC needed to pay fees\\n     *      qFeeToken amount of Fee Token needed to pay fess\\n     *      qACVendorMarkup amount of AC needed to pay vendor markup\\n     *      qFeeTokenVendorMarkup amount of Fee Token needed to pay vendor markup\\n     */\\n    function swapTCforTPto(\\n        SwapTCforTPParams memory params_,\\n        address operator\\n    )\\n        external\\n        payable\\n        returns (uint256 qACSurcharges, uint256 qTPtoMint, uint256 qFeeTokenTotalNeeded, FeeCalcs memory feeCalcs)\\n    {\\n        (uint256 ctargemaCA, uint256[] memory pACtps) = _updateEmasAndCalcCtargemaCA();\\n        uint256 i = _tpi(params_.tp);\\n        uint256 pACtp = pACtps[i];\\n        _updateTPtracking(i, pACtp);\\n        // evaluates whether or not the system coverage is healthy enough to redeem TC\\n        // given the target coverage adjusted by the moving average, reverts if it's not\\n        (uint256 lckAC, uint256 nACgain) = _evalCoverage(ctargemaCA, pACtps);\\n        // evaluates if there are enough Collateral Tokens available to redeem, reverts if there are not\\n        _evalTCAvailableToRedeem(params_.qTC, ctargemaCA, lckAC, nACgain);\\n        // calculate how many total qAC are redeemed\\n        // [N] = [N] * [PREC] / [PREC]\\n        uint256 qACtotalToRedeem = _mulPrec(params_.qTC, _getPTCac(lckAC, nACgain));\\n        // if is 0 reverts because it is trying to swap an amount below precision\\n        // slither-disable-next-line incorrect-equality\\n        if (qACtotalToRedeem == 0) revert QacNeededMustBeGreaterThanZero();\\n        // calculate how many qTP can mint with the given qAC\\n        // qTPtoMint = qTC * pTCac * pACtp\\n        // [N] = ([N] * ([N] - [N]) * [PREC] / [N]) / [PREC]\\n        qTPtoMint = ((params_.qTC * (_getTotalACavailable(nACgain) - lckAC) * pACtp) / nTCcb) / PRECISION;\\n        // evaluates if there are enough TP available to mint, reverts if it's not\\n        _evalTPavailableToMint(i, qTPtoMint, pACtp, ctargemaCA, lckAC, nACgain);\\n        if (qTPtoMint < params_.qTPmin) revert QtpBelowMinimumRequired(params_.qTPmin, qTPtoMint);\\n\\n        (qACSurcharges, qFeeTokenTotalNeeded, feeCalcs) = _calcFees(\\n            params_.sender,\\n            params_.vendor,\\n            qACtotalToRedeem,\\n            swapTCforTPFee\\n        );\\n        if (qACSurcharges > params_.qACmax) revert InsufficientQacSent(params_.qACmax, feeCalcs.qACFee);\\n        // update flux capacitor and reverts if not allowed by accumulators\\n        _updateAccumulatorsOnMintTP(qACtotalToRedeem);\\n        _withdrawAndBurnTC(params_.qTC, 0, operator);\\n        _depositAndMintTP(i, qTPtoMint, 0, params_.recipient);\\n    }\\n\\n    /**\\n     * @notice calculate how many Collateral Asset are needed to mint an amount of Collateral Token\\n     * and Pegged Token in one operation\\n     * @param qTP_ amount of Pegged Token to mint\\n     * @param pACtp_ Pegged Token price [PREC]\\n     * @param ctargemaTP_ target coverage adjusted by the moving average of the value of a Pegged Token\\n     * @param pTCac_ Collateral Token price [PREC]\\n     * @return qTCtoMint amount of Collateral Token to mint [N]\\n     * @return qACNeededtoMint total amount of Collateral Asset needed to mint [N]\\n     * @return qACtoMintTP amount of Collateral Asset used to mint Pegged Token [N]\\n     */\\n    function _calcQACforMintTCandTP(\\n        uint256 qTP_,\\n        uint256 pACtp_,\\n        uint256 ctargemaTP_,\\n        uint256 pTCac_\\n    ) internal pure returns (uint256 qTCtoMint, uint256 qACNeededtoMint, uint256 qACtoMintTP) {\\n        // calculate how many TC are needed to mint TP and total qAC used for mint both\\n        // [N] = [N] * ([PREC] - [PREC]) / [PREC]\\n        qACNeededtoMint = (qTP_ * (ctargemaTP_ - ONE)) / pACtp_;\\n        // [N] = [N] *  [PREC] / [PREC]\\n        qTCtoMint = _divPrec(qACNeededtoMint, pTCac_);\\n        // [N] = [N] *  [PREC] / [PREC]\\n        qACtoMintTP = _divPrec(qTP_, pACtp_);\\n        // [N] = [N] + [N]\\n        qACNeededtoMint = qACNeededtoMint + qACtoMintTP;\\n        return (qTCtoMint, qACNeededtoMint, qACtoMintTP);\\n    }\\n\\n    /**\\n     * @notice calculate how many Collateral Asset are needed to redeem an amount of Collateral Token\\n     * and Pegged Token in one operation\\n     * @param qTC_ amount of Collateral Token to redeem\\n     * @param qTP_ amount of Pegged Token to redeem\\n     * @param pACtp_ Pegged Token price [PREC]\\n     * @param pTCac_ Collateral Token price [PREC]\\n     * @return qACtotalToRedeem total amount of Collateral Asset needed to redeem, including fees [N]\\n     * @return qACtoRedeemTP amount of Collateral Asset used to redeem Pegged Token [N]\\n     */\\n    function _calcQACforRedeemTCandTP(\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 pACtp_,\\n        uint256 pTCac_\\n    ) internal pure returns (uint256 qACtotalToRedeem, uint256 qACtoRedeemTP) {\\n        // calculate how many total qAC are redeemed\\n        // [N] = [N] * [PREC] / [PREC]\\n        qACtoRedeemTP = _divPrec(qTP_, pACtp_);\\n        // if is 0 reverts because it is trying to redeem an amount of TP below precision\\n        // we check it here to prevent qTP == 0 && qTC != 0\\n        // slither-disable-next-line incorrect-equality\\n        if (qACtoRedeemTP == 0) revert QacNeededMustBeGreaterThanZero();\\n        // calculate how many qAC are redeemed because TC\\n        // [N] = [N] * [PREC] / [PREC]\\n        // TODO: rounding error could be avoid replacing here with qTC_ * totalACavailable / nTCcb\\n        qACtotalToRedeem = qACtoRedeemTP + _mulPrec(qTC_, pTCac_);\\n        return (qACtotalToRedeem, qACtoRedeemTP);\\n    }\\n}\\n\",\"keccak256\":\"0x6ed22a1a501ddc71625c0070519d58cbe8d34ef49baa82397d361fc8964e3c44\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/core/MocEma.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IMocRC20 } from \\\"../interfaces/IMocRC20.sol\\\";\\nimport { MocBaseBucket } from \\\"./MocBaseBucket.sol\\\";\\n\\n/**\\n * @title MocEma: Exponential Moving Average\\n * @notice Moc Ema, provides a set of methods that allows to calculate and track\\n * Exponential Moving Average for each of the pegged Tokens.\\n * @dev More information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing\\n */\\nabstract contract MocEma is MocBaseBucket {\\n    // ------- Events -------\\n    event TPemaUpdated(uint256 indexed i_, uint256 oldTPema_, uint256 newTPema_);\\n\\n    // ------- Structs -------\\n    struct EmaItem {\\n        // exponential moving average\\n        uint256 ema;\\n        // smoothing factor\\n        uint256 sf;\\n    }\\n\\n    // ------- Storage -------\\n    // TP EMA items, indexes are in sync with PeggedTokens across Moc solution\\n    EmaItem[] public tpEma;\\n    // next Ema Calculation Block number\\n    uint256 public nextEmaCalculation;\\n    // amount of blocks to wait for next ema calculation\\n    uint256 public emaCalculationBlockSpan;\\n\\n    /**\\n     * @notice calculates exponential moving average of the value of a Pegged Token\\n     * @dev more information of EMA calculation https://en.wikipedia.org/wiki/Exponential_smoothing\\n     * @param currentTPema_ current Ema value\\n     * @param pACtp_ current tp AC price\\n     */\\n    function __calcNewEma(EmaItem memory currentTPema_, uint256 pACtp_) private pure returns (uint256) {\\n        // [PREC\\u00b2] = [PREC] * ([PREC] - [PREC])\\n        uint256 term1 = currentTPema_.ema * (ONE - currentTPema_.sf);\\n        // [PREC\\u00b2] = [PREC] * [PREC]\\n        uint256 term2 = currentTPema_.sf * pACtp_;\\n        // [PREC] = ([PREC\\u00b2] + [PREC\\u00b2]) / [PREC]\\n        return (term1 + term2) / PRECISION;\\n    }\\n\\n    // ------- Initializer -------\\n    /**\\n     * @notice contract initializer\\n     * @param emaCalculationBlockSpan_ amount of blocks to wait between Pegged ema calculation\\n     */\\n    function __MocEma_init_unchained(uint256 emaCalculationBlockSpan_) internal onlyInitializing {\\n        if (emaCalculationBlockSpan_ == 0) revert InvalidValue();\\n        emaCalculationBlockSpan = emaCalculationBlockSpan_;\\n        _updateNextEmaCalculation(emaCalculationBlockSpan_);\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * @notice updates next EMA block calculation\\n     * @param emaCalculationBlockSpan_ amount of blocks to wait between Pegged ema calculation\\n     */\\n    function _updateNextEmaCalculation(uint256 emaCalculationBlockSpan_) internal {\\n        unchecked {\\n            nextEmaCalculation = block.number + emaCalculationBlockSpan_;\\n        }\\n    }\\n\\n    /**\\n     * @notice get target coverage adjusted by the moving average of the value of a Pegged Token\\n     * @param i_ Pegged Token index\\n     * @param pACtp_ Pegged Token price [PREC]\\n     * @return ctargemaTP [PREC]\\n     */\\n    function _getCtargemaTP(uint256 i_, uint256 pACtp_) internal view returns (uint256 ctargemaTP) {\\n        uint256 auxTPctarg = tpCtarg[i_];\\n        uint256 auxTpEma = tpEma[i_].ema;\\n        if (shouldCalculateEma()) auxTpEma = __calcNewEma(tpEma[i_], pACtp_);\\n        if (auxTpEma >= pACtp_) return auxTPctarg;\\n        // [PREC] = [PREC] * [PREC] / [PREC]\\n        return (auxTPctarg * pACtp_) / auxTpEma;\\n    }\\n\\n    /**\\n     * @notice update exponential moving average of the value of a Pegged Token\\n     * @param i_ Pegged Token index\\n     */\\n    function updateTPema(uint256 i_) internal {\\n        EmaItem memory currentTPema = tpEma[i_];\\n        uint256 pACtp = _getPACtp(i_);\\n        uint256 newEma = __calcNewEma(currentTPema, pACtp);\\n        // save new ema value to storage\\n        tpEma[i_].ema = newEma;\\n        emit TPemaUpdated(i_, currentTPema.ema, newEma);\\n    }\\n\\n    /**\\n     * @notice calculates CA target coverage, adjusted by all Pegged Token's to\\n     *  Collateral Asset last stored moving average price\\n     * @dev WARN: if EMA are not up to date, the resulting coverage might not reflect real spot value\\n     *      qAC = (nTP + tpGain) / pACtp\\n     *      ctargemaCA = \\u2211(ctargemaTP * qAC) / \\u2211(qAC)\\n     * @return ctargemaCA [PREC]\\n     * @return pACtps array of all AC prices for each TP, with [PREC]\\n     */\\n    function _calcCtargemaCA() internal view returns (uint256 ctargemaCA, uint256[] memory pACtps) {\\n        uint256 num;\\n        uint256 den;\\n        uint256 pegAmount = pegContainer.length;\\n        pACtps = new uint256[](pegAmount);\\n        for (uint256 i = 0; i < pegAmount; i = unchecked_inc(i)) {\\n            uint256 pACtp = _getPACtp(i);\\n            pACtps[i] = pACtp;\\n            (uint256 tpGain, ) = _getPnLTP(i, pACtp);\\n            // [PREC] = [N] * [PREC] * [PREC]  / [PREC]\\n            uint256 qAC = _divPrec((pegContainer[i].nTP + tpGain) * PRECISION, pACtp);\\n            // [PREC]^2 = [PREC] * [PREC]\\n            num += _getCtargemaTP(i, pACtp) * qAC;\\n            // [PREC] = [PREC]\\n            den += qAC;\\n        }\\n        // we must return a default value when all nTP are 0\\n        // slither-disable-next-line incorrect-equality\\n        if (den == 0) {\\n            unchecked {\\n                return (protThrld * 2, pACtps);\\n            }\\n        }\\n        // [PREC] = ([PREC]^2) / [PREC]\\n        ctargemaCA = num / den;\\n    }\\n\\n    /**\\n     * @notice make sure Ema is up to date, and calculates target coverage adjusted by all Pegged Token's\\n     * to Collateral Asset rate moving average\\n     * @dev qAC = nTP / pACtp\\n     *      ctargemaCA = \\u2211(ctargemaTP * qAC) / \\u2211(qAC)\\n     * @return ctargemaCA [PREC]\\n     * @return pACtps array of all AC prices for each TP, with [PREC]\\n     */\\n    function _updateEmasAndCalcCtargemaCA() internal returns (uint256 ctargemaCA, uint256[] memory pACtps) {\\n        // Make sure EMAs are up to date for all the pegs, in the, unlikely, scenario they hadn't been updated already\\n        updateEmas();\\n        return _calcCtargemaCA();\\n    }\\n\\n    // ------- Public Functions -------\\n\\n    /**\\n     * @notice calculates target coverage adjusted by all Pegged Token's to Collateral Asset rate moving average\\n     * @dev qAC = nTP / pACtp\\n     *      ctargemaCA = \\u2211(ctargemaTP * qAC) / \\u2211(qAC)\\n     * @return ctargemaCA [PREC]\\n     */\\n    function calcCtargemaCA() external view returns (uint256 ctargemaCA) {\\n        (ctargemaCA, ) = _calcCtargemaCA();\\n    }\\n\\n    /**\\n     * @notice true if the necessary span has pass since last ema update\\n     */\\n    function shouldCalculateEma() public view returns (bool) {\\n        unchecked {\\n            return block.number >= nextEmaCalculation;\\n        }\\n    }\\n\\n    /**\\n     * @notice If time, calculates the EMA for all the Pegged Token prices.\\n     * @dev All price provider prices must be available, fails if not\\n     */\\n    function updateEmas() public {\\n        if (shouldCalculateEma()) {\\n            uint256 pegAmount = pegContainer.length;\\n            for (uint256 i = 0; i < pegAmount; i = unchecked_inc(i)) {\\n                updateTPema(i);\\n            }\\n            _updateNextEmaCalculation(emaCalculationBlockSpan);\\n        }\\n    }\\n\\n    /**\\n     * @param blockSpan_ Defines how many blocks should pass between EMA calculations\\n     * @dev nextEmaCalculation is not automatically updated, you have to wait until next\\n     *  EMA calculation to be made : nextEmaCalculation = block.number + emaCalculationBlockSpan\\n     **/\\n    function setEmaCalculationBlockSpan(uint256 blockSpan_) external onlyAuthorizedChanger {\\n        emaCalculationBlockSpan = blockSpan_;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x7ca1141851bba2ee28342ae1aff2e90e8e482f936c20361b7325e0a7a31f15f6\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/governance/Governed.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IGovernor } from \\\"../interfaces/IGovernor.sol\\\";\\nimport { MocHelper } from \\\"../utils/MocHelper.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n  @title Governed\\n  @notice Base contract to be inherited by governed contracts\\n  @dev This contract is not usable on its own since it does not have any _productive useful_ behavior\\n  The only purpose of this contract is to define some useful modifiers and functions to be used on the\\n  governance aspect of the child contract\\n  */\\nabstract contract Governed is Initializable, MocHelper {\\n    /**\\n    @notice The address of the contract which governs this one\\n   */\\n    IGovernor public governor;\\n\\n    error NotAuthorizedChanger();\\n\\n    /**\\n    @notice Modifier that protects the function\\n    @dev You should use this modifier in any function that should be called through\\n    the governance system\\n   */\\n    modifier onlyAuthorizedChanger() {\\n        checkIfAuthorizedChanger();\\n        _;\\n    }\\n\\n    /**\\n    @notice Initialize the contract with the basic settings\\n    @dev This initialize replaces the constructor but it is not called automatically.\\n    It is necessary because of the upgradeability of the contracts\\n    @param governorAddress_ Governor address\\n   */\\n    function __Governed_init(address governorAddress_) internal onlyInitializing {\\n        __Governed_init_unchained(governorAddress_);\\n    }\\n\\n    function __Governed_init_unchained(address governorAddress_) internal onlyInitializing {\\n        governor = IGovernor(governorAddress_);\\n    }\\n\\n    /**\\n    @notice Change the contract's governor. Should be called through the old governance system\\n    @param newGovernor_ New governor address\\n   */\\n    function changeGovernor(IGovernor newGovernor_) external onlyAuthorizedChanger {\\n        governor = newGovernor_;\\n    }\\n\\n    /**\\n    @notice Checks if the msg sender is an authorized changer, reverts otherwise\\n   */\\n    function checkIfAuthorizedChanger() internal view {\\n        if (!governor.isAuthorizedChanger(msg.sender)) revert NotAuthorizedChanger();\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x4ca00d6d57ffff0ee43e4441d1bafa20c4e3f52e43e50b08cf68d7f65540e09a\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/governance/MocUpgradable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { Stoppable } from \\\"../governance/Stoppable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n// Import to allow compilation and deploy of ERC1967Proxy\\nimport { ERC1967Proxy } from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\n\\nabstract contract MocUpgradable is UUPSUpgradeable, Stoppable {\\n    // ------- Initializer -------\\n    /**\\n     * @notice contract initializer\\n     * @param governorAddress_ The address that will define when a change contract is authorized\\n     * @param pauserAddress_ The address that is authorized to pause this contract\\n     */\\n    function __MocUpgradable_init(address governorAddress_, address pauserAddress_) internal onlyInitializing {\\n        __UUPSUpgradeable_init();\\n        __Governed_init(governorAddress_);\\n        __Stoppable_init_unchained(pauserAddress_, true);\\n    }\\n\\n    /**\\n     * @inheritdoc UUPSUpgradeable\\n     * @dev checks that the changer that will do the upgrade is currently authorized by governance to makes\\n     * changes within the system\\n     * @param newImplementation new implementation contract address(not used)\\n     */\\n    /* solhint-disable-next-line no-empty-blocks */\\n    function _authorizeUpgrade(address newImplementation) internal override onlyAuthorizedChanger {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xcfd79734ffdc0e9e294b7c27a56e65228a704d77b9b75881227765a314a29186\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/governance/Stoppable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { Governed } from \\\"./Governed.sol\\\";\\n\\n/**\\n * @title Stoppable\\n * @notice Allow a contract to be paused through the stopper subsystem. This contracts\\n * is able to disable the stoppability feature through governance.\\n * @dev This contract was heavily based on the _Pausable_ contract of openzeppelin-eth but\\n * it was modified in order to being able to turn on and off its stoppability\\n */\\ncontract Stoppable is Governed {\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    bool public stoppable;\\n    bool private _paused;\\n    address public pauser;\\n\\n    // ------- Custom Errors -------\\n    error Unstoppable();\\n    error OnlyWhilePaused();\\n    error NotWhenPaused();\\n    error OnlyPauser();\\n\\n    /**\\n     * @notice Modifier to make a function callable only when the contract is not paused\\n     */\\n    modifier notPaused() {\\n        _checkNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier to make a function callable only when the contract is paused\\n     */\\n    modifier onlyPaused() {\\n        if (!_paused) revert OnlyWhilePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initialize the contract with the basic settings\\n     * @dev This initialize replaces the constructor but it is not called automatically.\\n     * It is necessary because of the upgradeability of the contracts. Either this function or the previous can be used\\n     * @param pauserAddress_ The address that is authorized to pause this contract\\n     * @param stoppable_ Define if the contract starts being unstoppable or not\\n     */\\n    function __Stoppable_init_unchained(address pauserAddress_, bool stoppable_) internal onlyInitializing {\\n        stoppable = stoppable_;\\n        pauser = pauserAddress_;\\n    }\\n\\n    /**\\n     * @dev reverts with NotWhenPaused when _paused\\n     */\\n    function _checkNotPaused() internal view {\\n        if (_paused) revert NotWhenPaused();\\n    }\\n\\n    /**\\n     * @notice Returns true if paused\\n     */\\n    function paused() external view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @notice Called by the owner to pause, triggers stopped state\\n     * @dev Should only be called by the pauser and when it is stoppable\\n     */\\n    function pause() external notPaused {\\n        if (msg.sender != pauser) revert OnlyPauser();\\n        if (!stoppable) revert Unstoppable();\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Called by the owner to unpause, returns to normal state\\n     */\\n    function unpause() external onlyPaused {\\n        if (msg.sender != pauser) revert OnlyPauser();\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Switches OFF the stoppability of the contract; if the contract was paused\\n     * it will no longer be so\\n     * @dev Should be called through governance\\n     */\\n    function makeUnstoppable() external onlyAuthorizedChanger {\\n        stoppable = false;\\n    }\\n\\n    /**\\n     * @notice Switches ON the stoppability of the contract; if the contract was paused\\n     * before making it unstoppable it will be paused again after calling this function\\n     * @dev Should be called through governance\\n     */\\n    function makeStoppable() external onlyAuthorizedChanger {\\n        stoppable = true;\\n    }\\n\\n    /**\\n     * @notice Changes the address which is enable to pause this contract\\n     * @param newPauser_ Address of the new pauser\\n     * @dev Should be called through governance\\n     */\\n    function setPauser(address newPauser_) external onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        pauser = newPauser_;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x535935f16a10f894197c692692649ac42c764018c981f1651bf1d59dc3bb32d5\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/interfaces/IChangeContract.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\n/**\\n  @title IChangeContract\\n  @notice This interface is the one used by the governance system.\\n  @dev If you plan to do some changes to a system governed by this project you should write a contract\\n  that does those changes, like a recipe. This contract MUST not have ANY kind of public or external function\\n  that modifies the state of this ChangeContract, otherwise you could run into front-running issues when the governance\\n  system is fully in place.\\n */\\ninterface IChangeContract {\\n    /**\\n    @notice Override this function with a recipe of the changes to be done when this ChangeContract\\n    is executed\\n   */\\n    function execute() external;\\n}\\n\",\"keccak256\":\"0x22e20ac9596a6a4c4545b0c5cf307c2924987d6033ef75357850b0de4d1f0901\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/interfaces/IDataProvider.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\n/**\\n * @title IDataProvider\\n * @notice Amphiraos-Oracle Interface for peeking the data from an oracle\\n * @dev https://github.com/money-on-chain/Amphiraos-Oracle\\n */\\ninterface IDataProvider {\\n    /**\\n     * @notice returns the given `data` if `valid`\\n     * @param data peeked\\n     * @param valid true if the data is valid\\n     */\\n    function peek() external view returns (bytes32 data, bool valid);\\n}\\n\",\"keccak256\":\"0xa24e4a8fe86fd41e5da606a361b504a20d97b579c5d620221442dd080e2ba39b\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/interfaces/IGovernor.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IChangeContract } from \\\"./IChangeContract.sol\\\";\\n\\n/**\\n  @title IGovernor\\n  @notice Governor interface. This functions should be overwritten to\\n  enable the communication with the rest of the system\\n  @dev This interface **MUST** be compatible with the corresponding Governance instance\\n  used on Production, from https://github.com/money-on-chain/Areopagus-Governance\\n  */\\ninterface IGovernor {\\n    /**\\n    @notice Function to be called to make the changes described in changeContract\\n    @dev This function should be protected somehow to only execute changes that\\n    benefit the system. This decision process is independent of this architecture\\n    therefore is independent of this interface too\\n    @param changeContract_ Address of the contract that will execute the changes\\n   */\\n    function executeChange(IChangeContract changeContract_) external;\\n\\n    /**\\n    @notice Returns whether this `changer_` is authorized to execute changes.\\n    @param changer_ Address of the contract that will execute the changes\\n   */\\n    function isAuthorizedChanger(address changer_) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0f8cd9de3ed9348e6a58cf4d971586f60f5542a20ecd3748194e4ba288f419c1\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/interfaces/IMocRC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @title IMocRC20\\n * @notice Base Moc ERC20 Token Interface: burn, mint. It can be both Pegs and Collateral Tokens.\\n */\\ninterface IMocRC20 is IERC20Upgradeable {\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     * See {ERC20-_mint}.\\n     */\\n    function mint(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Burns a specific `amount` of tokens for `to`.\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(address to, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x59d458617a8daf761e2f0ff84a367b32b4eacabfb8340e244f52bc168cb8a16a\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/interfaces/IPriceProvider.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\n/**\\n * @title IPriceFeed\\n * @notice Amphiraos-Oracle Interface for peeking the price of a given asset\\n * @dev https://github.com/money-on-chain/Amphiraos-Oracle\\n */\\ninterface IPriceProvider {\\n    /**\\n     * @notice returns the given `price` for the asset if `valid`\\n     * @param price assetPrice\\n     * @param valid true if the price is valid\\n     */\\n    function peek() external view returns (bytes32 price, bool valid);\\n}\\n\",\"keccak256\":\"0xf91d285e24227b0c2f0c187d610d63e33a4fc9c1e193e0ced8df131eac440b23\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/queue/MocQueue.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocQueueExecFees } from \\\"./MocQueueExecFees.sol\\\";\\nimport { MocCore, MocCommons } from \\\"../core/MocCore.sol\\\";\\nimport { MocBaseBucket } from \\\"../core/MocBaseBucket.sol\\\";\\nimport { MocCARC20Deferred } from \\\"../collateral/rc20/MocCARC20Deferred.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n/* solhint-disable-next-line max-line-length */\\nimport { ReentrancyGuardUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nbytes32 constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\nbytes32 constant ENQUEUER_ROLE = keccak256(\\\"ENQUEUER_ROLE\\\");\\n\\n/**\\n * @title MocQueue: Allows queue Operation deferral execution processing\\n */\\ncontract MocQueue is MocQueueExecFees, ReentrancyGuardUpgradeable {\\n    // ------- Custom Errors -------\\n\\n    // Wrong amount of coinbase set as execution fee\\n    error BucketAlreadyRegistered();\\n\\n    // ------- Events -------\\n    event OperationError(uint256 operId_, bytes4 errorCode_, string msg_);\\n    event UnhandledError(uint256 operId_, bytes reason_);\\n\\n    event OperationQueued(address indexed bucket_, uint256 operId_, OperType operType_);\\n    event OperationExecuted(address indexed executor, uint256 indexed operId_);\\n\\n    event TCMinted(\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTC_,\\n        uint256 qAC_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TCRedeemed(\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTC_,\\n        uint256 qAC_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TPMinted(\\n        address indexed tp,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTP_,\\n        uint256 qAC_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TPRedeemed(\\n        address indexed tp_,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTP_,\\n        uint256 qAC_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TCandTPRedeemed(\\n        address indexed tp_,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 qAC_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TCandTPMinted(\\n        address indexed tp_,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 qAC_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TPSwappedForTP(\\n        address indexed tpFrom_,\\n        address tpTo_,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTPfrom_,\\n        uint256 qTPto_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TPSwappedForTC(\\n        address indexed tp_,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTP_,\\n        uint256 qTC_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n    event TCSwappedForTP(\\n        address indexed tp_,\\n        address indexed sender_,\\n        address indexed recipient_,\\n        uint256 qTC_,\\n        uint256 qTP_,\\n        uint256 qACfee_,\\n        uint256 qFeeToken_,\\n        uint256 qACVendorMarkup_,\\n        uint256 qFeeTokenVendorMarkup_,\\n        address vendor_,\\n        uint256 operId_\\n    );\\n\\n    // ------- Structs -------\\n    struct OperInfo {\\n        // Operation Type\\n        OperType operType;\\n        // block number on which the Operation was queued\\n        uint248 queuedBlk;\\n    }\\n\\n    // ------- Storage -------\\n\\n    // mocCore bucket that would be able to queue\\n    MocCARC20Deferred public mocCore;\\n\\n    // Amount of Operations created\\n    uint256 public operIdCount;\\n    // first operation to be executed\\n    uint256 public firstOperId;\\n\\n    mapping(uint256 => MocCore.MintTCParams) public operationsMintTC;\\n    mapping(uint256 => MocCore.MintTPParams) public operationsMintTP;\\n    mapping(uint256 => MocCore.RedeemTCParams) public operationsRedeemTC;\\n    mapping(uint256 => MocCore.RedeemTPParams) public operationsRedeemTP;\\n    mapping(uint256 => MocCore.MintTCandTPParams) public operationsMintTCandTP;\\n    mapping(uint256 => MocCore.RedeemTCandTPParams) public operationsRedeemTCandTP;\\n    mapping(uint256 => MocCore.SwapTCforTPParams) public operationsSwapTCforTP;\\n    mapping(uint256 => MocCore.SwapTPforTCParams) public operationsSwapTPforTC;\\n    mapping(uint256 => MocCore.SwapTPforTPParams) public operationsSwapTPforTP;\\n\\n    // Set of Deferrable Operation Types\\n    enum OperType {\\n        none, // avoid using zero as Type\\n        mintTC,\\n        redeemTC,\\n        mintTP,\\n        redeemTP,\\n        mintTCandTP,\\n        redeemTCandTP,\\n        swapTCforTP,\\n        swapTPforTC,\\n        swapTPforTP\\n    }\\n\\n    // OperId => Operation Type | block.number\\n    mapping(uint256 => OperInfo) public opersInfo;\\n\\n    // min amount of blocks the Operation should wait in the Queue before execution\\n    uint128 public minOperWaitingBlk;\\n\\n    // max amount of Operations that can be executed on a single batch,\\n    // gas restricted batch size to guarantee no gas limit failure\\n    uint128 public maxOperPerBatch;\\n\\n    // ------- Initializer -------\\n\\n    function initialize(\\n        address governor_,\\n        address pauser_,\\n        uint128 minOperWaitingBlk_,\\n        uint128 maxOperPerBatch_,\\n        InitializeMocQueueExecFeesParams calldata mocQueueExecFeesParams_\\n    ) external initializer {\\n        __AccessControl_init();\\n        __MocUpgradable_init(governor_, pauser_);\\n        __MocQueueExecFees_init(mocQueueExecFeesParams_);\\n        __ReentrancyGuard_init();\\n        minOperWaitingBlk = minOperWaitingBlk_;\\n        maxOperPerBatch = maxOperPerBatch_;\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * @notice hook after mintedTC Operation execution, emits the TCMinted event\\n     * @param operId_ Identifier to track the Operation lifecycle\\n     * @param params_ TCMint params\\n     * @param qACtotalNeeded_ amount of AC used to mint qTC\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTCMinted(\\n        uint256 operId_,\\n        MocCore.MintTCParams memory params_,\\n        uint256 qACtotalNeeded_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TCMinted(\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTC,\\n            qACtotalNeeded_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice hook after redeemTC Operation execution, emits the TCRedeemed event\\n     * @param operId_ Identifier to track the Operation lifecycle\\n     * @param params_ mintTCto function params\\n     * @param qACRedeemed_ amount of AC redeemed\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTCRedeemed(\\n        uint256 operId_,\\n        MocCore.RedeemTCParams memory params_,\\n        uint256 qACRedeemed_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TCRedeemed(\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTC,\\n            qACRedeemed_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice hook after mintTP Operation is executed, emits the TPMinted event\\n     * @param operId_ Identifier to track the Operation lifecycle\\n     * @param params_ mintTP functions params\\n     * @param qACtotalNeeded_ amount of AC needed to mint qTP\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTPMinted(\\n        uint256 operId_,\\n        MocCore.MintTPParams memory params_,\\n        uint256 qACtotalNeeded_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TPMinted(\\n            params_.tp,\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTP,\\n            qACtotalNeeded_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook after the TP is redeemed, with operation information result\\n     * @param operId_ operation id\\n     * @param params_ redeemTPto function params\\n     * @param qACRedeemed_ amount of AC redeemed\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTPRedeemed(\\n        uint256 operId_,\\n        MocCore.RedeemTPParams memory params_,\\n        uint256 qACRedeemed_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TPRedeemed(\\n            params_.tp,\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTP,\\n            qACRedeemed_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook after the TC and TP are minted, with operation information result\\n     * @param operId_ operation id\\n     * @param params_ mintTCandTPto function params\\n     * @param qTCMinted_ amount of qTC minted for the given qTP\\n     * @param qACtotalNeeded_ total amount of AC needed to mint qTC and qTP\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTCandTPMinted(\\n        uint256 operId_,\\n        MocCore.MintTCandTPParams memory params_,\\n        uint256 qTCMinted_,\\n        uint256 qACtotalNeeded_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TCandTPMinted(\\n            params_.tp,\\n            params_.sender,\\n            params_.recipient,\\n            qTCMinted_,\\n            params_.qTP,\\n            qACtotalNeeded_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook after the TC and TP are redeemed, with operation information result\\n     * @param operId_ operation id\\n     * @param params_ redeemTCandTPto function params\\n     * @param qTPRedeemed_ total amount of TP redeemed\\n     * @param qACRedeemed_ total amount of AC redeemed\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTCandTPRedeemed(\\n        uint256 operId_,\\n        MocCore.RedeemTCandTPParams memory params_,\\n        uint256 qTPRedeemed_,\\n        uint256 qACRedeemed_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TCandTPRedeemed(\\n            params_.tp,\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTC,\\n            qTPRedeemed_,\\n            qACRedeemed_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook after the TC is swapped for TP, with operation information result\\n     * @param operId_ operation id\\n     * @param params_ swapTCforTP function params\\n     * @param qTPMinted_ total amount of TP swapped\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTCforTPSwapped(\\n        uint256 operId_,\\n        MocCore.SwapTCforTPParams memory params_,\\n        uint256 qTPMinted_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TCSwappedForTP(\\n            params_.tp,\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTC,\\n            qTPMinted_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook after the TP is swapped for TC, with operation information result\\n     * @param operId_ operation id\\n     * @param params_ swapTPforTC function params\\n     * @param qTCMinted_ total amount of TC minted\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTPforTCSwapped(\\n        uint256 operId_,\\n        MocCore.SwapTPforTCParams memory params_,\\n        uint256 qTCMinted_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TPSwappedForTC(\\n            params_.tp,\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTP,\\n            qTCMinted_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice Hook after the TP is swapped for another TP, with operation information result\\n     * @param operId_ operation id\\n     * @param params_ swapTPforTP function params\\n     * @param qTPMinted_ total amount of TP `iTo` minted\\n     * @param feeCalcs_ platform fee detail breakdown\\n     */\\n    function _onDeferredTPforTPSwapped(\\n        uint256 operId_,\\n        MocCore.SwapTPforTPParams memory params_,\\n        uint256 qTPMinted_,\\n        MocCore.FeeCalcs memory feeCalcs_\\n    ) internal {\\n        emit TPSwappedForTP(\\n            params_.tpFrom,\\n            params_.tpTo,\\n            params_.sender,\\n            params_.recipient,\\n            params_.qTP,\\n            qTPMinted_,\\n            feeCalcs_.qACFee,\\n            feeCalcs_.qFeeToken,\\n            feeCalcs_.qACVendorMarkup,\\n            feeCalcs_.qFeeTokenVendorMarkup,\\n            params_.vendor,\\n            operId_\\n        );\\n    }\\n\\n    /**\\n     * @notice Executes mint TC handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TCMinted, OperationError, UnhandledError} events\\n     */\\n    function _executeMintTC(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.MintTCParams memory params = operationsMintTC[operId_];\\n        try mocCore.execMintTC(params) returns (uint256 _qACtotalNeeded, uint256, MocCore.FeeCalcs memory _feeCalcs) {\\n            _onDeferredTCMinted(operId_, params, _qACtotalNeeded, _feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.InsufficientQacSent.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient qac sent\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockACInPending(params.sender, params.qACmax);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsMintTC[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes redeem TC handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TCRedeemed, OperationError, UnhandledError} events\\n     */\\n    function _executeRedeemTC(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.RedeemTCParams memory params = operationsRedeemTC[operId_];\\n        try mocCore.execRedeemTC(params) returns (uint256 _qACRedeemed, uint256, MocCore.FeeCalcs memory _feeCalcs) {\\n            _onDeferredTCRedeemed(operId_, params, _qACRedeemed, _feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.InsufficientTCtoRedeem.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient tc to redeem\\\");\\n            } else if (errorSelector == MocCommons.QacBelowMinimumRequired.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"qAC below minimum required\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockTCInPending(params.sender, params.qTC);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsRedeemTC[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes mint TP handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TPMinted, OperationError, UnhandledError} events\\n     */\\n    function _executeMintTP(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.MintTPParams memory params = operationsMintTP[operId_];\\n        try mocCore.execMintTP(params) returns (uint256 _qACtotalNeeded, uint256, MocCore.FeeCalcs memory _feeCalcs) {\\n            _onDeferredTPMinted(operId_, params, _qACtotalNeeded, _feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.MaxFluxCapacitorOperationReached.selector) {\\n                // this error is handled to stop the batch execution, so the operation can be executed again\\n                // after blocks pass and the flux capacitor is free again\\n                emit OperationError(operId_, errorSelector, \\\"Max flux capacitor operation reached\\\");\\n                return false;\\n            } else if (errorSelector == MocCommons.InsufficientTPtoMint.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient tp to mint\\\");\\n            } else if (errorSelector == MocCommons.InsufficientQacSent.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient qac sent\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockACInPending(params.sender, params.qACmax);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsMintTP[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes redeem TP handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TPRedeemed, OperationError, UnhandledError} events\\n     */\\n    function _executeRedeemTP(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.RedeemTPParams memory params = operationsRedeemTP[operId_];\\n        try mocCore.execRedeemTP(params) returns (uint256 _qACRedeemed, uint256, MocCore.FeeCalcs memory _feeCalcs) {\\n            _onDeferredTPRedeemed(operId_, params, _qACRedeemed, _feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.MaxFluxCapacitorOperationReached.selector) {\\n                // this error is handled to stop the batch execution, so the operation can be executed again\\n                // after blocks pass and the flux capacitor is free again\\n                emit OperationError(operId_, errorSelector, \\\"Max flux capacitor operation reached\\\");\\n                return false;\\n            } else if (errorSelector == MocCommons.QacBelowMinimumRequired.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"qAC below minimum required\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockTPInPending(params.sender, IERC20Upgradeable(params.tp), params.qTP);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsRedeemTP[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes mint TC and TP handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TCandTPMinted, OperationError, UnhandledError} events\\n     */\\n    function _executeMintTCandTP(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.MintTCandTPParams memory params = operationsMintTCandTP[operId_];\\n        try mocCore.execMintTCandTP(params) returns (\\n            uint256 _qACtotalNeeded,\\n            uint256 _qTcMinted,\\n            uint256,\\n            MocCore.FeeCalcs memory _feeCalcs\\n        ) {\\n            _onDeferredTCandTPMinted(operId_, params, _qTcMinted, _qACtotalNeeded, _feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.MaxFluxCapacitorOperationReached.selector) {\\n                // this error is handled to stop the batch execution, so the operation can be executed again\\n                // after blocks pass and the flux capacitor is free again\\n                emit OperationError(operId_, errorSelector, \\\"Max flux capacitor operation reached\\\");\\n                return false;\\n            } else if (errorSelector == MocCommons.InsufficientQacSent.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient qac sent\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockACInPending(params.sender, params.qACmax);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsMintTCandTP[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes redeem TC and TP handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TCandTPRedeemed, OperationError, UnhandledError} events\\n     */\\n    function _executeRedeemTCandTP(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.RedeemTCandTPParams memory params = operationsRedeemTCandTP[operId_];\\n        try mocCore.execRedeemTCandTP(params) returns (\\n            uint256 _qACRedeemed,\\n            uint256 _qTPRedeemed,\\n            uint256,\\n            MocCore.FeeCalcs memory _feeCalcs\\n        ) {\\n            _onDeferredTCandTPRedeemed(operId_, params, _qTPRedeemed, _qACRedeemed, _feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.MaxFluxCapacitorOperationReached.selector) {\\n                // this error is handled to stop the batch execution, so the operation can be executed again\\n                // after blocks pass and the flux capacitor is free again\\n                emit OperationError(operId_, errorSelector, \\\"Max flux capacitor operation reached\\\");\\n                return false;\\n            } else if (errorSelector == MocCommons.InsufficientQtpSent.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient tp sent\\\");\\n            } else if (errorSelector == MocCommons.QacBelowMinimumRequired.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"qAC below minimum required\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockTPInPending(params.sender, IERC20Upgradeable(params.tp), params.qTP);\\n            mocCore.unlockTCInPending(params.sender, params.qTC);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsRedeemTCandTP[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes swap TC for TP handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TCforTPSwapped, OperationError, UnhandledError} events\\n     */\\n    function _executeSwapTCforTP(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.SwapTCforTPParams memory params = operationsSwapTCforTP[operId_];\\n        try mocCore.execSwapTCforTP(params) returns (\\n            uint256,\\n            uint256 qTPMinted,\\n            uint256,\\n            MocCore.FeeCalcs memory feeCalcs\\n        ) {\\n            _onDeferredTCforTPSwapped(operId_, params, qTPMinted, feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.MaxFluxCapacitorOperationReached.selector) {\\n                // this error is handled to stop the batch execution, so the operation can be executed again\\n                // after blocks pass and the flux capacitor is free again\\n                emit OperationError(operId_, errorSelector, \\\"Max flux capacitor operation reached\\\");\\n                return false;\\n            } else if (errorSelector == MocCommons.InsufficientQacSent.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient qac sent\\\");\\n            } else if (errorSelector == MocCommons.QtpBelowMinimumRequired.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"qTp below minimum required\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockTCInPending(params.sender, params.qTC);\\n            mocCore.unlockACInPending(params.sender, params.qACmax);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsSwapTCforTP[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes swap TP for TC handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TPforTCSwapped, OperationError, UnhandledError} events\\n     */\\n    function _executeSwapTPforTC(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.SwapTPforTCParams memory params = operationsSwapTPforTC[operId_];\\n        try mocCore.execSwapTPforTC(params) returns (\\n            uint256,\\n            uint256 qTCMinted,\\n            uint256,\\n            MocCore.FeeCalcs memory feeCalcs\\n        ) {\\n            _onDeferredTPforTCSwapped(operId_, params, qTCMinted, feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.MaxFluxCapacitorOperationReached.selector) {\\n                // this error is handled to stop the batch execution, so the operation can be executed again\\n                // after blocks pass and the flux capacitor is free again\\n                emit OperationError(operId_, errorSelector, \\\"Max flux capacitor operation reached\\\");\\n                return false;\\n            } else if (errorSelector == MocCommons.InsufficientQacSent.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient qac sent\\\");\\n            } else if (errorSelector == MocCommons.QtcBelowMinimumRequired.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"qTc below minimum required\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockTPInPending(params.sender, IERC20Upgradeable(params.tp), params.qTP);\\n            mocCore.unlockACInPending(params.sender, params.qACmax);\\n        }\\n        // Independently from the result, we delete the operation params\\n        delete operationsSwapTPforTC[operId_];\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Executes swap TP for TP handling any error\\n     * @param operId_ operation id\\n     * @return executed true if the Operations was executed\\n     *\\n     * May emit {TPforTPSwapped, OperationError, UnhandledError} events\\n     */\\n    function _executeSwapTPforTP(uint256 operId_) internal virtual returns (bool executed) {\\n        MocCore.SwapTPforTPParams memory params = operationsSwapTPforTP[operId_];\\n        // Independently from the result, we delete the operation params\\n        delete operationsSwapTPforTP[operId_];\\n        try mocCore.execSwapTPforTP(params) returns (\\n            uint256,\\n            uint256 qTPMinted,\\n            uint256,\\n            MocCore.FeeCalcs memory feeCalcs\\n        ) {\\n            _onDeferredTPforTPSwapped(operId_, params, qTPMinted, feeCalcs);\\n        } catch (bytes memory returnData) {\\n            // TODO: analyze if it's necessary to decode error params, returnData needs to be\\n            // padded/shifted as decode only takes bytes32 chunks and error selector is just 4 bytes.\\n            bytes4 errorSelector = bytes4(returnData);\\n            if (errorSelector == MocCommons.InsufficientQacSent.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Insufficient qac sent\\\");\\n            } else if (errorSelector == MocCommons.QtpBelowMinimumRequired.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"qTp below minimum required\\\");\\n            } else if (errorSelector == MocBaseBucket.LowCoverage.selector) {\\n                emit OperationError(operId_, errorSelector, \\\"Low coverage\\\");\\n            } else emit UnhandledError(operId_, returnData);\\n\\n            // On a failed Operation, we unlock user funds\\n            mocCore.unlockTPInPending(params.sender, IERC20Upgradeable(params.tpFrom), params.qTP);\\n            mocCore.unlockACInPending(params.sender, params.qACmax);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice executes the given Operation by the `operId_`\\n     * @dev does not revert on Operation failure, throws Process and Error\\n     * events according to the Oper type and result\\n     * @param operId_ Identifier for the Operation to be executed\\n     * @return executed true if the Operations was executed\\n     * @return executionFee execution fees corresponding to this Operation\\n     */\\n    function execute(uint256 operId_, uint256 limitBlk) internal returns (bool executed, uint256 executionFee) {\\n        OperInfo memory operInfo = opersInfo[operId_];\\n        if (operInfo.queuedBlk > limitBlk) {\\n            executed = false;\\n            executionFee = 0;\\n        } else if (operInfo.operType == OperType.mintTC) {\\n            executed = _executeMintTC(operId_);\\n            executionFee = tcMintExecFee;\\n        } else if (operInfo.operType == OperType.redeemTC) {\\n            executed = _executeRedeemTC(operId_);\\n            executionFee = tcRedeemExecFee;\\n        } else if (operInfo.operType == OperType.mintTP) {\\n            executed = _executeMintTP(operId_);\\n            executionFee = tpMintExecFee;\\n        } else if (operInfo.operType == OperType.redeemTP) {\\n            executed = _executeRedeemTP(operId_);\\n            executionFee = tpRedeemExecFee;\\n        } else if (operInfo.operType == OperType.mintTCandTP) {\\n            executed = _executeMintTCandTP(operId_);\\n            executionFee = mintTCandTPExecFee;\\n        } else if (operInfo.operType == OperType.redeemTCandTP) {\\n            executed = _executeRedeemTCandTP(operId_);\\n            executionFee = redeemTCandTPExecFee;\\n        } else if (operInfo.operType == OperType.swapTCforTP) {\\n            executed = _executeSwapTCforTP(operId_);\\n            executionFee = swapTCforTPExecFee;\\n        } else if (operInfo.operType == OperType.swapTPforTC) {\\n            executed = _executeSwapTPforTC(operId_);\\n            executionFee = swapTPforTCExecFee;\\n        } else if (operInfo.operType == OperType.swapTPforTP) {\\n            executed = _executeSwapTPforTP(operId_);\\n            executionFee = swapTPforTPExecFee;\\n        }\\n        if (executed) delete opersInfo[operId_];\\n        return (executed, executionFee);\\n    }\\n\\n    // ------- External Functions -------\\n\\n    /**\\n     * @notice registered executors can process Operations in the queue\\n     * @dev does not revert on Operation failure, throws Process and Error\\n     * events according to the Oper type and result\\n     */\\n    function execute(address executionFeeRecipient) external notPaused nonReentrant onlyRole(EXECUTOR_ROLE) {\\n        uint256 operId = firstOperId;\\n        uint256 lastOperId;\\n        uint256 limitBlk;\\n        uint256 totalExecutionFee;\\n        unchecked {\\n            lastOperId = Math.min(operIdCount, operId + maxOperPerBatch);\\n            limitBlk = block.number - minOperWaitingBlk;\\n        }\\n        // loop through all pending Operations\\n        while (operId < lastOperId) {\\n            (bool executed, uint256 executionFee) = execute(operId, limitBlk);\\n            if (executed) {\\n                emit OperationExecuted(msg.sender, operId);\\n                operId = unchecked_inc(operId);\\n                unchecked {\\n                    totalExecutionFee += executionFee;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        // Define new reference to queue beginning\\n        firstOperId = operId;\\n        if (totalExecutionFee > 0) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = executionFeeRecipient.call{ value: totalExecutionFee }(\\\"\\\");\\n            if (!success) revert ExecutionFeePaymentFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueMintTC(\\n        MocCore.MintTCParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(tcMintExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.mintTC, uint248(block.number));\\n        operationsMintTC[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.mintTC);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueRedeemTC(\\n        MocCore.RedeemTCParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(tcRedeemExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.redeemTC, uint248(block.number));\\n        operationsRedeemTC[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.redeemTC);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueMintTP(\\n        MocCore.MintTPParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(tpMintExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.mintTP, uint248(block.number));\\n        operationsMintTP[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.mintTP);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice Registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueRedeemTP(\\n        MocCore.RedeemTPParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(tpRedeemExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.redeemTP, uint248(block.number));\\n        operationsRedeemTP[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.redeemTP);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice Registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueMintTCandTP(\\n        MocCore.MintTCandTPParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(mintTCandTPExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.mintTCandTP, uint248(block.number));\\n        operationsMintTCandTP[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.mintTCandTP);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice Registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueRedeemTCandTP(\\n        MocCore.RedeemTCandTPParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(redeemTCandTPExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.redeemTCandTP, uint248(block.number));\\n        operationsRedeemTCandTP[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.redeemTCandTP);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice Registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueSwapTCforTP(\\n        MocCore.SwapTCforTPParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(swapTCforTPExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.swapTCforTP, uint248(block.number));\\n        operationsSwapTCforTP[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.swapTCforTP);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice Registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueSwapTPforTC(\\n        MocCore.SwapTPforTCParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(swapTPforTCExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.swapTPforTC, uint248(block.number));\\n        operationsSwapTPforTC[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.swapTPforTC);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice Registered enqueuer can queue an Operations\\n     * @return operId Identifier to track the Operation lifecycle\\n     */\\n    function queueSwapTPforTP(\\n        MocCore.SwapTPforTPParams calldata params\\n    ) external payable notPaused onlyRole(ENQUEUER_ROLE) returns (uint256 operId) {\\n        verifyExecFee(swapTPforTPExecFee);\\n        operId = operIdCount;\\n        opersInfo[operId] = OperInfo(OperType.swapTPforTP, uint248(block.number));\\n        operationsSwapTPforTP[operId] = params;\\n        emit OperationQueued(msg.sender, operId, OperType.swapTPforTP);\\n        operIdCount++;\\n    }\\n\\n    /**\\n     * @notice true if the queue is empty\\n     */\\n    function isEmpty() public view override returns (bool) {\\n        return firstOperId == operIdCount;\\n    }\\n\\n    /**\\n     * @notice true if the queue has at least one Operation ready to be executed\\n     */\\n    function readyToExecute() public view returns (bool) {\\n        if (isEmpty()) return false;\\n        OperInfo memory operInfo = opersInfo[firstOperId];\\n        return (operInfo.queuedBlk <= block.number - minOperWaitingBlk);\\n    }\\n\\n    // ------- Only Authorized Changer Functions -------\\n\\n    /**\\n     * @notice sets Moc Queue minimum operation waiting blocks\\n     * @param minOperWaitingBlk_ minimum amount of blocks an operation needs to remain in the\\n     * queue before it can be executed\\n     */\\n    function setMinOperWaitingBlk(uint128 minOperWaitingBlk_) external onlyAuthorizedChanger {\\n        minOperWaitingBlk = minOperWaitingBlk_;\\n    }\\n\\n    /**\\n     * @notice sets Moc Queue maximum amount of operations per execution batch\\n     * @param maxOperPerBatch_ maximum amount of operations allowed on a batch to avoid going over\\n     * the block gas limit\\n     */\\n    function setMaxOperPerBatch(uint128 maxOperPerBatch_) external onlyAuthorizedChanger {\\n        maxOperPerBatch = maxOperPerBatch_;\\n    }\\n\\n    /**\\n     * @notice registers the mocCore bucket that would operate over this queue\\n     * @dev in order to operate, the queue needs to be whitelisted as EXECUTOR on the bucket as well\\n     * @param bucket_ address of the mocCore implementation to interact with\\n     *\\n     * May emit a {RoleGranted} event for ENQUEUER role\\n     */\\n    function registerBucket(MocCARC20Deferred bucket_) external onlyAuthorizedChanger {\\n        if (address(mocCore) != address(0)) revert BucketAlreadyRegistered();\\n        mocCore = bucket_;\\n        // internal, not role restricted granting, as it's protected by governance\\n        _grantRole(ENQUEUER_ROLE, address(bucket_));\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xd08d3224412ae1a9131fb75de20921ff02a50e83fdacdef207327241041f70c5\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/queue/MocQueueExecFees.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocAccessControlled } from \\\"../utils/MocAccessControlled.sol\\\";\\n\\n/**\\n * @title MocQueue Execution Fee: Handles Queuing execution fees\\n */\\nabstract contract MocQueueExecFees is MocAccessControlled {\\n    // ------- Custom Errors -------\\n\\n    // Wrong amount of coinbase set as execution fee\\n    error WrongExecutionFee(uint256 expectedValue);\\n    // Failure on Executor payment address coinbase transfer\\n    error ExecutionFeePaymentFailed();\\n    // Action not allow when queue is not empty\\n    error NotAllowOnNoneEmptyQueue();\\n\\n    // ------- Structs -------\\n\\n    struct InitializeMocQueueExecFeesParams {\\n        // absolute coinbase execution fee applied on Collateral Tokens mint\\n        uint256 tcMintExecFee;\\n        // absolute coinbase execution fee applied on Collateral Tokens redeem\\n        uint256 tcRedeemExecFee;\\n        // absolute coinbase execution fee applied on Pegged Tokens mint\\n        uint256 tpMintExecFee;\\n        // absolute coinbase execution fee applied on Pegged Tokens redeem\\n        uint256 tpRedeemExecFee;\\n        // absolute coinbase execution fee applied on swap a Pegged Token for another Pegged Token\\n        uint256 swapTPforTPExecFee;\\n        // absolute coinbase execution fee applied on swap a Pegged Token for Collateral Token\\n        uint256 swapTPforTCExecFee;\\n        // absolute coinbase execution fee applied on swap Collateral Token for a Pegged Token\\n        uint256 swapTCforTPExecFee;\\n        // absolute coinbase execution fee applied on redeem Collateral Token and Pegged Token in one operations\\n        uint256 redeemTCandTPExecFee;\\n        // absolute coinbase execution fee applied on mint Collateral Token and Pegged Token in one operation\\n        uint256 mintTCandTPExecFee;\\n    }\\n\\n    // absolute coinbase execution fee applied on Collateral Tokens mint\\n    uint256 public tcMintExecFee;\\n    // absolute coinbase execution fee applied on Collateral Tokens redeem\\n    uint256 public tcRedeemExecFee;\\n    // absolute coinbase execution fee applied on Pegged Tokens mint\\n    uint256 public tpMintExecFee;\\n    // absolute coinbase execution fee applied on Pegged Tokens redeem\\n    uint256 public tpRedeemExecFee;\\n    // absolute coinbase execution fee applied on swap a Pegged Token for another Pegged Token\\n    uint256 public swapTPforTPExecFee;\\n    // absolute coinbase execution fee applied on swap a Pegged Token for Collateral Token\\n    uint256 public swapTPforTCExecFee;\\n    // absolute coinbase execution fee applied on swap Collateral Token for a Pegged Token\\n    uint256 public swapTCforTPExecFee;\\n    // absolute coinbase execution fee applied on redeem Collateral Token and Pegged Token in one operations\\n    uint256 public redeemTCandTPExecFee;\\n    // absolute coinbase execution fee applied on mint Collateral Token and Pegged Token in one operation\\n    uint256 public mintTCandTPExecFee;\\n\\n    // ------- Initializer -------\\n\\n    function __MocQueueExecFees_init(\\n        InitializeMocQueueExecFeesParams calldata mocQueueExecFeesParams_\\n    ) internal onlyInitializing {\\n        _setExecutionFees(mocQueueExecFeesParams_);\\n    }\\n\\n    // ------- Abstract Functions -------\\n\\n    /**\\n     * @notice true if the queue is empty\\n     */\\n    function isEmpty() public view virtual returns (bool isEmpty);\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * @notice verifies that operation execution fee sent (msg.value) is equal to `operationFee`\\n     * reverts, with WrongExecutionFee error is not.\\n     */\\n    function verifyExecFee(uint256 operationFee) internal {\\n        if (operationFee != msg.value) revert WrongExecutionFee(operationFee);\\n    }\\n\\n    /**\\n     * @notice sets Execution Fees absolute values for each operation type\\n     */\\n    function _setExecutionFees(InitializeMocQueueExecFeesParams calldata mocQueueExecFeesParams_) internal {\\n        tcMintExecFee = mocQueueExecFeesParams_.tcMintExecFee;\\n        tcRedeemExecFee = mocQueueExecFeesParams_.tcRedeemExecFee;\\n        tpMintExecFee = mocQueueExecFeesParams_.tpMintExecFee;\\n        tpRedeemExecFee = mocQueueExecFeesParams_.tpRedeemExecFee;\\n        swapTPforTPExecFee = mocQueueExecFeesParams_.swapTPforTPExecFee;\\n        swapTPforTCExecFee = mocQueueExecFeesParams_.swapTPforTCExecFee;\\n        swapTCforTPExecFee = mocQueueExecFeesParams_.swapTCforTPExecFee;\\n        redeemTCandTPExecFee = mocQueueExecFeesParams_.redeemTCandTPExecFee;\\n        mintTCandTPExecFee = mocQueueExecFeesParams_.mintTCandTPExecFee;\\n    }\\n\\n    /**\\n     * @notice verifies if the queue is empty, reverts if not\\n     */\\n    function _verifyEmptyQueue() internal view {\\n        if (!isEmpty()) revert NotAllowOnNoneEmptyQueue();\\n    }\\n\\n    // ------- External Functions -------\\n\\n    // ------- Only Authorized Changer Functions -------\\n\\n    function updateExecutionFees(\\n        InitializeMocQueueExecFeesParams calldata mocQueueExecFeesParams_\\n    ) external onlyAuthorizedChanger {\\n        _verifyEmptyQueue();\\n        _setExecutionFees(mocQueueExecFeesParams_);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x4975e1318f574f0303052f6b16641dca31271738e0814c8406909a21a6a50197\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/tokens/MocRC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { IMocRC20 } from \\\"../interfaces/IMocRC20.sol\\\";\\nimport { IGovernor, Governed } from \\\"../governance/Governed.sol\\\";\\n/* solhint-disable-next-line max-line-length */\\nimport { AccessControlEnumerableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport { ERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\n/**\\n * @title MocRC20\\n * @notice Base Moc ERC20 Token: burn, mint. It can be both Pegs and Collateral Tokens.\\n * @dev ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.\\n */\\ncontract MocRC20 is IMocRC20, AccessControlEnumerableUpgradeable, ERC20Upgradeable, UUPSUpgradeable, Governed {\\n    bytes32 private constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 private constant BURNER_ROLE = keccak256(\\\"BURNER_ROLE\\\");\\n\\n    error NotUniqueRole(bytes32 role);\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * See {__MocRC20_init}.\\n     */\\n    function initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        address admin_,\\n        IGovernor governor_\\n    ) external virtual initializer {\\n        __MocRC20_init(name_, symbol_, admin_, governor_);\\n        _grantRole(MINTER_ROLE, admin_);\\n        _grantRole(BURNER_ROLE, admin_);\\n    }\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE` to `admin` address.\\n     *\\n     * See {ERC20_init}.\\n     */\\n    function __MocRC20_init(\\n        string memory name_,\\n        string memory symbol_,\\n        address admin_,\\n        IGovernor governor_\\n    ) internal onlyInitializing {\\n        __ERC20_init(name_, symbol_);\\n        __AccessControlEnumerable_init();\\n        __UUPSUpgradeable_init();\\n        __Governed_init(address(governor_));\\n        _grantRole(DEFAULT_ADMIN_ROLE, admin_);\\n    }\\n\\n    /**\\n     * @inheritdoc UUPSUpgradeable\\n     * @dev checks that the changer that will do the upgrade is currently authorized by governance to makes\\n     * changes within the system\\n     * @param newImplementation new implementation contract address(not used)\\n     */\\n    /* solhint-disable-next-line no-empty-blocks */\\n    function _authorizeUpgrade(address newImplementation) internal override onlyAuthorizedChanger {}\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 amount) external virtual onlyRole(MINTER_ROLE) returns (bool) {\\n        _mint(to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Burns a specific `amount` of tokens for `to`.\\n     * * See {ERC20-_burn}.\\n     * Requirements:\\n     *\\n     * - the caller must have the `BURNER_ROLE`.\\n     */\\n    function burn(address to, uint256 amount) external virtual onlyRole(BURNER_ROLE) {\\n        _burn(to, amount);\\n    }\\n\\n    /**\\n     * @dev Grants all `roles` to `account` while sender renounces to all ``role``\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     * - no one else must have any other role\\n     *\\n     * May emit a {RoleGranted x3, RoleRevoked x3} event.\\n     */\\n    function transferAllRoles(address account) public virtual onlyRole(getRoleAdmin(DEFAULT_ADMIN_ROLE)) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, account);\\n        _grantRole(MINTER_ROLE, account);\\n        _grantRole(BURNER_ROLE, account);\\n        _revokeRole(MINTER_ROLE, msg.sender);\\n        _revokeRole(BURNER_ROLE, msg.sender);\\n        _revokeRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        // One the new admin account has roles\\n        if (getRoleMemberCount(DEFAULT_ADMIN_ROLE) != 1) revert NotUniqueRole(DEFAULT_ADMIN_ROLE);\\n        if (getRoleMemberCount(MINTER_ROLE) != 1) revert NotUniqueRole(MINTER_ROLE);\\n        if (getRoleMemberCount(BURNER_ROLE) != 1) revert NotUniqueRole(BURNER_ROLE);\\n    }\\n}\\n\",\"keccak256\":\"0x5ae23d94f4a2cf84d0999a307d0d8b0031ba52f5f01ee31510051e961d952239\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/tokens/MocTC.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocRC20, IGovernor, IMocRC20 } from \\\"./MocRC20.sol\\\";\\n/* solhint-disable-next-line max-line-length */\\nimport { ERC20PausableUpgradeable, ERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\\\";\\n\\n/**\\n * @title MocTC\\n * @notice Base Moc  ERC20 Collateral Tokens: Allows burn, mint and pause.\\n * @dev ERC20 like token that allows roles allowed contracts to mint and burn (destroyed) any token.\\n */\\ncontract MocTC is MocRC20, ERC20PausableUpgradeable {\\n    bytes32 private constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @dev Grants `PAUSER_ROLE` to `admin` address.\\n     *\\n     * See {MocRC20-constructor}.\\n     */\\n    function initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        address admin_,\\n        IGovernor governor_\\n    ) external override initializer {\\n        __MocRC20_init(name_, symbol_, admin_, governor_);\\n        __ERC20Pausable_init();\\n    }\\n\\n    /**\\n     * @dev override only to satisfy compiler\\n     * @inheritdoc ERC20PausableUpgradeable\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\\n        ERC20PausableUpgradeable._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Pauses the contract.\\n     * See {ERC20PausableUpgradeable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() external virtual onlyRole(PAUSER_ROLE) {\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Grants all `roles` to `account` while sender renounces to all ``role``.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     * - no one else must have any other role\\n     *\\n     * May emit a {RoleGranted x4, RoleRevoked x4} event.\\n     */\\n    function transferAllRoles(address account) public override onlyRole(getRoleAdmin(DEFAULT_ADMIN_ROLE)) {\\n        _grantRole(PAUSER_ROLE, account);\\n        _revokeRole(PAUSER_ROLE, msg.sender);\\n        super.transferAllRoles(account);\\n        if (getRoleMemberCount(PAUSER_ROLE) != 1) revert NotUniqueRole(PAUSER_ROLE);\\n    }\\n}\\n\",\"keccak256\":\"0x9cf0f1716999076e7128bfb83af415eb99bfd43b785e6efc8015e45df6e1baf3\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/utils/MocAccessControlled.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocUpgradable } from \\\"../governance/MocUpgradable.sol\\\";\\nimport { AccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @title MocAccessControlled\\n * @notice Extends Moc Upgradable capabilities, with access control capabilities\\n * @dev grant and revoke functions are overwritten so that they are also\\n *      compatible with governance authorization mechanism.\\n */\\nabstract contract MocAccessControlled is MocUpgradable, AccessControlUpgradeable {\\n    // ------- Public Functions -------\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role  OR\\n     *   the caller must have be an authorized Governance changer.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override {\\n        verifyRoleManagementPrivilege(role);\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role  OR\\n     *   the caller must have be an authorized Governance changer.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override {\\n        verifyRoleManagementPrivilege(role);\\n        _revokeRole(role, account);\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    function verifyRoleManagementPrivilege(bytes32 role) private view {\\n        if (!governor.isAuthorizedChanger(msg.sender) && !hasRole(getRoleAdmin(role), msg.sender))\\n            revert NotAuthorizedChanger();\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x08d62ed029461b93adac423c101c4e56dbf6a628e4d02855c3c4040d1e5e2b4e\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/utils/MocHelper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n/* solhint-disable-next-line max-line-length */\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nabstract contract MocHelper {\\n    error InvalidAddress();\\n    error InvalidValue();\\n    // Constants may not be used in child contracts and that is fine as they are\\n    // not using any space in storage, so we disable the check\\n    // slither-disable-next-line unused-state\\n    uint256 internal constant PRECISION = 10 ** 18;\\n    // slither-disable-next-line unused-state\\n    uint256 internal constant ONE = 10 ** 18;\\n    // slither-disable-next-line unused-state\\n    uint256 internal constant UINT256_MAX = ~uint256(0);\\n\\n    // Saves gas\\n    // https://github.com/KadenZipfel/gas-optimizations/blob/main/gas-saving-patterns/unchecked-arithmetic.md\\n    function unchecked_inc(uint256 i) internal pure returns (uint256) {\\n        unchecked {\\n            return i + 1;\\n        }\\n    }\\n\\n    /**\\n     * @notice add precision and div two number\\n     * @param a_ numerator\\n     * @param b_ denominator\\n     * @return `a_` * PRECISION / `b_`\\n     */\\n    function _divPrec(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return (a_ * PRECISION) / b_;\\n    }\\n\\n    /**\\n     * @notice multiply two number and remove precision\\n     * @param a_ term 1\\n     * @param b_ term 2\\n     * @return `a_` * `b_` / PRECISION\\n     */\\n    function _mulPrec(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return (a_ * b_) / PRECISION;\\n    }\\n\\n    /**\\n     * @notice reverts if value if less than PRECISION ONE\\n     * @param value_ value to check [PREC]\\n     */\\n    function _checkLessThanOne(uint256 value_) internal pure {\\n        if (value_ > ONE) revert InvalidValue();\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x73fa805076c35c1e4db33e957ab681fb34637a9d3d99b1ae5edcf7fb43248c0b\",\"license\":\"UNLICENSED\"},\"moc-main/contracts/vendors/MocVendors.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport { MocUpgradable } from \\\"../governance/MocUpgradable.sol\\\";\\n\\n/**\\n * @title MocVendors\\n * @notice MocVendors allows a third-party to add a markup to all operations\\n *  A vendor can set a markup themselves or ask vendors guardian to do it on their behalf.\\n *  Considerations:\\n *  - Theres is not a markup limit or restriction\\n *  - The currency that the vendor receives is always the same that is used to pay fees(AC or Fee Token)\\n *  - A malicious vendor front running an operation increasing the markup is protected in some way\\n *      by the maximum (AC or Fee Token) that the user expect to spend(or de minimum that expect to receive)\\n */\\ncontract MocVendors is MocUpgradable {\\n    // ------- Events -------\\n    event VendorMarkupChanged(address indexed vendorAddress_, uint256 newMarkup_);\\n    // ------- Custom Errors -------\\n    error NotVendorsGuardian(address sender_);\\n\\n    // ------- Storage -------\\n\\n    // address authorized to change a vendor's markup\\n    address public vendorsGuardianAddress;\\n    // addition markup pct applied on each operation when operating through a vendor [PREC]\\n    mapping(address => uint256) public vendorMarkup; // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\\n\\n    // ------- Initializer -------\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice contract initializer\\n     * @param vendorsGuardianAddress_ The address authorized to change a vendor's markup\\n     * @param governorAddress_ The address that will define when a change contract is authorized\\n     * @param pauserAddress_ The address that is authorized to pause this contract\\n     */\\n    function initialize(\\n        address vendorsGuardianAddress_,\\n        address governorAddress_,\\n        address pauserAddress_\\n    ) external initializer {\\n        // slither-disable-next-line missing-zero-check\\n        vendorsGuardianAddress = vendorsGuardianAddress_;\\n        __MocUpgradable_init(governorAddress_, pauserAddress_);\\n    }\\n\\n    // ------- Internal Functions -------\\n\\n    /**\\n     * @notice sets a vendor markup\\n     * @param vendorAddress_ vendor address to change markup\\n     * @param newMarkup_ new markup applied to vendor [PREC]\\n     */\\n    function _setMarkup(address vendorAddress_, uint256 newMarkup_) internal {\\n        vendorMarkup[vendorAddress_] = newMarkup_;\\n        emit VendorMarkupChanged(vendorAddress_, newMarkup_);\\n    }\\n\\n    // ------- External Functions -------\\n\\n    /**\\n     * @notice vendor sets its own markup\\n     * @param newMarkup_ new markup applied to vendor [PREC]\\n     */\\n    function setMarkup(uint256 newMarkup_) external {\\n        _setMarkup(msg.sender, newMarkup_);\\n    }\\n\\n    /**\\n     * @notice guardian sets a vendor markup\\n     * @param vendorAddress_ vendor address to change markup\\n     * @param newMarkup_ new markup applied to vendor [PREC]\\n     */\\n    function setVendorMarkup(address vendorAddress_, uint256 newMarkup_) external {\\n        if (msg.sender != vendorsGuardianAddress) revert NotVendorsGuardian(msg.sender);\\n        _setMarkup(vendorAddress_, newMarkup_);\\n    }\\n\\n    // ------- Only Authorized Changer Functions -------\\n\\n    /**\\n     * @dev Sets the address which will be authorized to set a vendor markup.\\n     * @param vendorsGuardianAddress_ Address which will be authorized to set a vendor markup.\\n     */\\n    function setVendorsGuardianAddress(address vendorsGuardianAddress_) public onlyAuthorizedChanger {\\n        // slither-disable-next-line missing-zero-check\\n        vendorsGuardianAddress = vendorsGuardianAddress_;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n\\n    // Purposely left unused to save some state space to allow for future upgrades\\n    // slither-disable-next-line unused-state\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x2fd4ff4cf08ecabbd32b44f837c3d7f6f14b5512574abc23b4f35a12995d3ae9\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x60a080604052346100315730608052614b30908161003782396080518181816110ef0152818161125e01526122c00152f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c8062c6e88e1461275757806301ffc9a7146127015780630c340a24146126d85780631826ebf0146126745780631a0c544014612606578063248a9ca3146125d65780632b994849146125b75780632d88af4a146125625780632f2ff15d1461252957806334975a41146123bb57806336568abe146123275780633659cfe61461228e5780633bb4b05c1461224b5780633cbcf4c4146122265780633dc8797a146122075780633f4ba83a1461218d5780633fa9e0c61461216e578063435c7e37146120e457806347d8496a146120175780634981d04e14611fd45780634b64e492146112c15780634f1ef286146111d75780635210570c146111b257806352d1902d146110dc5780635c817aa3146110785780635c975abb146110525780635ee1d2bb1461100857806364d9e82114610fe9578063681fe70c14610fc55780636827435714610f9d5780636b59c22f14610ed05780636b76333014610e6c57806373e3d08614610e4d5780637656cd1014610e2e5780637c50b7e414610dea5780637e81a82114610d1d5780638456cb5914610c875780638a4737ab14610c285780638b20076c14610bc95780638e7e818914610ba157806391d1485414610b4e57806397ac81fb14610b2f5780639aac1c2a14610b105780639fd0506d14610ae3578063a217fddf14610ac7578063ad16c2de14610a59578063bb4872de14610a36578063bbe720d9146109c1578063c84d8bb6146108f4578063d17910e2146108d5578063d547741f1461089a578063d9a862d614610870578063db9014771461064f578063dbb0b6841461062d578063e4c0aaf4146105e7578063e4e1b7291461051a578063e97a4d631461044d578063eeab6f4b1461042e578063f2cee87a1461040f578063fa91a9a5146103225763fb8aafb8146102ba57600080fd5b3461031d57602036600319011261031d5760043560005261026a602052604060002060018060a01b03610319818354169160018401549360028101549180600383015416906005816004850154169301541692604051968796876128bb565b0390f35b600080fd5b60a036600319011261031d57610336612ec1565b61034d600080516020614adb833981519152612f42565b6103596101f854614950565b61026580546040519161036d604084612867565b60028352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026983526103c560046040600020614706565b604051828152600284820152600080516020614abb83398151915260403392a26103ef8154614779565b9055604051908152f35b634e487b7160e01b600052602160045260246000fd5b3461031d57600036600319011261031d5760206101fd54604051908152f35b3461031d57600036600319011261031d5760206101fb54604051908152f35b60a036600319011261031d57610461612ec1565b610478600080516020614adb833981519152612f42565b6104846101f754614950565b610265805460405191610498604084612867565b60018352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026783526104f060046040600020614706565b604051828152600184820152600080516020614abb83398151915260403392a26103ef8154614779565b60e036600319011261031d5761052e612ec1565b610545600080516020614adb833981519152612f42565b6105516101fe54614950565b610265805460405191610565604084612867565b60068352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026c83526105bd600460406000206147f3565b604051828152600684820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d576004356001600160a01b0381169081900361031d57610615612e3e565b6001600160601b0360a01b6097541617609755600080f35b3461031d57600036600319011261031d5760206102715460801c604051908152f35b3461031d576101a036600319011261031d576001600160a01b036004358181169081900361031d57602435918216820361031d576044356001600160801b039283821680920361031d57606435938416840361031d5761012036608319011261031d576000549260ff8460081c161593848095610863575b801561084c575b156107f05761076592600191868360ff198316176000556107de575b5060ff60005460081c16926106fe84612ee2565b61070784612ee2565b61071084612ee2565b61071984612ee2565b61072284612ee2565b6001600160601b0360a01b609754161760975561073e83612ee2565b60ca5490620100008360b01b039060101b169061ff018360b01b031916171760ca55612ee2565b61076f6084614972565b6000549261078b60ff8560081c1661078681612ee2565b612ee2565b60016102325560801b6001600160801b03191617610271556107a957005b61ff0019166000557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160018152a1005b61ffff191661010117600055876106ea565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b50303b1580156106ce5750600160ff8216146106ce565b50600160ff8216106106c7565b3461031d57600036600319011261031d57610264546040516001600160a01b039091168152602090f35b3461031d57604036600319011261031d576004356024356001600160a01b038116810361031d57816108ce6108d3936149c2565b6128f5565b005b3461031d57600036600319011261031d5760206101fa54604051908152f35b60c036600319011261031d57610908612ec1565b61091f600080516020614adb833981519152612f42565b61092b6101fa54614950565b61026580546040519161093f604084612867565b60048352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026a835261099760046040600020614788565b604051828152600484820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d576001600160a01b036004358181169081900361031d576109f0612e3e565b6102648054928316610a2457816108d3936001600160601b0360a01b16179055600080516020614adb8339815191526148ce565b604051630a646b7760e41b8152600490fd5b3461031d57600036600319011261031d57602060ff60ca54166040519015158152f35b3461031d57602036600319011261031d576004803560009081526102696020908152604091829020805460018201546002830154600384015493909601548551928352938201526001600160a01b03948516938101939093528316606083015291909116608082015260a090f35b3461031d57600036600319011261031d57602060405160008152f35b3461031d57600036600319011261031d5760ca5460405160109190911c6001600160a01b03168152602090f35b3461031d57600036600319011261031d5760206101f754604051908152f35b3461031d57600036600319011261031d5760206101f854604051908152f35b3461031d57604036600319011261031d576024356001600160a01b0381169081900361031d57600435600052610193602052604060002090600052602052602060ff604060002054166040519015158152f35b3461031d57600036600319011261031d5760206001600160801b036102715416604051908152f35b3461031d57602036600319011261031d5760043560005261026b602052604060002060018060a01b03610319818354169160018401549360028101549180600383015416906005816004850154169301541692604051968796876128bb565b3461031d57602036600319011261031d57600435600052610268602052604060002060018060a01b03610319818354169160018401549360028101549180600383015416906005816004850154169301541692604051968796876128bb565b3461031d57600036600319011261031d57610ca0612ec1565b60ca54601081901c6001600160a01b03163303610d0b5760ff811615610cf9576101009061ff0019161760ca557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b60405163866099c360e01b8152600490fd5b604051631d77d47760e21b8152600490fd5b60c036600319011261031d57610d31612ec1565b610d48600080516020614adb833981519152612f42565b610d546101f954614950565b610265805460405191610d68604084612867565b60038352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b169116179055816000526102688352610dc060046040600020614788565b604051828152600384820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d5760043560005261027060205260406000205460ff81169060405190600a8310156103f957604092825260081c6020820152f35b3461031d57600036600319011261031d5760206101fe54604051908152f35b3461031d57600036600319011261031d57602061026554604051908152f35b3461031d57602036600319011261031d5760043560005261026c602052604060002060018060a01b03610319818354169160018401549360028101549160038201548160048401541691600681600586015416940154169360405197889788612824565b60e036600319011261031d57610ee4612ec1565b610efb600080516020614adb833981519152612f42565b610f076101fd54614950565b610265805460405191610f1b604084612867565b60078352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026d8352610f73600460406000206147f3565b604051828152600784820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57600036600319011261031d57610fb6612e3e565b60ca805460ff19166001179055005b3461031d57600036600319011261031d576020610266546102655414604051908152f35b3461031d57600036600319011261031d5760206101fc54604051908152f35b3461031d57602036600319011261031d576001600160801b03600435818116810361031d57611035612e3e565b610271805490921660809190911b6001600160801b031916179055005b3461031d57600036600319011261031d57602060ff60ca5460081c166040519015158152f35b3461031d57602036600319011261031d5760043560005261026e602052604060002060018060a01b03610319818354169160018401549360028101549160038201548160048401541691600681600586015416940154169360405197889788612824565b3461031d57600036600319011261031d577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036111475760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b60405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c00000000000000006064820152608490fd5b3461031d57600036600319011261031d576111cb612e3e565b60ca805460ff19169055005b604036600319011261031d576001600160a01b03600435818116810361031d5760243567ffffffffffffffff811161031d573660238201121561031d578060040135916112238361289f565b916112316040519384612867565b838352366024858301011161031d576108d394600060208660019760246112b496018389013786010152807f0000000000000000000000000000000000000000000000000000000000000000169061128b82301415612974565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416146129d5565b6112bc612e3e565b612a36565b3461031d57602036600319011261031d576004356001600160a01b038116900361031d576112ed612ec1565b60026102325414611f8f576002610232556113277fd8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e63612f42565b6102665460006102655461027154908160801c8401808210600014611f845750909291925b818310611399575b50506102665580611368575b600161023255005b6000808080936004355af161137b612d11565b50156113875780611360565b604051638f58940960e01b8152600490fd5b9091600090600091816000526102706020526040600020604051906113bf604083612867565b546113cd60ff82168361318e565b60081c8060208301526001600160801b038616430310600014611452575060009250829050805b61143c575b156114355780600191337fb207e6b6b26274f3764b879e578b4539b8e37f41dff43932ddc87b3e04090974600080a3019301919092919261134c565b9250611354565b81600052610270602052600060408120556113f9565b8051600a8110156103f95760010361171657505080915060005261026760205261147f604060002061319a565b61026480546040805163235e81cf60e01b81528451600482015260208501516024820152908401516001600160a01b0390811660448301526060850151811660648301526080850151811660848301529091600091168260a48160c09485945af16000928392826116e1575b50506116655750506114fb612d11565b61150481613249565b906001600160e01b03198216630b63f1a760e01b8103611600575050611540600080516020614a7b8339815191529160405191829187836132b6565b0390a15b5460408201516020909201516001600160a01b039182169290911690823b1561031d576040516358f32de960e01b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156115f4576115e3575b505b806000526102676020526115d6604060002060046000918281558260018201558260028201558260038201550155565b6101f754906001806113f4565b60006115ee91612867565b846115a4565b6040513d6000823e3d90fd5b637912120160e01b03611636575061162e600080516020614a7b83398151915291604051918291878361327a565b0390a1611544565b600080516020614a9b833981519152915061162e90604051918291878352604060208401526040830190612e01565b7f5090a820029acae4d47b64da9af62ce04a5a1bdb546934e5fcfe091ee1f780ee91925060018060a01b03604085015116926116d986606060018060a01b03818901511697805194805192602082015190604083015192015192608060018060a01b039101511693604051988998896132fb565b0390a36115a6565b80919294506117059350903d1061170f575b6116fd8183612867565b810190613226565b92905089806114eb565b503d6116f3565b8051600a8110156103f957600203611a1b575050809150600052610269602052611743604060002061319a565b61026480546040805163bfe4262160e01b81528451600482015260208501516024820152908401516001600160a01b0390811660448301526060850151811660648301526080850151811660848301529091600091168260a48160c09485945af16000928392826119f6575b505061197a5750506117bf612d11565b6117c881613249565b6001600160e01b031981169163a5db715d60e01b83036118e357505060a0600080516020614a7b83398151915291604051908682526020820152601960608060408401528201527f496e73756666696369656e7420746320746f2072656465656d000000000000006080820152a15b54604082015191516001600160a01b039182169290911690823b1561031d576040516353b16d1760e01b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156115f4576118d2575b505b806000526102696020526118c5604060002060046000918281558260018201558260028201558260038201550155565b6101f854906001806113f4565b60006118dd91612867565b84611893565b90916354cde31360e01b810361191d575050611915600080516020614a7b83398151915291604051918291878361333a565b0390a1611837565b637912120160e01b0361194b5750611915600080516020614a7b83398151915291604051918291878361327a565b600080516020614a9b833981519152915061191590604051918291878352604060208401526040830190612e01565b7f7e7043742f69701e6292386d468d710f2d6e44bf93232a1e52f1641e50a9de1291925060018060a01b03604085015116926119ee86606060018060a01b03818901511697805194805192602082015190604083015192015192608060018060a01b039101511693604051988998896132fb565b0390a3611895565b8091929450611a119350903d1061170f576116fd8183612867565b92905089806117af565b8051600a8110156103f957600303611a465750509050611a3a81613480565b90816101f954926113f4565b8051600a8110156103f957600403611a715750509050611a6581613789565b90816101fa54926113f4565b8051600a8110156103f957600503611a9c5750509050611a90816139f8565b90816101ff54926113f4565b8051600a8110156103f957600603611ac75750509050611abb81613d8c565b90816101fe54926113f4565b8051600a8110156103f957600703611af25750509050611ae68161415a565b90816101fd54926113f4565b8051600a8110156103f957600803611b1d5750509050611b118161443c565b90816101fc54926113f4565b51600a8110156103f957600914611b35575b806113f4565b5080915060005261026f60205260006040812060405190611b5861010083612867565b60018060a01b03815416825260018060a01b03600182015416602083015260028101546040830152600381015460608301526004810154608083015260018060a01b0360058201541660a083015260018060a01b0360068201541660c0830152600760018060a01b039101541660e082015282825261026f60205281600760408220828155826001820155826002820155826003820155826004820155826005820155826006820155015560e060018060a01b0361026454166101046040518095819363391bf6cf861b835260018060a01b03875116600484015260018060a01b03602088015116602484015260408701516044840152606087015160648401526080870151608484015260018060a01b0360a08801511660a484015260018060a01b0360c08801511660c484015260018060a01b03868801511660e48401525af19182600091600094611f4d575b50611e9757509050611cb7612d11565b611cc081613249565b906001600160e01b03198216630b63f1a760e01b8103611e02575050611cfc600080516020614a7b8339815191529160405191829186836132b6565b0390a15b6102645460a0820151825160408401516001600160a01b039182169392821692909116803b1561031d57604051630e2c5e9960e41b81526001600160a01b03938416600482015293909216602484015260448301526000908290606490829084905af180156115f457611df1575b506102645460a08201516080909201516001600160a01b039182169290911690823b1561031d576040516358f32de960e01b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156115f457611de0575b505b6101fb54906001611b2f565b6000611deb91612867565b84611dd2565b6000611dfc91612867565b85611d6e565b63272e3f5960e21b8103611e3a575050611e32600080516020614a7b83398151915291604051918291868361410d565b0390a1611d00565b637912120160e01b03611e685750611e32600080516020614a7b83398151915291604051918291868361327a565b600080516020614a9b8339815191529150611e3290604051918291868352604060208401526040830190612e01565b7ff86f4487d2c5541b78f06d2368e28e0f4052e182124def54d5855bf2a01d325861012060018060a01b038451169260018060a01b036020860151169060018060a01b0360a0870151169560018060a01b0360c082015116976040820151928151602083015191606060408501519401519460e060018060a01b039101511695604051978852602088015260408701526060860152608085015260a084015260c083015260e082015286610100820152a4611dd4565b909350611f72915060e03d60e011611f7d575b611f6a8183612867565b8101906139d4565b925050909288611ca7565b503d611f60565b90509092919261134c565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b3461031d5761012036600319011261031d57611fee612e3e565b610266546102655403612005576108d36004614972565b6040516315996eab60e01b8152600490fd5b60c036600319011261031d5761202b612ec1565b612042600080516020614adb833981519152612f42565b61204e6101ff54614950565b610265805460405191612062604084612867565b60058352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026b83526120ba60046040600020614788565b604051828152600584820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d5760043560005261026f602052610100604060002060018060a01b03808254169181600182015416916002820154600383015460048401549183600586015416936007816006880154169601541695604051978852602088015260408701526060860152608085015260a084015260c083015260e0820152f35b3461031d57600036600319011261031d5760206101ff54604051908152f35b3461031d57600036600319011261031d5760ca5460ff8160081c16156121f557601081901c6001600160a01b03163303610d0b5761ff00191660ca557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b604051637c7fd07960e01b8152600490fd5b3461031d57600036600319011261031d5760206101f954604051908152f35b3461031d57600036600319011261031d576020612241614869565b6040519015158152f35b3461031d57602036600319011261031d576004356001600160801b03811680910361031d57612278612e3e565b61027180546001600160801b0319169091179055005b3461031d57602036600319011261031d576004356001600160a01b03808216820361031d576108d3916122ed826000937f0000000000000000000000000000000000000000000000000000000000000000169061128b82301415612974565b6122f5612e3e565b6122fe8261289f565b9061230c6040519283612867565b828252601f1961231b8461289f565b01366020840137612a36565b3461031d57604036600319011261031d576024356001600160a01b03811680820361031d57330361235e576108d3906004356128f5565b60405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608490fd5b61010036600319011261031d576123d0612ec1565b6123e7600080516020614adb833981519152612f42565b6123f36101fb54614950565b6102658054604051612406604082612867565b600981526020810160018060f81b0343168152826000526102706020526040600020915190600a8210156103f9575160ff9190911660089190911b60ff1916179055600081815261026f602052604090206001600160a01b0360043581811694929085900361031d576001600160601b0360a01b94858254161781556001810160243583811680910361031d57868254161790556044356002820155606435600382015560843560048201556005810160a43583811680910361031d5786825416179055600681019060c4359183831680930361031d5760079287825416179055019060e43590811680910361031d57602094825416179055604051828152600984820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57604036600319011261031d576004356024356001600160a01b038116810361031d578161255d6108d3936149c2565b6148ce565b3461031d57602036600319011261031d576004356001600160a01b038116810361031d5761258e612e3e565b60ca805462010000600160b01b03191660109290921b62010000600160b01b0316919091179055005b3461031d57600036600319011261031d57602061026654604051908152f35b3461031d57602036600319011261031d576004356000526101936020526020600160406000200154604051908152f35b3461031d57602036600319011261031d576004803560009081526102676020908152604091829020805460018201546002830154600384015493909601548551928352938201526001600160a01b03948516938101939093528316606083015291909116608082015260a090f35b3461031d57602036600319011261031d5760043560005261026d602052604060002060018060a01b03610319818354169160018401549360028101549160038201548160048401541691600681600586015416940154169360405197889788612824565b3461031d57600036600319011261031d576097546040516001600160a01b039091168152602090f35b3461031d57602036600319011261031d5760043563ffffffff60e01b811680910361031d57602090637965db0b60e01b8114908115612746575b506040519015158152f35b6301ffc9a760e01b1490508261273b565b60e036600319011261031d5761276b612ec1565b612782600080516020614adb833981519152612f42565b61278e6101fc54614950565b6102658054604051916127a2604084612867565b60088352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026e83526127fa600460406000206147f3565b604051828152600884820152600080516020614abb83398151915260403392a26103ef8154614779565b6001600160a01b039182168152602081019290925260408201929092526060810192909252918216608082015291811660a083015290911660c082015260e00190565b90601f8019910116810190811067ffffffffffffffff82111761288957604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161288957601f01601f191660200190565b6001600160a01b0391821681526020810192909252604082019290925291811660608301529182166080820152911660a082015260c00190565b9060009180835261019380602052604084209260018060a01b03169283855260205260ff60408520541661292a575b50505050565b818452602052604083208284526020526040832060ff1981541690557ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b339380a438808080612924565b1561297b57565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b156129dc57565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b6163746976652070726f787960a01b6064820152608490fd5b9060ff7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435416600014612a705750612a6e9150612c6f565b565b6040516352d1902d60e01b8152602093919291906001600160a01b038316908581600481855afa60009181612c3d575b50612b015760405162461bcd60e51b815260048101879052602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b6064820152608490fd5b9394937fc9f76b5ec45e5cdef99837d7b6d2467235c1df8933c8ca56df5c35afa2c7d44401612be657612b3383612c6f565b7fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a283511590811591612bde575b50612b6e57505050565b600080612bdb94612b7f602761289f565b94612b8d6040519687612867565b602786527f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c81870152660819985a5b195960ca1b604087015281519101845af4612bd5612d11565b91612d41565b50565b905038612b64565b60405162461bcd60e51b815260048101859052602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b6064820152608490fd5b90918782813d8311612c68575b612c548183612867565b81010312612c655750519038612aa0565b80fd5b503d612c4a565b803b15612cb6577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b03909216919091179055565b60405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b6064820152608490fd5b3d15612d3c573d90612d228261289f565b91612d306040519384612867565b82523d6000602084013e565b606090565b91929015612da35750815115612d55575090565b3b15612d5e5790565b60405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b825190915015612db65750805190602001fd5b60405162461bcd60e51b815260206004820152908190612dda906024830190612e01565b0390fd5b60005b838110612df15750506000910152565b8181015183820152602001612de1565b90602091612e1a81518092818552858086019101612dde565b601f01601f1916010190565b9081602091031261031d5751801515810361031d5790565b60975460405163d994d6d560e01b815233600482015290602090829060249082906001600160a01b03165afa9081156115f457600091612e93575b5015612e8157565b604051631dd1b1b560e21b8152600490fd5b612eb4915060203d8111612eba575b612eac8183612867565b810190612e26565b38612e79565b503d612ea2565b60ff60ca5460081c16612ed057565b60405163783bb6c960e11b8152600490fd5b15612ee957565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b8060005260206101938152604060002033600052815260ff6040600020541615612f6a575050565b6130006048612f8483612f7e601433613021565b95613021565b936040519485917f416363657373436f6e74726f6c3a206163636f756e742000000000000000000086840152612fc38151809288603787019101612dde565b82017001034b99036b4b9b9b4b733903937b6329607d1b6037820152612ff182518093888785019101612dde565b01036028810185520183612867565b612dda60405192839262461bcd60e51b845260048401526024830190612e01565b60019180831b91906001600160ff1b03811603613162576002820192838311613162576130666130508561289f565b9461305e6040519687612867565b80865261289f565b6020939085850190601f190136823785511561317857603090538451821015613178576078602186015381810180911161316257905b8082116130f05750506130ad575090565b6064906040519062461bcd60e51b825280600483015260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152fd5b9091600f8116601081101561314d57855184101561314d576f181899199a1a9b1b9c1cb0b131b232b360811b901a85840185015360041c91801561313857600019019061309c565b60246000634e487b7160e01b81526011600452fd5b60246000634e487b7160e01b81526032600452fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b600a8210156103f95752565b906040516131a960a082612867565b825481526001830154602082015260028301546001600160a01b0390811660408301526003840154811660608301526004909301549092166080830152565b919082608091031261031d57604051613202608082612867565b60608082948051845260208101516020850152604081015160408501520151910152565b909160c08284031261031d576132468251936040602085015194016131e8565b90565b906020825192015163ffffffff60e01b90818116936004811061326b57505050565b60040360031b82901b16169150565b909160a092825263ffffffff60e01b16602082015260606040820152600c60608201526b4c6f7720636f76657261676560a01b60808201520190565b909160a092825263ffffffff60e01b166020820152606060408201526015606082015274125b9cdd59999a58da595b9d081c5858c81cd95b9d605a1b60808201520190565b94919260e0969399989794919961010087019a8752602087015260408601526060850152608084015260a083015260018060a01b031660c08201520152565b909160a092825263ffffffff60e01b16602082015260606040820152601a60608201527f7141432062656c6f77206d696e696d756d20726571756972656400000000000060808201520190565b9060405161339660c082612867565b82546001600160a01b039081168252600184015460208301526002840154604083015260038401548116606083015260048401548116608083015260059093015490921660a0830152565b60a09081600180821b03918281511685526020810151602086015260408101516040860152826060820151166060860152826080820151166080860152015116910152565b909160c092825263ffffffff60e01b16602082015260606040820152602460608201527f4d617820666c757820636170616369746f72206f7065726174696f6e2072656160808201526318da195960e21b60a08201520190565b90600082815261026892602090848252604061349d818520613387565b61026480548351635a21a61960e11b81526001600160a01b039992969160c090829060c49082908c908f166134d5600484018b6133e1565b5af1908189918a93613765575b506136ec5750506134f1612d11565b986134fb8a613249565b966001600160e01b031988166306da41e560e11b810361354257505050505050600080516020614a7b8339815191529394955061353c905192839283613426565b0390a190565b869998839598969c63c39b739f60e09996991b831460001461365b57505060a0600080516020614a7b8339815191529185519088825289820152606086820152601760608201527f496e73756666696369656e7420747020746f206d696e740000000000000000006080820152a15b54169160608a01511698015197813b156136575786516358f32de960e01b81526001600160a01b039091166004820152602481019890985284908890818381604481015b03925af196871561364d576136349697613639575b505b8352522060056000918281558260018201558260028201558260038201558260048201550155565b600190565b8461364691959295612867565b923861360a565b85513d86823e3d90fd5b8580fd5b9091630b63f1a760e01b810361369457505061368c600080516020614a7b83398151915291855191829189836132b6565b0390a16135b1565b637912120160e01b036136c1575061368c600080516020614a7b833981519152918551918291898361327a565b600080516020614a9b833981519152915061368c908551918291898352878b84015287830190612e01565b8492959897507f125247fdf990b9b419d4b4f895b1bb75bc485e3f8b813cf5557a4a12a56d054d908b6136349b9c9395989651169261375d878c836060890151169784608082015116998c820151958d8251908301519160a0606087860151950151950151169451988998896132fb565b0390a461360c565b909250613780915060c03d811161170f576116fd8183612867565b929050386134e2565b90600082815261026a60209381855260406137a5818520613387565b6102648054835163ad4e666d60e01b81526001600160a01b03999296939160c090829060c49082908c908f166137de60048401896133e1565b5af1908189918a936139b0575b5061393f5750506137fa612d11565b9561380487613249565b966001600160e01b031988166306da41e560e11b810361384557505050505050600080516020614a7b8339815191529394955061353c905192839283613426565b908b9394969998916354cde31360e09997991b81146000146138df575050613882600080516020614a7b833981519152918a51918291888361333a565b0390a15b54169083896060830151169982511691015198823b156138db578751630e2c5e9960e41b81526001600160a01b03918216600482015291166024820152604481019890985284908890818381606481016135f5565b8680fd5b637912120160e01b03613914575061390c600080516020614a7b833981519152918a51918291888361327a565b0390a1613886565b600080516020614a9b833981519152915061390c908a519182918883528c8a8401528c830190612e01565b8a9193959897507f625b9fc283a619f53beb817d79b8ab044d60e307fd2af4bb89fa5e9a24ce4ebc906136349a9b8498969851169261375d878c836060890151169784608082015116998c820151958d8251908301519160a0606087860151950151950151169451988998896132fb565b9092506139cb915060c03d811161170f576116fd8183612867565b929050386137eb565b60e08183031261031d578051926132466020830151936060604085015194016131e8565b90600082815261026b80602052604093613a13858420613387565b9460018060a01b0395610264938560e08987541660c486518094819363883d21cb861b8352613a45600484018a6133e1565b5af187918291829181613c6f575b50613bf457505050613a63612d11565b97613a6d89613249565b956001600160e01b031987166306da41e560e11b8103613aad575050505050600080516020614a7b8339815191529394955061353c905192839283613426565b9682949a869998630b63f1a760e0999896991b8114600014613b93575050613aea600080516020614a7b83398151915291855191829189836132b6565b0390a15b54169160608901511697015196813b15613b8f5785516358f32de960e01b81526001600160a01b03919091166004820152602481019790975283908790604490829084905af1958615613b85576136349596613b71575b505b82526020522060056000918281558260018201558260028201558260038201558260048201550155565b83613b7e91949294612867565b9138613b45565b84513d85823e3d90fd5b8480fd5b637912120160e01b03613bc85750613bc0600080516020614a7b833981519152918551918291898361327a565b0390a1613aee565b600080516020614a9b8339815191529150613bc090855191829189835287602084015287830190612e01565b85989750907f03e9e02a94d7486426fcf2b05a27e911b8d1b61e2e1dcf103785512f46c8476491613c678887959699988e6136349e9f9951169689606082015116988a6080830151169a60208301519782519060208401519260a0606088870151960151960151169551998a998a613c94565b0390a4613b47565b91509250613c8b915060e03d8111611f7d57611f6a8183612867565b93905038613a53565b95926101009794919a9998959261012088019b8852602088015260408701526060860152608085015260a084015260c083015260018060a01b031660e08201520152565b90604051613ce760e082612867565b82546001600160a01b0390811682526001840154602083015260028401546040830152600384015460608301526004840154811660808301526005840154811660a083015260069093015490921660c0830152565b60c0908160018060a01b03918281511685526020810151602086015260408101516040860152606081015160608601528260808201511660808601528260a08201511660a0860152015116910152565b90600082815261026c602090808252604090613da9828520613cd8565b61026480548451633631a6bb60e21b81526001600160a01b039693929160e090829060e49082908c908c16613de1600484018a613d3c565b5af19088828a928b946140e5575b5061406b57505050613dff612d11565b95613e0987613249565b966001600160e01b03198816906306da41e560e11b8203613e4b57505050505050509361353c600080516020614a7b8339815191529394955192839283613426565b637a031da360e19a99929394959697989a1b8314600014613fda57505060a0600080516020614a7b833981519152918951908c82528782015260608a8201526014606082015273125b9cdd59999a58da595b9d081d1c081cd95b9d60621b6080820152a15b808254169160808401928284511690838651168a87015192823b15613fd6578b51630e2c5e9960e41b81526001600160a01b03918216600482015291166024820152604481019290925288908290606490829084905af18015613fcc57613fb4575b5090808592541692511692015191813b156136575786516353b16d1760e01b81526001600160a01b039091166004820152602481019290925284908290818381604481015b03925af1801561364d57613f9b575b5061363494955b8352522060066000918281558260018201558260028201558260038201558260048201558260058201550155565b613fa6848092612867565b613fb05738613f66565b8280fd5b9187613fc38293998895612867565b97919250613f12565b89513d8a823e3d90fd5b8a80fd5b90916354cde31360e01b810361401357505061400b600080516020614a7b8339815191529189519182918d8361333a565b0390a1613eb0565b637912120160e01b03614040575061400b600080516020614a7b8339815191529189519182918d8361327a565b600080516020614a9b833981519152915061400b9089519182918d83528b898401528b830190612e01565b84929350907f4d33a2f9c4f66a101333f7ca2ab718582e763c941ff6fc304d2d4408d43a8284916140dd8d8a6136349e9f999a9b9d9c809951169689608082015116988a60a0830151169a8d80840151978351918401519260c0606088870151960151960151169551998a998a613c94565b0390a4613f6d565b91509250614101915060e03d8111611f7d57611f6a8183612867565b92905090919238613def565b909160a092825263ffffffff60e01b16602082015260606040820152601a60608201527f7154702062656c6f77206d696e696d756d20726571756972656400000000000060808201520190565b90600082815261026d602090808252604090614177828520613cd8565b610264805484516312bce9bf60e21b81526001600160a01b039693929160e090829060e49082908c908c166141af600484018a613d3c565b5af1908189918a93614416575b506143a55750506141cb612d11565b956141d587613249565b966001600160e01b031988166306da41e560e11b810361421657505050505050509361353c600080516020614a7b8339815191529394955192839283613426565b630b63f1a760e09a999394959697989a1b8114600014614316575050614251600080516020614a7b8339815191529189519182918d836132b6565b0390a15b8082541691608084019282845116908686015191813b15614312578a516353b16d1760e01b81526001600160a01b039091166004820152602481019290925288908290818381604481015b03925af18015613fcc576142f9575b509080606092541692511692015191813b156136575786516358f32de960e01b81526001600160a01b03909116600482015260248101929092528490829081838160448101613f57565b9187614309829399606095612867565b979192506142af565b8980fd5b63272e3f5960e21b810361434d575050614345600080516020614a7b8339815191529189519182918d8361410d565b0390a1614255565b637912120160e01b0361437a5750614345600080516020614a7b8339815191529189519182918d8361327a565b600080516020614a9b83398151915291506143459089519182918d83528b898401528b830190612e01565b8392507ff8dcb57698d7067da58ab71c48cd2e3b329b69e7e9853f88630c2c69c2557c7890886136349b9c9697989a9993955116926140dd878c83608089015116978460a082015116998c820151958d8251908301519160c0606087860151950151950151169451988998896132fb565b909250614431915060e03d8111611f7d57611f6a8183612867565b9250509091386141bc565b90600082815261026e602090808252604090614459828520613cd8565b61026480548451635e272ad960e11b81526001600160a01b039693929160e090829060e49082908c908c16614491600484018a613d3c565b5af1908189918a936146cc575b5061465b5750506144ad612d11565b956144b787613249565b966001600160e01b03198816906306da41e560e11b82036144f957505050505050509361353c600080516020614a7b8339815191529394955192839283613426565b630b63f1a760e09a99929394959697989a1b83146000146145945750600080516020614a7b83398151915291506145369089519182918d836132b6565b0390a15b808254169160808401928284511690838651168787015192823b15613fd6578b51630e2c5e9960e41b81526001600160a01b03918216600482015291166024820152604481019290925288908290818381606481016142a0565b63f577bef560e01b83036145f957505060a0600080516020614a7b833981519152918951908c82528782015260608a820152601a60608201527f7154632062656c6f77206d696e696d756d2072657175697265640000000000006080820152a161453a565b9091637912120160e01b036146305750614628600080516020614a7b8339815191529189519182918d8361327a565b0390a161453a565b600080516020614a9b83398151915291506146289089519182918d83528b898401528b830190612e01565b8392507f8ab42044ce8b230e021e5542eb53688d77443e50ee84cda7917f6bdd833c697f90886136349b9c9697989a9993955116926140dd878c83608089015116978460a082015116998c820151958d8251908301519160c0606087860151950151950151169451988998896132fb565b9092506146e7915060e03d8111611f7d57611f6a8183612867565b92505090913861449e565b356001600160a01b038116810361031d5790565b813581556020820135600182015560028101906001600160a01b039061476f9060809060049084614739604089016146f2565b16956001600160601b0360a01b9687825416179055600381018561475f60608a016146f2565b16878254161790550194016146f2565b1690825416179055565b60001981146131625760010190565b6001600160a01b0361476f60a06005836147a1876146f2565b16946001600160601b03831b9586825416178155602087013560018201556040870135600282015560038101856147da60608a016146f2565b1687825416179055600481018561475f60808a016146f2565b6001600160a01b0361476f60c060068361480c876146f2565b16946001600160601b0360a01b9586825416178155602087013560018201556040870135600282015560608701356003820155600481018561485060808a016146f2565b1687825416179055600581018561475f60a08a016146f2565b610266546102655481146148c8576000526102706020526020604060002060405190614896604083612867565b546148a460ff82168361318e565b60081c91829101526001600160801b03610271541643039043821161316257111590565b50600090565b9060009180835261019380602052604084209260018060a01b03169283855260205260ff604085205416156149035750505050565b8184526020526040832082845260205260408320600160ff198254161790557f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d339380a438808080612924565b34810361495a5750565b6024906040519063049e6f6960e41b82526004820152fd5b80356101f75560208101356101f85560408101356101f95560608101356101fa5560808101356101fb5560a08101356101fc5560c08101356101fd5560e08101356101fe5561010001356101ff55565b6097546040805163d994d6d560e01b8152336004820152909291602090829060249082906001600160a01b03165afa908115614a6f57600091614a51575b50159081614a21575b50614a115750565b51631dd1b1b560e21b8152600490fd5b90506000526101936020526001816000200154600052806000203360005260205260ff8160002054161538614a09565b614a69915060203d8111612eba57612eac8183612867565b38614a00565b83513d6000823e3d90fdfe5bbebb64d62396f99cae4b3b78d9386cb0f2893aab6a69f27eb61f8e7c29775e3ea497186958ec638834f65ec5a571c2b2e877e5d59a76804ec0448fac7829babfa5d40ab595fa613b17566ea5e38a5cac79a71f09ce1435246db2e6805816c27d5e686862ec2250829eb6dee4a7cb0834865072f135485c874d3bbbe39bdfdba2646970667358221220d516e5624a1bed1b85eb5258e760f97f37799d0567946952dbd82f9ac78a43a964736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b60003560e01c8062c6e88e1461275757806301ffc9a7146127015780630c340a24146126d85780631826ebf0146126745780631a0c544014612606578063248a9ca3146125d65780632b994849146125b75780632d88af4a146125625780632f2ff15d1461252957806334975a41146123bb57806336568abe146123275780633659cfe61461228e5780633bb4b05c1461224b5780633cbcf4c4146122265780633dc8797a146122075780633f4ba83a1461218d5780633fa9e0c61461216e578063435c7e37146120e457806347d8496a146120175780634981d04e14611fd45780634b64e492146112c15780634f1ef286146111d75780635210570c146111b257806352d1902d146110dc5780635c817aa3146110785780635c975abb146110525780635ee1d2bb1461100857806364d9e82114610fe9578063681fe70c14610fc55780636827435714610f9d5780636b59c22f14610ed05780636b76333014610e6c57806373e3d08614610e4d5780637656cd1014610e2e5780637c50b7e414610dea5780637e81a82114610d1d5780638456cb5914610c875780638a4737ab14610c285780638b20076c14610bc95780638e7e818914610ba157806391d1485414610b4e57806397ac81fb14610b2f5780639aac1c2a14610b105780639fd0506d14610ae3578063a217fddf14610ac7578063ad16c2de14610a59578063bb4872de14610a36578063bbe720d9146109c1578063c84d8bb6146108f4578063d17910e2146108d5578063d547741f1461089a578063d9a862d614610870578063db9014771461064f578063dbb0b6841461062d578063e4c0aaf4146105e7578063e4e1b7291461051a578063e97a4d631461044d578063eeab6f4b1461042e578063f2cee87a1461040f578063fa91a9a5146103225763fb8aafb8146102ba57600080fd5b3461031d57602036600319011261031d5760043560005261026a602052604060002060018060a01b03610319818354169160018401549360028101549180600383015416906005816004850154169301541692604051968796876128bb565b0390f35b600080fd5b60a036600319011261031d57610336612ec1565b61034d600080516020614adb833981519152612f42565b6103596101f854614950565b61026580546040519161036d604084612867565b60028352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026983526103c560046040600020614706565b604051828152600284820152600080516020614abb83398151915260403392a26103ef8154614779565b9055604051908152f35b634e487b7160e01b600052602160045260246000fd5b3461031d57600036600319011261031d5760206101fd54604051908152f35b3461031d57600036600319011261031d5760206101fb54604051908152f35b60a036600319011261031d57610461612ec1565b610478600080516020614adb833981519152612f42565b6104846101f754614950565b610265805460405191610498604084612867565b60018352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026783526104f060046040600020614706565b604051828152600184820152600080516020614abb83398151915260403392a26103ef8154614779565b60e036600319011261031d5761052e612ec1565b610545600080516020614adb833981519152612f42565b6105516101fe54614950565b610265805460405191610565604084612867565b60068352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026c83526105bd600460406000206147f3565b604051828152600684820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d576004356001600160a01b0381169081900361031d57610615612e3e565b6001600160601b0360a01b6097541617609755600080f35b3461031d57600036600319011261031d5760206102715460801c604051908152f35b3461031d576101a036600319011261031d576001600160a01b036004358181169081900361031d57602435918216820361031d576044356001600160801b039283821680920361031d57606435938416840361031d5761012036608319011261031d576000549260ff8460081c161593848095610863575b801561084c575b156107f05761076592600191868360ff198316176000556107de575b5060ff60005460081c16926106fe84612ee2565b61070784612ee2565b61071084612ee2565b61071984612ee2565b61072284612ee2565b6001600160601b0360a01b609754161760975561073e83612ee2565b60ca5490620100008360b01b039060101b169061ff018360b01b031916171760ca55612ee2565b61076f6084614972565b6000549261078b60ff8560081c1661078681612ee2565b612ee2565b60016102325560801b6001600160801b03191617610271556107a957005b61ff0019166000557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160018152a1005b61ffff191661010117600055876106ea565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b50303b1580156106ce5750600160ff8216146106ce565b50600160ff8216106106c7565b3461031d57600036600319011261031d57610264546040516001600160a01b039091168152602090f35b3461031d57604036600319011261031d576004356024356001600160a01b038116810361031d57816108ce6108d3936149c2565b6128f5565b005b3461031d57600036600319011261031d5760206101fa54604051908152f35b60c036600319011261031d57610908612ec1565b61091f600080516020614adb833981519152612f42565b61092b6101fa54614950565b61026580546040519161093f604084612867565b60048352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026a835261099760046040600020614788565b604051828152600484820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d576001600160a01b036004358181169081900361031d576109f0612e3e565b6102648054928316610a2457816108d3936001600160601b0360a01b16179055600080516020614adb8339815191526148ce565b604051630a646b7760e41b8152600490fd5b3461031d57600036600319011261031d57602060ff60ca54166040519015158152f35b3461031d57602036600319011261031d576004803560009081526102696020908152604091829020805460018201546002830154600384015493909601548551928352938201526001600160a01b03948516938101939093528316606083015291909116608082015260a090f35b3461031d57600036600319011261031d57602060405160008152f35b3461031d57600036600319011261031d5760ca5460405160109190911c6001600160a01b03168152602090f35b3461031d57600036600319011261031d5760206101f754604051908152f35b3461031d57600036600319011261031d5760206101f854604051908152f35b3461031d57604036600319011261031d576024356001600160a01b0381169081900361031d57600435600052610193602052604060002090600052602052602060ff604060002054166040519015158152f35b3461031d57600036600319011261031d5760206001600160801b036102715416604051908152f35b3461031d57602036600319011261031d5760043560005261026b602052604060002060018060a01b03610319818354169160018401549360028101549180600383015416906005816004850154169301541692604051968796876128bb565b3461031d57602036600319011261031d57600435600052610268602052604060002060018060a01b03610319818354169160018401549360028101549180600383015416906005816004850154169301541692604051968796876128bb565b3461031d57600036600319011261031d57610ca0612ec1565b60ca54601081901c6001600160a01b03163303610d0b5760ff811615610cf9576101009061ff0019161760ca557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b60405163866099c360e01b8152600490fd5b604051631d77d47760e21b8152600490fd5b60c036600319011261031d57610d31612ec1565b610d48600080516020614adb833981519152612f42565b610d546101f954614950565b610265805460405191610d68604084612867565b60038352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b169116179055816000526102688352610dc060046040600020614788565b604051828152600384820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d5760043560005261027060205260406000205460ff81169060405190600a8310156103f957604092825260081c6020820152f35b3461031d57600036600319011261031d5760206101fe54604051908152f35b3461031d57600036600319011261031d57602061026554604051908152f35b3461031d57602036600319011261031d5760043560005261026c602052604060002060018060a01b03610319818354169160018401549360028101549160038201548160048401541691600681600586015416940154169360405197889788612824565b60e036600319011261031d57610ee4612ec1565b610efb600080516020614adb833981519152612f42565b610f076101fd54614950565b610265805460405191610f1b604084612867565b60078352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026d8352610f73600460406000206147f3565b604051828152600784820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57600036600319011261031d57610fb6612e3e565b60ca805460ff19166001179055005b3461031d57600036600319011261031d576020610266546102655414604051908152f35b3461031d57600036600319011261031d5760206101fc54604051908152f35b3461031d57602036600319011261031d576001600160801b03600435818116810361031d57611035612e3e565b610271805490921660809190911b6001600160801b031916179055005b3461031d57600036600319011261031d57602060ff60ca5460081c166040519015158152f35b3461031d57602036600319011261031d5760043560005261026e602052604060002060018060a01b03610319818354169160018401549360028101549160038201548160048401541691600681600586015416940154169360405197889788612824565b3461031d57600036600319011261031d577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036111475760206040517f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8152f35b60405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c00000000000000006064820152608490fd5b3461031d57600036600319011261031d576111cb612e3e565b60ca805460ff19169055005b604036600319011261031d576001600160a01b03600435818116810361031d5760243567ffffffffffffffff811161031d573660238201121561031d578060040135916112238361289f565b916112316040519384612867565b838352366024858301011161031d576108d394600060208660019760246112b496018389013786010152807f0000000000000000000000000000000000000000000000000000000000000000169061128b82301415612974565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416146129d5565b6112bc612e3e565b612a36565b3461031d57602036600319011261031d576004356001600160a01b038116900361031d576112ed612ec1565b60026102325414611f8f576002610232556113277fd8aa0f3194971a2a116679f7c2090f6939c8d4e01a2a8d7e41d55e5351469e63612f42565b6102665460006102655461027154908160801c8401808210600014611f845750909291925b818310611399575b50506102665580611368575b600161023255005b6000808080936004355af161137b612d11565b50156113875780611360565b604051638f58940960e01b8152600490fd5b9091600090600091816000526102706020526040600020604051906113bf604083612867565b546113cd60ff82168361318e565b60081c8060208301526001600160801b038616430310600014611452575060009250829050805b61143c575b156114355780600191337fb207e6b6b26274f3764b879e578b4539b8e37f41dff43932ddc87b3e04090974600080a3019301919092919261134c565b9250611354565b81600052610270602052600060408120556113f9565b8051600a8110156103f95760010361171657505080915060005261026760205261147f604060002061319a565b61026480546040805163235e81cf60e01b81528451600482015260208501516024820152908401516001600160a01b0390811660448301526060850151811660648301526080850151811660848301529091600091168260a48160c09485945af16000928392826116e1575b50506116655750506114fb612d11565b61150481613249565b906001600160e01b03198216630b63f1a760e01b8103611600575050611540600080516020614a7b8339815191529160405191829187836132b6565b0390a15b5460408201516020909201516001600160a01b039182169290911690823b1561031d576040516358f32de960e01b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156115f4576115e3575b505b806000526102676020526115d6604060002060046000918281558260018201558260028201558260038201550155565b6101f754906001806113f4565b60006115ee91612867565b846115a4565b6040513d6000823e3d90fd5b637912120160e01b03611636575061162e600080516020614a7b83398151915291604051918291878361327a565b0390a1611544565b600080516020614a9b833981519152915061162e90604051918291878352604060208401526040830190612e01565b7f5090a820029acae4d47b64da9af62ce04a5a1bdb546934e5fcfe091ee1f780ee91925060018060a01b03604085015116926116d986606060018060a01b03818901511697805194805192602082015190604083015192015192608060018060a01b039101511693604051988998896132fb565b0390a36115a6565b80919294506117059350903d1061170f575b6116fd8183612867565b810190613226565b92905089806114eb565b503d6116f3565b8051600a8110156103f957600203611a1b575050809150600052610269602052611743604060002061319a565b61026480546040805163bfe4262160e01b81528451600482015260208501516024820152908401516001600160a01b0390811660448301526060850151811660648301526080850151811660848301529091600091168260a48160c09485945af16000928392826119f6575b505061197a5750506117bf612d11565b6117c881613249565b6001600160e01b031981169163a5db715d60e01b83036118e357505060a0600080516020614a7b83398151915291604051908682526020820152601960608060408401528201527f496e73756666696369656e7420746320746f2072656465656d000000000000006080820152a15b54604082015191516001600160a01b039182169290911690823b1561031d576040516353b16d1760e01b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156115f4576118d2575b505b806000526102696020526118c5604060002060046000918281558260018201558260028201558260038201550155565b6101f854906001806113f4565b60006118dd91612867565b84611893565b90916354cde31360e01b810361191d575050611915600080516020614a7b83398151915291604051918291878361333a565b0390a1611837565b637912120160e01b0361194b5750611915600080516020614a7b83398151915291604051918291878361327a565b600080516020614a9b833981519152915061191590604051918291878352604060208401526040830190612e01565b7f7e7043742f69701e6292386d468d710f2d6e44bf93232a1e52f1641e50a9de1291925060018060a01b03604085015116926119ee86606060018060a01b03818901511697805194805192602082015190604083015192015192608060018060a01b039101511693604051988998896132fb565b0390a3611895565b8091929450611a119350903d1061170f576116fd8183612867565b92905089806117af565b8051600a8110156103f957600303611a465750509050611a3a81613480565b90816101f954926113f4565b8051600a8110156103f957600403611a715750509050611a6581613789565b90816101fa54926113f4565b8051600a8110156103f957600503611a9c5750509050611a90816139f8565b90816101ff54926113f4565b8051600a8110156103f957600603611ac75750509050611abb81613d8c565b90816101fe54926113f4565b8051600a8110156103f957600703611af25750509050611ae68161415a565b90816101fd54926113f4565b8051600a8110156103f957600803611b1d5750509050611b118161443c565b90816101fc54926113f4565b51600a8110156103f957600914611b35575b806113f4565b5080915060005261026f60205260006040812060405190611b5861010083612867565b60018060a01b03815416825260018060a01b03600182015416602083015260028101546040830152600381015460608301526004810154608083015260018060a01b0360058201541660a083015260018060a01b0360068201541660c0830152600760018060a01b039101541660e082015282825261026f60205281600760408220828155826001820155826002820155826003820155826004820155826005820155826006820155015560e060018060a01b0361026454166101046040518095819363391bf6cf861b835260018060a01b03875116600484015260018060a01b03602088015116602484015260408701516044840152606087015160648401526080870151608484015260018060a01b0360a08801511660a484015260018060a01b0360c08801511660c484015260018060a01b03868801511660e48401525af19182600091600094611f4d575b50611e9757509050611cb7612d11565b611cc081613249565b906001600160e01b03198216630b63f1a760e01b8103611e02575050611cfc600080516020614a7b8339815191529160405191829186836132b6565b0390a15b6102645460a0820151825160408401516001600160a01b039182169392821692909116803b1561031d57604051630e2c5e9960e41b81526001600160a01b03938416600482015293909216602484015260448301526000908290606490829084905af180156115f457611df1575b506102645460a08201516080909201516001600160a01b039182169290911690823b1561031d576040516358f32de960e01b81526001600160a01b039290921660048301526024820152906000908290604490829084905af180156115f457611de0575b505b6101fb54906001611b2f565b6000611deb91612867565b84611dd2565b6000611dfc91612867565b85611d6e565b63272e3f5960e21b8103611e3a575050611e32600080516020614a7b83398151915291604051918291868361410d565b0390a1611d00565b637912120160e01b03611e685750611e32600080516020614a7b83398151915291604051918291868361327a565b600080516020614a9b8339815191529150611e3290604051918291868352604060208401526040830190612e01565b7ff86f4487d2c5541b78f06d2368e28e0f4052e182124def54d5855bf2a01d325861012060018060a01b038451169260018060a01b036020860151169060018060a01b0360a0870151169560018060a01b0360c082015116976040820151928151602083015191606060408501519401519460e060018060a01b039101511695604051978852602088015260408701526060860152608085015260a084015260c083015260e082015286610100820152a4611dd4565b909350611f72915060e03d60e011611f7d575b611f6a8183612867565b8101906139d4565b925050909288611ca7565b503d611f60565b90509092919261134c565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b3461031d5761012036600319011261031d57611fee612e3e565b610266546102655403612005576108d36004614972565b6040516315996eab60e01b8152600490fd5b60c036600319011261031d5761202b612ec1565b612042600080516020614adb833981519152612f42565b61204e6101ff54614950565b610265805460405191612062604084612867565b60058352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026b83526120ba60046040600020614788565b604051828152600584820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57602036600319011261031d5760043560005261026f602052610100604060002060018060a01b03808254169181600182015416916002820154600383015460048401549183600586015416936007816006880154169601541695604051978852602088015260408701526060860152608085015260a084015260c083015260e0820152f35b3461031d57600036600319011261031d5760206101ff54604051908152f35b3461031d57600036600319011261031d5760ca5460ff8160081c16156121f557601081901c6001600160a01b03163303610d0b5761ff00191660ca557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b604051637c7fd07960e01b8152600490fd5b3461031d57600036600319011261031d5760206101f954604051908152f35b3461031d57600036600319011261031d576020612241614869565b6040519015158152f35b3461031d57602036600319011261031d576004356001600160801b03811680910361031d57612278612e3e565b61027180546001600160801b0319169091179055005b3461031d57602036600319011261031d576004356001600160a01b03808216820361031d576108d3916122ed826000937f0000000000000000000000000000000000000000000000000000000000000000169061128b82301415612974565b6122f5612e3e565b6122fe8261289f565b9061230c6040519283612867565b828252601f1961231b8461289f565b01366020840137612a36565b3461031d57604036600319011261031d576024356001600160a01b03811680820361031d57330361235e576108d3906004356128f5565b60405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b6064820152608490fd5b61010036600319011261031d576123d0612ec1565b6123e7600080516020614adb833981519152612f42565b6123f36101fb54614950565b6102658054604051612406604082612867565b600981526020810160018060f81b0343168152826000526102706020526040600020915190600a8210156103f9575160ff9190911660089190911b60ff1916179055600081815261026f602052604090206001600160a01b0360043581811694929085900361031d576001600160601b0360a01b94858254161781556001810160243583811680910361031d57868254161790556044356002820155606435600382015560843560048201556005810160a43583811680910361031d5786825416179055600681019060c4359183831680930361031d5760079287825416179055019060e43590811680910361031d57602094825416179055604051828152600984820152600080516020614abb83398151915260403392a26103ef8154614779565b3461031d57604036600319011261031d576004356024356001600160a01b038116810361031d578161255d6108d3936149c2565b6148ce565b3461031d57602036600319011261031d576004356001600160a01b038116810361031d5761258e612e3e565b60ca805462010000600160b01b03191660109290921b62010000600160b01b0316919091179055005b3461031d57600036600319011261031d57602061026654604051908152f35b3461031d57602036600319011261031d576004356000526101936020526020600160406000200154604051908152f35b3461031d57602036600319011261031d576004803560009081526102676020908152604091829020805460018201546002830154600384015493909601548551928352938201526001600160a01b03948516938101939093528316606083015291909116608082015260a090f35b3461031d57602036600319011261031d5760043560005261026d602052604060002060018060a01b03610319818354169160018401549360028101549160038201548160048401541691600681600586015416940154169360405197889788612824565b3461031d57600036600319011261031d576097546040516001600160a01b039091168152602090f35b3461031d57602036600319011261031d5760043563ffffffff60e01b811680910361031d57602090637965db0b60e01b8114908115612746575b506040519015158152f35b6301ffc9a760e01b1490508261273b565b60e036600319011261031d5761276b612ec1565b612782600080516020614adb833981519152612f42565b61278e6101fc54614950565b6102658054604051916127a2604084612867565b60088352602083019260018060f81b03431684528260005261027060205260406000209051600a8110156103f95760ff6020958119905160081b1691161790558160005261026e83526127fa600460406000206147f3565b604051828152600884820152600080516020614abb83398151915260403392a26103ef8154614779565b6001600160a01b039182168152602081019290925260408201929092526060810192909252918216608082015291811660a083015290911660c082015260e00190565b90601f8019910116810190811067ffffffffffffffff82111761288957604052565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161288957601f01601f191660200190565b6001600160a01b0391821681526020810192909252604082019290925291811660608301529182166080820152911660a082015260c00190565b9060009180835261019380602052604084209260018060a01b03169283855260205260ff60408520541661292a575b50505050565b818452602052604083208284526020526040832060ff1981541690557ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b339380a438808080612924565b1561297b57565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b156129dc57565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b6163746976652070726f787960a01b6064820152608490fd5b9060ff7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435416600014612a705750612a6e9150612c6f565b565b6040516352d1902d60e01b8152602093919291906001600160a01b038316908581600481855afa60009181612c3d575b50612b015760405162461bcd60e51b815260048101879052602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201526d6f6e206973206e6f74205555505360901b6064820152608490fd5b9394937fc9f76b5ec45e5cdef99837d7b6d2467235c1df8933c8ca56df5c35afa2c7d44401612be657612b3383612c6f565b7fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a283511590811591612bde575b50612b6e57505050565b600080612bdb94612b7f602761289f565b94612b8d6040519687612867565b602786527f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c81870152660819985a5b195960ca1b604087015281519101845af4612bd5612d11565b91612d41565b50565b905038612b64565b60405162461bcd60e51b815260048101859052602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f786044820152681a58589b195555525160ba1b6064820152608490fd5b90918782813d8311612c68575b612c548183612867565b81010312612c655750519038612aa0565b80fd5b503d612c4a565b803b15612cb6577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b0319166001600160a01b03909216919091179055565b60405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b6064820152608490fd5b3d15612d3c573d90612d228261289f565b91612d306040519384612867565b82523d6000602084013e565b606090565b91929015612da35750815115612d55575090565b3b15612d5e5790565b60405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b825190915015612db65750805190602001fd5b60405162461bcd60e51b815260206004820152908190612dda906024830190612e01565b0390fd5b60005b838110612df15750506000910152565b8181015183820152602001612de1565b90602091612e1a81518092818552858086019101612dde565b601f01601f1916010190565b9081602091031261031d5751801515810361031d5790565b60975460405163d994d6d560e01b815233600482015290602090829060249082906001600160a01b03165afa9081156115f457600091612e93575b5015612e8157565b604051631dd1b1b560e21b8152600490fd5b612eb4915060203d8111612eba575b612eac8183612867565b810190612e26565b38612e79565b503d612ea2565b60ff60ca5460081c16612ed057565b60405163783bb6c960e11b8152600490fd5b15612ee957565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b8060005260206101938152604060002033600052815260ff6040600020541615612f6a575050565b6130006048612f8483612f7e601433613021565b95613021565b936040519485917f416363657373436f6e74726f6c3a206163636f756e742000000000000000000086840152612fc38151809288603787019101612dde565b82017001034b99036b4b9b9b4b733903937b6329607d1b6037820152612ff182518093888785019101612dde565b01036028810185520183612867565b612dda60405192839262461bcd60e51b845260048401526024830190612e01565b60019180831b91906001600160ff1b03811603613162576002820192838311613162576130666130508561289f565b9461305e6040519687612867565b80865261289f565b6020939085850190601f190136823785511561317857603090538451821015613178576078602186015381810180911161316257905b8082116130f05750506130ad575090565b6064906040519062461bcd60e51b825280600483015260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152fd5b9091600f8116601081101561314d57855184101561314d576f181899199a1a9b1b9c1cb0b131b232b360811b901a85840185015360041c91801561313857600019019061309c565b60246000634e487b7160e01b81526011600452fd5b60246000634e487b7160e01b81526032600452fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b600a8210156103f95752565b906040516131a960a082612867565b825481526001830154602082015260028301546001600160a01b0390811660408301526003840154811660608301526004909301549092166080830152565b919082608091031261031d57604051613202608082612867565b60608082948051845260208101516020850152604081015160408501520151910152565b909160c08284031261031d576132468251936040602085015194016131e8565b90565b906020825192015163ffffffff60e01b90818116936004811061326b57505050565b60040360031b82901b16169150565b909160a092825263ffffffff60e01b16602082015260606040820152600c60608201526b4c6f7720636f76657261676560a01b60808201520190565b909160a092825263ffffffff60e01b166020820152606060408201526015606082015274125b9cdd59999a58da595b9d081c5858c81cd95b9d605a1b60808201520190565b94919260e0969399989794919961010087019a8752602087015260408601526060850152608084015260a083015260018060a01b031660c08201520152565b909160a092825263ffffffff60e01b16602082015260606040820152601a60608201527f7141432062656c6f77206d696e696d756d20726571756972656400000000000060808201520190565b9060405161339660c082612867565b82546001600160a01b039081168252600184015460208301526002840154604083015260038401548116606083015260048401548116608083015260059093015490921660a0830152565b60a09081600180821b03918281511685526020810151602086015260408101516040860152826060820151166060860152826080820151166080860152015116910152565b909160c092825263ffffffff60e01b16602082015260606040820152602460608201527f4d617820666c757820636170616369746f72206f7065726174696f6e2072656160808201526318da195960e21b60a08201520190565b90600082815261026892602090848252604061349d818520613387565b61026480548351635a21a61960e11b81526001600160a01b039992969160c090829060c49082908c908f166134d5600484018b6133e1565b5af1908189918a93613765575b506136ec5750506134f1612d11565b986134fb8a613249565b966001600160e01b031988166306da41e560e11b810361354257505050505050600080516020614a7b8339815191529394955061353c905192839283613426565b0390a190565b869998839598969c63c39b739f60e09996991b831460001461365b57505060a0600080516020614a7b8339815191529185519088825289820152606086820152601760608201527f496e73756666696369656e7420747020746f206d696e740000000000000000006080820152a15b54169160608a01511698015197813b156136575786516358f32de960e01b81526001600160a01b039091166004820152602481019890985284908890818381604481015b03925af196871561364d576136349697613639575b505b8352522060056000918281558260018201558260028201558260038201558260048201550155565b600190565b8461364691959295612867565b923861360a565b85513d86823e3d90fd5b8580fd5b9091630b63f1a760e01b810361369457505061368c600080516020614a7b83398151915291855191829189836132b6565b0390a16135b1565b637912120160e01b036136c1575061368c600080516020614a7b833981519152918551918291898361327a565b600080516020614a9b833981519152915061368c908551918291898352878b84015287830190612e01565b8492959897507f125247fdf990b9b419d4b4f895b1bb75bc485e3f8b813cf5557a4a12a56d054d908b6136349b9c9395989651169261375d878c836060890151169784608082015116998c820151958d8251908301519160a0606087860151950151950151169451988998896132fb565b0390a461360c565b909250613780915060c03d811161170f576116fd8183612867565b929050386134e2565b90600082815261026a60209381855260406137a5818520613387565b6102648054835163ad4e666d60e01b81526001600160a01b03999296939160c090829060c49082908c908f166137de60048401896133e1565b5af1908189918a936139b0575b5061393f5750506137fa612d11565b9561380487613249565b966001600160e01b031988166306da41e560e11b810361384557505050505050600080516020614a7b8339815191529394955061353c905192839283613426565b908b9394969998916354cde31360e09997991b81146000146138df575050613882600080516020614a7b833981519152918a51918291888361333a565b0390a15b54169083896060830151169982511691015198823b156138db578751630e2c5e9960e41b81526001600160a01b03918216600482015291166024820152604481019890985284908890818381606481016135f5565b8680fd5b637912120160e01b03613914575061390c600080516020614a7b833981519152918a51918291888361327a565b0390a1613886565b600080516020614a9b833981519152915061390c908a519182918883528c8a8401528c830190612e01565b8a9193959897507f625b9fc283a619f53beb817d79b8ab044d60e307fd2af4bb89fa5e9a24ce4ebc906136349a9b8498969851169261375d878c836060890151169784608082015116998c820151958d8251908301519160a0606087860151950151950151169451988998896132fb565b9092506139cb915060c03d811161170f576116fd8183612867565b929050386137eb565b60e08183031261031d578051926132466020830151936060604085015194016131e8565b90600082815261026b80602052604093613a13858420613387565b9460018060a01b0395610264938560e08987541660c486518094819363883d21cb861b8352613a45600484018a6133e1565b5af187918291829181613c6f575b50613bf457505050613a63612d11565b97613a6d89613249565b956001600160e01b031987166306da41e560e11b8103613aad575050505050600080516020614a7b8339815191529394955061353c905192839283613426565b9682949a869998630b63f1a760e0999896991b8114600014613b93575050613aea600080516020614a7b83398151915291855191829189836132b6565b0390a15b54169160608901511697015196813b15613b8f5785516358f32de960e01b81526001600160a01b03919091166004820152602481019790975283908790604490829084905af1958615613b85576136349596613b71575b505b82526020522060056000918281558260018201558260028201558260038201558260048201550155565b83613b7e91949294612867565b9138613b45565b84513d85823e3d90fd5b8480fd5b637912120160e01b03613bc85750613bc0600080516020614a7b833981519152918551918291898361327a565b0390a1613aee565b600080516020614a9b8339815191529150613bc090855191829189835287602084015287830190612e01565b85989750907f03e9e02a94d7486426fcf2b05a27e911b8d1b61e2e1dcf103785512f46c8476491613c678887959699988e6136349e9f9951169689606082015116988a6080830151169a60208301519782519060208401519260a0606088870151960151960151169551998a998a613c94565b0390a4613b47565b91509250613c8b915060e03d8111611f7d57611f6a8183612867565b93905038613a53565b95926101009794919a9998959261012088019b8852602088015260408701526060860152608085015260a084015260c083015260018060a01b031660e08201520152565b90604051613ce760e082612867565b82546001600160a01b0390811682526001840154602083015260028401546040830152600384015460608301526004840154811660808301526005840154811660a083015260069093015490921660c0830152565b60c0908160018060a01b03918281511685526020810151602086015260408101516040860152606081015160608601528260808201511660808601528260a08201511660a0860152015116910152565b90600082815261026c602090808252604090613da9828520613cd8565b61026480548451633631a6bb60e21b81526001600160a01b039693929160e090829060e49082908c908c16613de1600484018a613d3c565b5af19088828a928b946140e5575b5061406b57505050613dff612d11565b95613e0987613249565b966001600160e01b03198816906306da41e560e11b8203613e4b57505050505050509361353c600080516020614a7b8339815191529394955192839283613426565b637a031da360e19a99929394959697989a1b8314600014613fda57505060a0600080516020614a7b833981519152918951908c82528782015260608a8201526014606082015273125b9cdd59999a58da595b9d081d1c081cd95b9d60621b6080820152a15b808254169160808401928284511690838651168a87015192823b15613fd6578b51630e2c5e9960e41b81526001600160a01b03918216600482015291166024820152604481019290925288908290606490829084905af18015613fcc57613fb4575b5090808592541692511692015191813b156136575786516353b16d1760e01b81526001600160a01b039091166004820152602481019290925284908290818381604481015b03925af1801561364d57613f9b575b5061363494955b8352522060066000918281558260018201558260028201558260038201558260048201558260058201550155565b613fa6848092612867565b613fb05738613f66565b8280fd5b9187613fc38293998895612867565b97919250613f12565b89513d8a823e3d90fd5b8a80fd5b90916354cde31360e01b810361401357505061400b600080516020614a7b8339815191529189519182918d8361333a565b0390a1613eb0565b637912120160e01b03614040575061400b600080516020614a7b8339815191529189519182918d8361327a565b600080516020614a9b833981519152915061400b9089519182918d83528b898401528b830190612e01565b84929350907f4d33a2f9c4f66a101333f7ca2ab718582e763c941ff6fc304d2d4408d43a8284916140dd8d8a6136349e9f999a9b9d9c809951169689608082015116988a60a0830151169a8d80840151978351918401519260c0606088870151960151960151169551998a998a613c94565b0390a4613f6d565b91509250614101915060e03d8111611f7d57611f6a8183612867565b92905090919238613def565b909160a092825263ffffffff60e01b16602082015260606040820152601a60608201527f7154702062656c6f77206d696e696d756d20726571756972656400000000000060808201520190565b90600082815261026d602090808252604090614177828520613cd8565b610264805484516312bce9bf60e21b81526001600160a01b039693929160e090829060e49082908c908c166141af600484018a613d3c565b5af1908189918a93614416575b506143a55750506141cb612d11565b956141d587613249565b966001600160e01b031988166306da41e560e11b810361421657505050505050509361353c600080516020614a7b8339815191529394955192839283613426565b630b63f1a760e09a999394959697989a1b8114600014614316575050614251600080516020614a7b8339815191529189519182918d836132b6565b0390a15b8082541691608084019282845116908686015191813b15614312578a516353b16d1760e01b81526001600160a01b039091166004820152602481019290925288908290818381604481015b03925af18015613fcc576142f9575b509080606092541692511692015191813b156136575786516358f32de960e01b81526001600160a01b03909116600482015260248101929092528490829081838160448101613f57565b9187614309829399606095612867565b979192506142af565b8980fd5b63272e3f5960e21b810361434d575050614345600080516020614a7b8339815191529189519182918d8361410d565b0390a1614255565b637912120160e01b0361437a5750614345600080516020614a7b8339815191529189519182918d8361327a565b600080516020614a9b83398151915291506143459089519182918d83528b898401528b830190612e01565b8392507ff8dcb57698d7067da58ab71c48cd2e3b329b69e7e9853f88630c2c69c2557c7890886136349b9c9697989a9993955116926140dd878c83608089015116978460a082015116998c820151958d8251908301519160c0606087860151950151950151169451988998896132fb565b909250614431915060e03d8111611f7d57611f6a8183612867565b9250509091386141bc565b90600082815261026e602090808252604090614459828520613cd8565b61026480548451635e272ad960e11b81526001600160a01b039693929160e090829060e49082908c908c16614491600484018a613d3c565b5af1908189918a936146cc575b5061465b5750506144ad612d11565b956144b787613249565b966001600160e01b03198816906306da41e560e11b82036144f957505050505050509361353c600080516020614a7b8339815191529394955192839283613426565b630b63f1a760e09a99929394959697989a1b83146000146145945750600080516020614a7b83398151915291506145369089519182918d836132b6565b0390a15b808254169160808401928284511690838651168787015192823b15613fd6578b51630e2c5e9960e41b81526001600160a01b03918216600482015291166024820152604481019290925288908290818381606481016142a0565b63f577bef560e01b83036145f957505060a0600080516020614a7b833981519152918951908c82528782015260608a820152601a60608201527f7154632062656c6f77206d696e696d756d2072657175697265640000000000006080820152a161453a565b9091637912120160e01b036146305750614628600080516020614a7b8339815191529189519182918d8361327a565b0390a161453a565b600080516020614a9b83398151915291506146289089519182918d83528b898401528b830190612e01565b8392507f8ab42044ce8b230e021e5542eb53688d77443e50ee84cda7917f6bdd833c697f90886136349b9c9697989a9993955116926140dd878c83608089015116978460a082015116998c820151958d8251908301519160c0606087860151950151950151169451988998896132fb565b9092506146e7915060e03d8111611f7d57611f6a8183612867565b92505090913861449e565b356001600160a01b038116810361031d5790565b813581556020820135600182015560028101906001600160a01b039061476f9060809060049084614739604089016146f2565b16956001600160601b0360a01b9687825416179055600381018561475f60608a016146f2565b16878254161790550194016146f2565b1690825416179055565b60001981146131625760010190565b6001600160a01b0361476f60a06005836147a1876146f2565b16946001600160601b03831b9586825416178155602087013560018201556040870135600282015560038101856147da60608a016146f2565b1687825416179055600481018561475f60808a016146f2565b6001600160a01b0361476f60c060068361480c876146f2565b16946001600160601b0360a01b9586825416178155602087013560018201556040870135600282015560608701356003820155600481018561485060808a016146f2565b1687825416179055600581018561475f60a08a016146f2565b610266546102655481146148c8576000526102706020526020604060002060405190614896604083612867565b546148a460ff82168361318e565b60081c91829101526001600160801b03610271541643039043821161316257111590565b50600090565b9060009180835261019380602052604084209260018060a01b03169283855260205260ff604085205416156149035750505050565b8184526020526040832082845260205260408320600160ff198254161790557f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d339380a438808080612924565b34810361495a5750565b6024906040519063049e6f6960e41b82526004820152fd5b80356101f75560208101356101f85560408101356101f95560608101356101fa5560808101356101fb5560a08101356101fc5560c08101356101fd5560e08101356101fe5561010001356101ff55565b6097546040805163d994d6d560e01b8152336004820152909291602090829060249082906001600160a01b03165afa908115614a6f57600091614a51575b50159081614a21575b50614a115750565b51631dd1b1b560e21b8152600490fd5b90506000526101936020526001816000200154600052806000203360005260205260ff8160002054161538614a09565b614a69915060203d8111612eba57612eac8183612867565b38614a00565b83513d6000823e3d90fdfe5bbebb64d62396f99cae4b3b78d9386cb0f2893aab6a69f27eb61f8e7c29775e3ea497186958ec638834f65ec5a571c2b2e877e5d59a76804ec0448fac7829babfa5d40ab595fa613b17566ea5e38a5cac79a71f09ce1435246db2e6805816c27d5e686862ec2250829eb6dee4a7cb0834865072f135485c874d3bbbe39bdfdba2646970667358221220d516e5624a1bed1b85eb5258e760f97f37799d0567946952dbd82f9ac78a43a964736f6c63430008140033",
  "devdoc": {
    "events": {
      "AdminChanged(address,address)": {
        "details": "Emitted when the admin account has changed."
      },
      "BeaconUpgraded(address)": {
        "details": "Emitted when the beacon is changed."
      },
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      },
      "RoleAdminChanged(bytes32,bytes32,bytes32)": {
        "details": "Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this. _Available since v3.1._"
      },
      "RoleGranted(bytes32,address,address)": {
        "details": "Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."
      },
      "RoleRevoked(bytes32,address,address)": {
        "details": "Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"
      },
      "Upgraded(address)": {
        "details": "Emitted when the implementation is upgraded."
      }
    },
    "kind": "dev",
    "methods": {
      "changeGovernor(address)": {
        "params": {
          "newGovernor_": "New governor address"
        }
      },
      "execute(address)": {
        "details": "does not revert on Operation failure, throws Process and Error events according to the Oper type and result"
      },
      "getRoleAdmin(bytes32)": {
        "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
      },
      "grantRole(bytes32,address)": {
        "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleGranted} event."
      },
      "hasRole(bytes32,address)": {
        "details": "Returns `true` if `account` has been granted `role`."
      },
      "makeStoppable()": {
        "details": "Should be called through governance"
      },
      "makeUnstoppable()": {
        "details": "Should be called through governance"
      },
      "pause()": {
        "details": "Should only be called by the pauser and when it is stoppable"
      },
      "proxiableUUID()": {
        "details": "Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate the implementation's compatibility when performing an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier."
      },
      "queueMintTC((uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueMintTCandTP((address,uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueMintTP((address,uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueRedeemTC((uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueRedeemTP((address,uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueSwapTCforTP((address,uint256,uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueSwapTPforTC((address,uint256,uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "queueSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))": {
        "returns": {
          "operId": "Identifier to track the Operation lifecycle"
        }
      },
      "registerBucket(address)": {
        "details": "in order to operate, the queue needs to be whitelisted as EXECUTOR on the bucket as well",
        "params": {
          "bucket_": "address of the mocCore implementation to interact with May emit a {RoleGranted} event for ENQUEUER role"
        }
      },
      "renounceRole(bytes32,address)": {
        "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`. May emit a {RoleRevoked} event."
      },
      "revokeRole(bytes32,address)": {
        "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role  OR   the caller must have be an authorized Governance changer. May emit a {RoleRevoked} event."
      },
      "setMaxOperPerBatch(uint128)": {
        "params": {
          "maxOperPerBatch_": "maximum amount of operations allowed on a batch to avoid going over the block gas limit"
        }
      },
      "setMinOperWaitingBlk(uint128)": {
        "params": {
          "minOperWaitingBlk_": "minimum amount of blocks an operation needs to remain in the queue before it can be executed"
        }
      },
      "setPauser(address)": {
        "details": "Should be called through governance",
        "params": {
          "newPauser_": "Address of the new pauser"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "upgradeTo(address)": {
        "custom:oz-upgrades-unsafe-allow-reachable": "delegatecall",
        "details": "Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      },
      "upgradeToAndCall(address,bytes)": {
        "custom:oz-upgrades-unsafe-allow-reachable": "delegatecall",
        "details": "Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."
      }
    },
    "stateVariables": {
      "__gap": {
        "details": "This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain. See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps"
      }
    },
    "title": "MocQueue: Allows queue Operation deferral execution processing",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "changeGovernor(address)": {
        "notice": "Change the contract's governor. Should be called through the old governance system"
      },
      "execute(address)": {
        "notice": "registered executors can process Operations in the queue"
      },
      "governor()": {
        "notice": "The address of the contract which governs this one"
      },
      "isEmpty()": {
        "notice": "true if the queue is empty"
      },
      "makeStoppable()": {
        "notice": "Switches ON the stoppability of the contract; if the contract was paused before making it unstoppable it will be paused again after calling this function"
      },
      "makeUnstoppable()": {
        "notice": "Switches OFF the stoppability of the contract; if the contract was paused it will no longer be so"
      },
      "pause()": {
        "notice": "Called by the owner to pause, triggers stopped state"
      },
      "paused()": {
        "notice": "Returns true if paused"
      },
      "queueMintTC((uint256,uint256,address,address,address))": {
        "notice": "registered enqueuer can queue an Operations"
      },
      "queueMintTCandTP((address,uint256,uint256,address,address,address))": {
        "notice": "Registered enqueuer can queue an Operations"
      },
      "queueMintTP((address,uint256,uint256,address,address,address))": {
        "notice": "registered enqueuer can queue an Operations"
      },
      "queueRedeemTC((uint256,uint256,address,address,address))": {
        "notice": "registered enqueuer can queue an Operations"
      },
      "queueRedeemTCandTP((address,uint256,uint256,uint256,address,address,address))": {
        "notice": "Registered enqueuer can queue an Operations"
      },
      "queueRedeemTP((address,uint256,uint256,address,address,address))": {
        "notice": "Registered enqueuer can queue an Operations"
      },
      "queueSwapTCforTP((address,uint256,uint256,uint256,address,address,address))": {
        "notice": "Registered enqueuer can queue an Operations"
      },
      "queueSwapTPforTC((address,uint256,uint256,uint256,address,address,address))": {
        "notice": "Registered enqueuer can queue an Operations"
      },
      "queueSwapTPforTP((address,address,uint256,uint256,uint256,address,address,address))": {
        "notice": "Registered enqueuer can queue an Operations"
      },
      "readyToExecute()": {
        "notice": "true if the queue has at least one Operation ready to be executed"
      },
      "registerBucket(address)": {
        "notice": "registers the mocCore bucket that would operate over this queue"
      },
      "setMaxOperPerBatch(uint128)": {
        "notice": "sets Moc Queue maximum amount of operations per execution batch"
      },
      "setMinOperWaitingBlk(uint128)": {
        "notice": "sets Moc Queue minimum operation waiting blocks"
      },
      "setPauser(address)": {
        "notice": "Changes the address which is enable to pause this contract"
      },
      "unpause()": {
        "notice": "Called by the owner to unpause, returns to normal state"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 950,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 953,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 932,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1247,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 19615,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "101",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 15749,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "governor",
        "offset": 0,
        "slot": "151",
        "type": "t_contract(IGovernor)16094"
      },
      {
        "astId": 15820,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "152",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 15889,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "stoppable",
        "offset": 0,
        "slot": "202",
        "type": "t_bool"
      },
      {
        "astId": 15891,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "_paused",
        "offset": 1,
        "slot": "202",
        "type": "t_bool"
      },
      {
        "astId": 15893,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "pauser",
        "offset": 2,
        "slot": "202",
        "type": "t_address"
      },
      {
        "astId": 16052,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "203",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 15871,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "253",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 3017,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "303",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 3400,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "353",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 184,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "_roles",
        "offset": 0,
        "slot": "403",
        "type": "t_mapping(t_bytes32,t_struct(RoleData)179_storage)"
      },
      {
        "astId": 479,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "404",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 19519,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "453",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 18932,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "tcMintExecFee",
        "offset": 0,
        "slot": "503",
        "type": "t_uint256"
      },
      {
        "astId": 18934,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "tcRedeemExecFee",
        "offset": 0,
        "slot": "504",
        "type": "t_uint256"
      },
      {
        "astId": 18936,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "tpMintExecFee",
        "offset": 0,
        "slot": "505",
        "type": "t_uint256"
      },
      {
        "astId": 18938,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "tpRedeemExecFee",
        "offset": 0,
        "slot": "506",
        "type": "t_uint256"
      },
      {
        "astId": 18940,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "swapTPforTPExecFee",
        "offset": 0,
        "slot": "507",
        "type": "t_uint256"
      },
      {
        "astId": 18942,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "swapTPforTCExecFee",
        "offset": 0,
        "slot": "508",
        "type": "t_uint256"
      },
      {
        "astId": 18944,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "swapTCforTPExecFee",
        "offset": 0,
        "slot": "509",
        "type": "t_uint256"
      },
      {
        "astId": 18946,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "redeemTCandTPExecFee",
        "offset": 0,
        "slot": "510",
        "type": "t_uint256"
      },
      {
        "astId": 18948,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "mintTCandTPExecFee",
        "offset": 0,
        "slot": "511",
        "type": "t_uint256"
      },
      {
        "astId": 19069,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "512",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 1389,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "_status",
        "offset": 0,
        "slot": "562",
        "type": "t_uint256"
      },
      {
        "astId": 1458,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "563",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 16422,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "mocCore",
        "offset": 0,
        "slot": "612",
        "type": "t_contract(MocCARC20Deferred)9522"
      },
      {
        "astId": 16424,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operIdCount",
        "offset": 0,
        "slot": "613",
        "type": "t_uint256"
      },
      {
        "astId": 16426,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "firstOperId",
        "offset": 0,
        "slot": "614",
        "type": "t_uint256"
      },
      {
        "astId": 16431,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsMintTC",
        "offset": 0,
        "slot": "615",
        "type": "t_mapping(t_uint256,t_struct(MintTCParams)12491_storage)"
      },
      {
        "astId": 16436,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsMintTP",
        "offset": 0,
        "slot": "616",
        "type": "t_mapping(t_uint256,t_struct(MintTPParams)12758_storage)"
      },
      {
        "astId": 16441,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsRedeemTC",
        "offset": 0,
        "slot": "617",
        "type": "t_mapping(t_uint256,t_struct(RedeemTCParams)12623_storage)"
      },
      {
        "astId": 16446,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsRedeemTP",
        "offset": 0,
        "slot": "618",
        "type": "t_mapping(t_uint256,t_struct(RedeemTPParams)11471_storage)"
      },
      {
        "astId": 16451,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsMintTCandTP",
        "offset": 0,
        "slot": "619",
        "type": "t_mapping(t_uint256,t_struct(MintTCandTPParams)11396_storage)"
      },
      {
        "astId": 16456,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsRedeemTCandTP",
        "offset": 0,
        "slot": "620",
        "type": "t_mapping(t_uint256,t_struct(RedeemTCandTPParams)11411_storage)"
      },
      {
        "astId": 16461,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsSwapTCforTP",
        "offset": 0,
        "slot": "621",
        "type": "t_mapping(t_uint256,t_struct(SwapTCforTPParams)11458_storage)"
      },
      {
        "astId": 16466,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsSwapTPforTC",
        "offset": 0,
        "slot": "622",
        "type": "t_mapping(t_uint256,t_struct(SwapTPforTCParams)11443_storage)"
      },
      {
        "astId": 16471,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "operationsSwapTPforTP",
        "offset": 0,
        "slot": "623",
        "type": "t_mapping(t_uint256,t_struct(SwapTPforTPParams)11428_storage)"
      },
      {
        "astId": 16487,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "opersInfo",
        "offset": 0,
        "slot": "624",
        "type": "t_mapping(t_uint256,t_struct(OperInfo)16419_storage)"
      },
      {
        "astId": 16489,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "minOperWaitingBlk",
        "offset": 0,
        "slot": "625",
        "type": "t_uint128"
      },
      {
        "astId": 16491,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "maxOperPerBatch",
        "offset": 16,
        "slot": "625",
        "type": "t_uint128"
      },
      {
        "astId": 18895,
        "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
        "label": "__gap",
        "offset": 0,
        "slot": "626",
        "type": "t_array(t_uint256)50_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IGovernor)16094": {
        "encoding": "inplace",
        "label": "contract IGovernor",
        "numberOfBytes": "20"
      },
      "t_contract(MocCARC20Deferred)9522": {
        "encoding": "inplace",
        "label": "contract MocCARC20Deferred",
        "numberOfBytes": "20"
      },
      "t_enum(OperType)16482": {
        "encoding": "inplace",
        "label": "enum MocQueue.OperType",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_struct(RoleData)179_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct AccessControlUpgradeable.RoleData)",
        "numberOfBytes": "32",
        "value": "t_struct(RoleData)179_storage"
      },
      "t_mapping(t_uint256,t_struct(MintTCParams)12491_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCore.MintTCParams)",
        "numberOfBytes": "32",
        "value": "t_struct(MintTCParams)12491_storage"
      },
      "t_mapping(t_uint256,t_struct(MintTCandTPParams)11396_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCommons.MintTCandTPParams)",
        "numberOfBytes": "32",
        "value": "t_struct(MintTCandTPParams)11396_storage"
      },
      "t_mapping(t_uint256,t_struct(MintTPParams)12758_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCore.MintTPParams)",
        "numberOfBytes": "32",
        "value": "t_struct(MintTPParams)12758_storage"
      },
      "t_mapping(t_uint256,t_struct(OperInfo)16419_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocQueue.OperInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(OperInfo)16419_storage"
      },
      "t_mapping(t_uint256,t_struct(RedeemTCParams)12623_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCore.RedeemTCParams)",
        "numberOfBytes": "32",
        "value": "t_struct(RedeemTCParams)12623_storage"
      },
      "t_mapping(t_uint256,t_struct(RedeemTCandTPParams)11411_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCommons.RedeemTCandTPParams)",
        "numberOfBytes": "32",
        "value": "t_struct(RedeemTCandTPParams)11411_storage"
      },
      "t_mapping(t_uint256,t_struct(RedeemTPParams)11471_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCommons.RedeemTPParams)",
        "numberOfBytes": "32",
        "value": "t_struct(RedeemTPParams)11471_storage"
      },
      "t_mapping(t_uint256,t_struct(SwapTCforTPParams)11458_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCommons.SwapTCforTPParams)",
        "numberOfBytes": "32",
        "value": "t_struct(SwapTCforTPParams)11458_storage"
      },
      "t_mapping(t_uint256,t_struct(SwapTPforTCParams)11443_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCommons.SwapTPforTCParams)",
        "numberOfBytes": "32",
        "value": "t_struct(SwapTPforTCParams)11443_storage"
      },
      "t_mapping(t_uint256,t_struct(SwapTPforTPParams)11428_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct MocCommons.SwapTPforTPParams)",
        "numberOfBytes": "32",
        "value": "t_struct(SwapTPforTPParams)11428_storage"
      },
      "t_struct(MintTCParams)12491_storage": {
        "encoding": "inplace",
        "label": "struct MocCore.MintTCParams",
        "members": [
          {
            "astId": 12482,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTC",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 12484,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmax",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 12486,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 12488,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 12490,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(MintTCandTPParams)11396_storage": {
        "encoding": "inplace",
        "label": "struct MocCommons.MintTCandTPParams",
        "members": [
          {
            "astId": 11385,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tp",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11387,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTP",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 11389,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmax",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 11391,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 11393,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 11395,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(MintTPParams)12758_storage": {
        "encoding": "inplace",
        "label": "struct MocCore.MintTPParams",
        "members": [
          {
            "astId": 12747,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tp",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 12749,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTP",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 12751,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmax",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 12753,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 12755,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 12757,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(OperInfo)16419_storage": {
        "encoding": "inplace",
        "label": "struct MocQueue.OperInfo",
        "members": [
          {
            "astId": 16416,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "operType",
            "offset": 0,
            "slot": "0",
            "type": "t_enum(OperType)16482"
          },
          {
            "astId": 16418,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "queuedBlk",
            "offset": 1,
            "slot": "0",
            "type": "t_uint248"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(RedeemTCParams)12623_storage": {
        "encoding": "inplace",
        "label": "struct MocCore.RedeemTCParams",
        "members": [
          {
            "astId": 12614,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTC",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 12616,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmin",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 12618,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 12620,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 12622,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(RedeemTCandTPParams)11411_storage": {
        "encoding": "inplace",
        "label": "struct MocCommons.RedeemTCandTPParams",
        "members": [
          {
            "astId": 11398,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tp",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11400,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTC",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 11402,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTP",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 11404,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmin",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 11406,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 11408,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 11410,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "6",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(RedeemTPParams)11471_storage": {
        "encoding": "inplace",
        "label": "struct MocCommons.RedeemTPParams",
        "members": [
          {
            "astId": 11460,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tp",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11462,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTP",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 11464,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmin",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 11466,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 11468,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 11470,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(RoleData)179_storage": {
        "encoding": "inplace",
        "label": "struct AccessControlUpgradeable.RoleData",
        "members": [
          {
            "astId": 176,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "members",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 178,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "adminRole",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(SwapTCforTPParams)11458_storage": {
        "encoding": "inplace",
        "label": "struct MocCommons.SwapTCforTPParams",
        "members": [
          {
            "astId": 11445,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tp",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11447,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTC",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 11449,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTPmin",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 11451,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmax",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 11453,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 11455,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 11457,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "6",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(SwapTPforTCParams)11443_storage": {
        "encoding": "inplace",
        "label": "struct MocCommons.SwapTPforTCParams",
        "members": [
          {
            "astId": 11430,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tp",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11432,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTP",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 11434,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTCmin",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 11436,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmax",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 11438,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 11440,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 11442,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "6",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(SwapTPforTPParams)11428_storage": {
        "encoding": "inplace",
        "label": "struct MocCommons.SwapTPforTPParams",
        "members": [
          {
            "astId": 11413,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tpFrom",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11415,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "tpTo",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 11417,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTP",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 11419,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qTPmin",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 11421,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "qACmax",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 11423,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "sender",
            "offset": 0,
            "slot": "5",
            "type": "t_address"
          },
          {
            "astId": 11425,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "recipient",
            "offset": 0,
            "slot": "6",
            "type": "t_address"
          },
          {
            "astId": 11427,
            "contract": "moc-main/contracts/queue/MocQueue.sol:MocQueue",
            "label": "vendor",
            "offset": 0,
            "slot": "7",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint248": {
        "encoding": "inplace",
        "label": "uint248",
        "numberOfBytes": "31"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}